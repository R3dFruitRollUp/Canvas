#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
ifids.py

dumps the data from the dce-rpc portmapper and returns the results
"""

import sys
if "." not in sys.path:
    sys.path.append(".")

import os

from exploitutils import *
from msrpcexploit import msrpcexploit
from msrpc import *
import canvasengine

NAME="ifids"
DOCUMENTATION={}
DOCUMENTATION["Notes"]=["If a port or named pipe is running DCE-RPC, then you can send a query to it asking it which endpoints it supports. This tool sends that query and returns the results. It also will brute force an endpoint that appears to be a DCE-RPC endpoint, but does not respond directly to the query by trying to bind to a list of interfaces. This list is stored in a text file in the CANVAS Resources directory"]
DOCUMENTATION["XP Note"]="On XP SP2, ifids will fail on port 135, etc. This is due to changes in the operating system, not a failure of the module"
DESCRIPTION="DCE Interface ID's Query Tool"

VERSION="1.0"

#affectsList=["Recon"]
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NOTES=""" 

"""

CHANGELOG="""

"""

# Usage from another exploit:
#        app = self.engine.getModuleExploit("dcedump")
#        app.link(self)
#        connectionList = app.getEndpointbyUUID(self.UUID) 
#
# For an protocol specific endpoint (You can, brute force if the UUID is not found with dcedump)
# 
#        app = self.engine.getModuleExploit("dcedump")
#        app.link(self)
#        connectionList = app.getHTTPEndpoint() 

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        
        self.setPort(135)
        self.setHost("")
        self.name=NAME
        self.version=0
        #MGMT UUID
        self.UUID="afa8bd80-7d8a-11c9-bef4-08002b102989"
        self.uuidversion="1.0"
        self.targetfunction=0
        self.response=1
        self.needsNoShellcode=1 #we don't need shellcode here
        self.autoversion=1
        self.namedpipe="\\browser"
        self.loadDocumentationFile()
        self.sleeptime=0
        return

       
    def neededListenerTypes(self):
        return []

    def testOS(self):

        self.log("Autoversioning, based on port")
        if self.port in [139,445]:
            self.version=2  #named pipe
        else:
            #TCP
            self.version=1

        return 1

    def buildConnectionList(self):
        self.namedpipe=self.argsDict.get("namedpipe",self.namedpipe)
        host=self.host
        
        self.target.add_to_knowledge("ifids",[]) #initialize this if necessary
        #otherwise it continues to try ifids over and over on a port 22
        #if no other ifid port is available
        
        #print "type: %s value: %s"%(type(self.port),self.port)
        if self.version==0:
            self.log("Autoversioning, based on port")
            self.testOS()
        self.log("Version: %s"%self.version)
        if self.version==1:
            #TCP
            connectionList = ["ncacn_ip_tcp:%s[%d]"% (host, self.port),
                              ]
        elif self.version==2:
            #named pipe
            connectionList = ["ncacn_np:%s[%s]"% (host, self.namedpipe),
                              ]            
        elif self.version==3:
            #http
            connectionList = ["ncacn_http:%s[%d]"% (host, self.port),
                              ]                        
        self.connectionList=connectionList
        self.log("Connectionlist: %s"%connectionList)
        return self.connectionList

    def buildDcePacket(self):
        #send nothing, function has no args
        return ""

    def parseException(self,msg):
        self.log("Parsing exception: %s"%msg)
        foundlist=[]
        #if self.covertness>2:
        #    return 0
        
        if msg.count("1c010014") and self.version==1:
            #msrpc server too busy and we are tcp
            self.log("MSRPC reported server too busy...trying all known endpoints")
            print "Self.ifidsdata: %s"%self.ifidsdata
            for interface in self.ifidsdata.keys():
                self.log("Trying interface: %s"%interface)
                documentation=self.ifidsdata.get(interface,"")
                for versionmajor in range(0,3): 
                    for versionminor in range(0,3):
                        version="%s.%s"%(versionmajor,versionminor)
                        connectionList=["ncacn_ip_tcp:%s[%d]"% (self.host,self.port)]
                        myDCE = DCE(interface, version,connectionList , covertness = self.covertness, getsock=self)
                        myDCE.setUsername(self.user)
                        myDCE.setPassword(self.password)
                        try:
                            map=myDCE.connect()
                            if map:
                                self.log("Found: %s v%s %s"%(interface,version, documentation))
                                value=[(self.port,connectionList,interface,version)]
                                foundlist+=value
                                self.target.add_to_knowledge("ifids",value)
                            else:
                                self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")                                
                        except Exception, msg:
                            pass
                            #self.log(msg)
        self.result=foundlist
        if self.result!=[]:
            self.log("Found interfaces on %s:%d"%(self.host,self.port))
            for item in self.result:
                interface=item[2]
                version=item[3]
                self.log("%s %s %s"%(interface,version,self.ifidsdata[interface]))
            return 1
        return 0
            
    def loadDocumentationFile(self, filename=None):
        "Load IFIDS data from our little file"
        if not filename:
            filename="ifids.txt"
            
        #load from resources directory
        filename=os.path.join(canvasengine.canvas_resources_directory,filename)
        self.ifidsdata={}
        fd=file(filename,"r")
        data=fd.readlines()
        for line in data:
            if line[0]=="#":
                continue
            linelist=line.split(" ")
            self.ifidsdata[linelist[0]]=" ".join(linelist[1:]).strip()
        return 
    
    def parseResponse(self,pkt):
        """Parse buffer

        Adds any ifids found to our ifids knowledge on that host
        
        pkt is really a list of DCE responses...
        """
        # print "pkt=%s"%type(pkt) for debug?
        if pkt=="":
            self.log("No response found!")
            return 0
        buf=pkt
        self.result=[]
        #print "IFIDS Buffer returned: \n%s"%prettyhexprint(buf)
        addr,buf=getint(buf) #ignored
        nument,buf=getint(buf)
        nument2,buf=getint(buf)
        buf=buf[4*nument:] #skip over this number of pointers in the array
        self.log("Number of entities in the array=%d"%nument)
        self.log("Using connectionList: %s"%self.connectionList)
        for i in range(0,nument):
            uuid,buf=get_uuid(buf)
            versionmajor,buf=getshort(buf)
            versionminor,buf=getshort(buf)
            version="%s.%s"%(versionmajor,versionminor)
            documentation=self.ifidsdata.get(uuid,"")
            self.log("%s v%s %s"%(uuid,version, documentation))
            value=[(self.port,self.connectionList,uuid,version)]
            self.result+=value
            self.target.add_to_knowledge("ifids",value)
        self.success=1
        return 1
        
        
#this stuff happens.
if __name__ == '__main__':

    app = theexploit()
    ret=standard_callback_commandline(app)
                                                                                   
