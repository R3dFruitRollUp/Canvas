#!/usr/bin/env python

import sys
if '.' not in sys.path:
    sys.path.append('.')

import time
import struct
import threading
import localsniffer


# CANVAS modules
from exploitutils import *
from tcpexploit import *


# GUI info
NAME="Passive_os_detect"
DESCRIPTION="Performs passive os detection"
DOCUMENTATION={}
DOCUMENTATION["Notes"] = """

This module is useful against filtered hosts which don't have any open ports. These hosts are still generating traffic, potentially (especially in the case of SMB/Netbios)

arguments:
    run_time (in minutes - default is 13). This is determined by how often Windows machines chat on the network.
    pof_type takes the following values: 
        1 = based on host announcement packets (SMB/Netbios detection)
        2 = based on ttl value in ip header (superset of option 1 but less accurate)
        
This module requires that the local node be able to sniff the network (currently only Linux/Root)
"""
DOCUMENTATION["Windows"]="This module has not been tested to run under windows"

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NOTES="""
"""

CHANGELOG="""
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.name=NAME
        self.covertness = 0
        self.setVersions()
        self.timeout=60
        self.dstip = ""
        self.maxthreads = 50
        self.run_time = 13
        self.pof_type = 2
        return


    def setVersions(self):
        self.versions={}
        self.versions[0]=("Passive OS detection scan", None)
        return 
    
    def getargs(self):
        self.host       = self.target.interface
        self.timeout    = float(self.argsDict.get("timeout",self.timeout))
        self.run_time   = int(self.argsDict.get("run_time",self.run_time))
        self.pof_type   = int(self.argsDict.get("pof_type", self.pof_type))
        return


    def run(self):
        self.getargs()
        #some day we need to be able to do this on remote nodes as well...
        node=self.argsDict["passednodes"][0]
        if not node.hasRawSocks():
            self.log("Cannot sniff on this Node. Did you want to select the local node? Are you running as Root on Linux?")
            self.setInfo("Sniffer failed to open (done)")
            return 0
        self.setInfo("Passive OS Detection running for %d minutes"%self.run_time)
        pof_thread = stpof(self,self.host,self.run_time,self.pof_type, engine=self.engine)
        pof_thread.exploit=self
        pof_thread.start()
        pof_thread.pof_wait()
        self.setProgress(100.0)
        self.setInfo("Pasive OS Detection (done)")
        return 1


    def displayVersions(self):
        for v in self.versions.keys():
            print "\tVersion %d: %s"%(v,self.versions[v][0])
        return 
    


# POF starting thread
class stpof(threading.Thread):

    def __init__(self, co, host, run_time, pof_type, engine=None):
        threading.Thread.__init__(self)
        self.engine = engine
        self.host     = host
        self.iface    = None
        self.run_time = run_time
        self.pof_type = pof_type
        self.pofhosts = []
        self.stop_thread = False
        self.start_time = 0
        self.min_runtime = 60 #1minute
        self.co = co
        self.pof_complete=False
        self.exploit=None 
        return 
    
    def log(self, msg):
        """
        We're not an exploit ,so we log using our exploit or engine if found, otherwise just print
        """
        if self.exploit:
            self.exploit.log(msg)
        else:
            if self.engine:
                self.engine.log(msg)
            else:
                print msg
        return 
    
    def run(self):
        self.log("Passive OS detection thread invoked")
        ret = self.autoprobe_interface(self.host)
        if ret == False:
            return
        else:
            [self.iface, self.netmask, self.ip] = ret

        self.start_time = time.time()
        self.pofwinSense(self.run_time,self.pof_type)
        self.pof_complete = True
        return

    def pof_wait(self):
        while not self.pof_complete:
            time.sleep(1)
        return

    def autoprobe_interface(self, ip):
        """
        Odd, because all this data is in the Node
        self.argsDict["passednodes"][0].
        """
        for ifc in getAllLocalIPs():
            tmpip = ip.split(".")
            tmpip1 = ifc[1].split(".")
            if(tmpip[0] == tmpip1[0]):
                iface   = ifc[0]
                netmask = nmask2cidr(socket.inet_ntoa(struct.pack(">L", ifc[2])))
                tip   = ifc[1]
                tbuf = "Auto probed interface: %s, netmask: %d, IP: %s"%(iface, netmask, ip)
                self.log(tbuf)
                return [iface,netmask,ip]

        if self.iface==None:
            self.log("Cannot probe interface, please select a target that falls in your interface range")
            return False

    # Does passive os detection for windows machines (wait_time in minutes) 
    # arg_type:
    #1 = based on host announcement packets
    #2 = based on ttl value in ip header (superset of option 1 but less accurate)

    def pofwinSense(self, wait_time, arg_type):
        if arg_type == 1:
            filterStr = "type(ETH) udpsource(138) udpdest(138)"
        elif arg_type == 2:
            filterStr = "type(ETH) ipttl(128)"
        else:
            return False

        ssnif = self.start_sniffer(self.pofwinPack, filterStr)

        self.log("Sleeping for: "+ str(wait_time) + "min. for passive OS detection")

        for i in xrange(0,wait_time*60):
            time.sleep(1)
            if self.stop_thread == True:
                self.log("Passive OS Detection was told to stop")
                break

            # CALCULATE (downscale to 90% for the previous 10% allocation in interface autofind code
            # the percent of the timer and update progress bar
            #perc = 0.9 * (i/(wait_time*60.0))+0.1
            #self.co.setProgress(perc*100)

        self.stop_sniffer(ssnif, self.pofwinPack)

        #print "Hosts found: "+ str(self.pofhosts)
        return self.pofhosts


    def stop_pof(self):
        time_diff = time.time() - self.start_time
        if time_diff < self.min_runtime:
            self.log("We are only running for: "+ str(time_diff) + "but minimum run time is: "+ str(self.min_runtime))
            sleep_more = self.min_runtime - time_diff
            self.log("We are going to sleep for another:" +  str(sleep_more))
            for cyberia in range(0,int(sleep_more)):
                if self.co.state==self.co.HALT:
                    break
                time.sleep(1)
        self.stop_thread = True
        time.sleep(1) # Allow sometime for pof to stop
        return

    # Adds the discovered windows host into the host list
    def pofwinPack(self, parsobj):
        pofhost = parsobj.attribs.get("ipsource", False)
        if pofhost and (pofhost not in self.pofhosts):
            if pofhost not in [ "0.0.0.0", "127.0.0.1" ]:
                self.log("Passive OS Detect - Found host: "+ str(pofhost))
                self.pofhosts.append(pofhost)
        return


    def start_sniffer(self, func, filterstr):
        if hasattr(self, "engine")==False or self.engine == None:
            self.log("No engine registered, starting our own sniffer...")
            ssnif = localsniffer.localsniffer()
            ssnif.start()
        else:
            ssnif = self.engine.localsniffer

        self.log("Passive OS Detection using iface: %s with filter string: %s and function callback: %s"%(self.iface, filterstr, func.func_name))
        ssnif.registercallback(func, filterstr)

        return ssnif


    def stop_sniffer(self, snif, func):
        snif.unregistercallback(func)
        if hasattr(self, "engine")==False or self.engine==None:
            snif.shutdown()
            del(snif) 
        return


if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)



