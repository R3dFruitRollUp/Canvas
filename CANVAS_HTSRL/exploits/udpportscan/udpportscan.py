#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
TODO : Add a test for packet loss and automatically adjust the number of iterations
to adjust for that.
"""
# CANVAS UDP Portscan module
#
# Bug class: Recon
# 

import sys
if "." not in sys.path: sys.path.append(".")

import socket
import timeoutsocket
import time
import select

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from sniffer import sender
from sniffer import packetConstructor
from sniffer import packetParser

# GUI info
NAME="UDP Portscan "
VERSION="1.0"
DESCRIPTION="Scans for open UDP Ports"
DOCUMENTATION={}
DOCUMENTATION["Notes"]=""" UDP Portscanning typically works by sending UDP
packets to different ports on your target and waiting for ICMP Port
Unreachable to come back. Future UDP scanners would have a list of ports which
they know how to elicit real responses from, of course, but we're not there
yet with this scanner.

This kind of scanner does have the potential for errors. There's really two
places where UDP scanning can have errors due to packet loss. One is in the
sending of UDP packets - you might be sending so fast that they get dropped.
Or they might be getting dropped randomly by overloaded network equipment
somewhere.

Likewise, the ICMP messages coming back to you can be dropped anywhere along
the way. So each port is tested multiple times to ensure that things are
working properly.

"""

VERSION="1.0"
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NOTES="""

"""

CHANGELOG="""
"""


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        # used for done flag from commandline
        self.done = 0
        self.port=53 
        self.fromport=53 #if fromport is 0 we randomize it
        self.closedports={}
        self.openhosts=[]
        self.name=NAME
        self.covertness = 0
        self.setVersions()
        self.timeout=60
        self.result=self.openhosts
        #source=self.engine.get_callback_interface().ip
        self.source="127.0.0.1"
        self.netmask="32"
        self.postHTTP=False
        self.portlist=None 
        self.startport=1
        self.endport=65536 #+1 really
        self.iterations=10 
        self.sleeptime=0.001 #between packets
        return
        
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Fast CANVAS Scan (requires root)", None)
        self.versions[1]=("UDP Connect Scan", None)
        
    def test(self):
        """All targets can be portscanned"""
        return 1
    
    def snooze(self, seconds):
        self.log("Snoozing (%d seconds)"% seconds)
        while seconds:
            self.log("%.2d seconds left in snooze"% seconds)
            time.sleep(1)
            seconds = seconds - 1 
        return 1

    def port_callback(self,parser):
        devlog("udpportscan", "Callback got triggered for udpportscan")
        data=parser.attribs["icmpdata"]
        if len(data)<28:
            return 
        from_port=str2int16(data[26:28])
        devlog("udpportscan","From port ICMP Reset found: %d"%from_port)
        self.closedports[from_port]=True 
        return

    def C_isOpen(self, host, port):
        s=self.gettcpsock()
        s.set_timeout(self.timeout)
        try:
            self.log("Probing host %s:%s"%(host,port))
            s.connect( (host, port))
        except socket.error, msg:
            self.log("Error: %s"%msg)
            if str(msg).count("No route to host"):
                return -1
            return 0
        except timeoutsocket.Timeout:
            return -1
        s.close()
        return 1
    
    def run_on_host(self,target):
        """
        runs once on each host that is alive in the netrange
        """
        host=target.interface

        if self.state==self.HALT:
            return 
        
        if self.doscanrand:
            mysender=sender()
            
        for i in range(0,self.iterations):
            #test each port multiple times.
            numports=len(self.portlist)-len(self.closedports.keys())
            if numports==0:
                self.log("All ports were closed")
                break 
                
            self.log("Running iteration %d on %d ports"%(i,numports))
            for port in self.portlist:
                if self.state==self.HALT:
                    return 

                if port%1000==0:
                    self.log("Testing port %d"%port)
                if port in self.closedports:
                    #no need to test this port, already know it's closed
                    continue
                if self.doscanrand:
                    
                    mpacker=packetConstructor()
                    #self.port is really self.fromport here
                    #print "source=%s dest=%s"%(source,dest)
                    mpacker.UDP(self.source,host,self.fromport,port,"")
                    mysender.sendto(mpacker.get(),"UDP",(host,0))
                    #if you don't sleep, you'll miss some ports. 
                    time.sleep(self.sleeptime)
                    
                else:
                    ret=self.C_isOpen(host, self.port)
                    if ret==1:
                        self.log("Found %s port %d open"%(host,self.port))
                        self.openhosts.append(host)
        
                    elif ret==0:
                        self.log("Found %s port %d closed"%(host,self.port))
                        self.closedhosts.append(host)      
                        
        if self.state!=self.HALT:
            #if we are not halted, let's wait for the rest of the packets just in case
            self.log("Sleeping for 5 seconds to recover all packets")
            time.sleep(5)
                
        return

    def getargs(self):
        self.host=self.target.interface
        self.timeout=float(self.argsDict.get("timeout",self.timeout))
        self.source=self.argsDict.get("source",self.engine.get_callback_interface(self.host))
        self.netmask=self.argsDict.get("netmask",self.netmask)
        self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
        self.fromport=int(self.argsDict.get("fromport",self.fromport))
        self.port=int(self.argsDict.get("port",self.port))
        self.getarg("portlist")
        self.getarg("startport")
        self.getarg("endport")
        self.getarg("iterations")
        self.sleeptime=float(self.argsDict.get("sleeptime", self.sleeptime))
        return 
    
    def run(self):        
        self.getargs()
        
        if isinstance(self.netmask, str):
            self.netmask=int(self.netmask.replace("/",""))
            
        self.setInfo("UDP Portscanning %s"%(self.host))
        self.node=self.argsDict["passednodes"][0]
        self.log("Timeout=%s"%self.timeout)
        self.doscanrand=0
        
        #don't do syn-scan if we're a SILICA        
        #if self.can_scanrand() and not self.argsDict.get("silica"):
        if self.can_scanrand():
            if not self.engine.sniffer_isactive():
                self.log("sniffer not active")
                self.setInfo("Portsweep: Not running as root - sniffer not active")
            else:
                self.doscanrand=1
                openfs="icmpsource(%s) icmpcode(3)"%(self.host)
                #print "self.port_callback=%s"%self.port_callback
                self.engine.register_sniffer_callback(self.port_callback,openfs)
        else:
            self.log("Currently this module only supports hosts with sniffer support")
            self.setInfo("UDP Portscan failed (not on sniffer host)")
            return 0
        if not self.portlist:
            self.portlist=range(self.startport, self.endport)
        else:
            #convert from string
            #TODO: Not done yet
            self.portlist=portlist_from_string(self.portlist)
        self.log("UDP Portscan running on %d ports"%len(self.portlist))
        self.run_on_host(self.target)
        openports=[]
        #need to use Set module here for speed
        for i in self.portlist:
            if i not in self.closedports:
                openports+=[i]
                
        self.target.add_to_knowledge("CLOSEDUDPPORTS",self.closedports)

        self.log("Found following UDP ports open on host %s: %s"%(self.host, openports)) 
        self.result=openports 
        if self.doscanrand:
            self.engine.unregister_sniffer_callback(self.port_callback)
        self.log("All done")            
        return 1

    def displayVersions(self):
        for v in self.versions.keys():
            print "\tVersion %d: %s"%(v,self.versions[v][0])


    #def usage(self):
    #    import sys
    #    #print "Usage: %s -t host -l localhost [-c covertness]"% sys.argv[0],
    #    self.displayVersions()

if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
    
