#! /usr/bin/env python
"""
VulnAssess.py


"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


NAME="VulnAssess"
VERSION="1.0"
NOTES2="""

"""

CHANGELOG="""
1.0 
Created.

Added toggles for whereami/traceroute at customer request alexm@ 8/14/08
"""

DEBUGNOTES="""

"""

import os,getopt
import sys
paths = (".", "exploits/passive_os_detect")
for i in paths:
        if i not in sys.path:
                sys.path.append(i)

import passive_os_detect
import timeoutsocket



import socket
from exploitutils import *




from tcpexploit import tcpexploit
from msrpc import *
import canvasengine
import time

from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

import libs.canvasos as canvasos
from engine.config import canvas_reports_directory

DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
For a given network range do the following actions:
1. Find all the alive hosts
2. For each alive host do an osdetect which generates an os basename
             Portscan each alive host from 1-10000
             If port 88 is open and os is Windows, then it is a domain server, so note that.
             If port 1433 is open, it is a SQL Server, so note that.
             If port 80 is open, it is a web server, so note that.
3. For each exploit in our exploit modules list, check to see which ones match that 
basename and run their test function
4. For each exploit in an explicit internal list, if the basename matches, run
the exploit and see if we get in. If so, drop a file, and disconnect.
5. Write a little report about it using our reporting module
"""

DOCUMENTATION["Todo"]="""
Future releases want to fingerprint each host so that if a host changes IP, we still
know where it is.
"""


NAME="VulnAssess"
DESCRIPTION="Safe Vulnerability Assessment Tool"

VERSION="0.1"

#affectsList=["Recon"]
PROPERTY = {}
PROPERTY['TYPE'] = "Tools"

GTK2_DIALOG="dialog.glade2"

NOTES=""" 

"""

import libs.reporting as reporting
from hostKnowledge import *
from engine.config import canvas_resources_directory
import os

class theexploit(tcpexploit):
        def __init__(self):
                tcpexploit.__init__(self)
                self.vulns=[]
                self.setPort(0)
                self.setHost("")
                self.setVersion(1)
                self.istest=0
                self.setVersions()
                self.shellcode="A"
                self.localhost=""
                self.localport=0
                self.ssl=0
                self.doshell=1
                self.force=0
                self.name=NAME
                self.netmask="32"
                self.report=None
                self.portscan=1 #default is do a portscan
                self.autohack_state=False 
                self.portlow=1
                self.porthigh=1100
                self.silica=False
                self.ssid=self.tpref=""
                self.do_testhost=False #should we run testhost (default is NO, instead we run a list of preselected recon modules)
                self.passive_detector=None 
                self.traceroute=True # Toggle traceroute, added at customer request
                self.whereami=True # Same request as above
                return

        def run_on_host(self,target):
                """ 
                runs once on each host that is alive in the netrange 
                """
                if self.state==self.HALT:
                        self.log("Not running on target %s, halted"%target.interface)
                        return 0

                host=target.interface
                self.report.newhost(target)
                self.log("Running on %s"%host)
                self.setInfo("Running on %s"%host)
                
                # Do a traceroute for the reporting
                if self.traceroute == True:
                        try:
                                app=self.engine.getModuleExploit("traceroute")
                                app.link(self)
                                app.target=target
                                ret=app.run()
                                if ret:
                                        app.setProgress(100)
                                else:
                                        app.setProgress(-1)
                                mytrace=app.result
        
                        except:
                                import traceback
                                traceback.print_exc(file=sys.__stdout__)
                                self.log("No traceroute")
        
        
                        tracelist = target.get_knowledge("TraceList", None)
                        if tracelist:
                                self.report.note(target, "%s"%str(tracelist))
                else:
                        self.log("Traceroute set to off, proceding")

                try:
                        app=self.engine.getModuleExploit("osdetect")
                        app.link(self)
                        app.target=target
                        ret=app.run()
                        if ret:
                                app.setProgress(100)
                        else:
                                app.setProgress(-1)
                        myos=app.result
                except:
                        import traceback
                        traceback.print_exc(file=sys.__stdout__)
                        self.log("Not determining OS - use osdetect exploit module")
                        myos=canvasos.new("Unknown")
                        
                
                target.add_knowledge("OS", myos,100)
                if self.portscan:
                        results=self.exploitnodes("portscan",target=target,
                                                  args={"mode" : "portrange", "portlow": self.portlow, "porthigh": self.porthigh})
                        results=results[0]
                else:
                        results=[]
                        self.log("Portscan not requested by user")
                try:
                        basename=myos.basename()
                except:
                        #if it's a string, take the first word
                        #it should NOT be a string. So fix this too.
                        devlog("osdetect", "Bug in osdetect that returned %s"%myos)
                        basename=str(myos).split(" ")[0]


                self.log("Base OS for ip %s: %s"%(target.interface,basename))
                self.log("Open ports on host %s: %s"%(target.interface,results))
                if "Windows" in basename:

                        if 88 in results:
                                self.report.note(target,"This host appears to be a domain controller (kerberos is available)")
                        if 3389 in results:
                                self.report.note(target,"This host is likely managed by Term Services")

                #sometimes Unix has this too...(think samba)
                lanman=target.get_knowledge("Lanman",None)
                smbdomain=target.get_knowledge("SMBDomain",None)
                smbserver=target.get_knowledge("SMBServer",None)
                shareenum=target.get_knowledge("SMBShares",None)

                if lanman:
                        self.report.note(target,"%s"%str(lanman))
                if smbdomain:
                        self.report.note(target,"%s"%str(smbdomain))
                if smbserver:
                        self.report.note(target,"%s"%str(smbserver))
                if shareenum:
                        text=shareenum.get_all_text()
                        devlog("hostKnowledge", "Share Text: %s"%text)
                        self.report.note(target,"%s"%prettyprint(text))

                language=target.get_knowledge("Language", None)
                if language:
                        self.report.note(target, "%s"%str(language))

                #we also want a PrintProvider list 
                printproviders=target.get_knowledge("PrintProviders",None)
                if printproviders:
                        self.report.note(target,"%s"%prettyprint(printproviders.get_all_text()))

                if self.do_testhost:
                        self.log("Running testhost against it")
                        result=self.exploitnodes("testhost")[0]
                        self.report.note(target,"Testhost returned: %s"%result)

                scanmodnames=file(os.path.join(canvas_resources_directory,"vulnassess.txt"),"rb").readlines()
                scanmodnames=map(str.strip,scanmodnames)

                scanmods = canvasengine.getModules(scanmodnames)
                #scanmods = canvasengine.exploitmodsGet()
                #exploitmods = []
                #exploitmods=[]
                totalmods=len(scanmods)
                currentmod=1        
                self.log("Vulnerability assessment has %d modules loaded total"%totalmods)
                for module in scanmods:
                        if self.state==self.HALT:
                                self.log("Halted - not continuing scan")
                                return 0
                        try:
                                self.log("Property = %s Basename=%s"%(module.PROPERTY["ARCH"],basename))
                                found=0
                                for prop in module.PROPERTY["ARCH"]:
                                        if prop[0]==basename:
                                                found=1
                                if not found:
                                        continue
                        except:
                                #no property in module
                                continue

                        try:
                                astr="Scanning with %s"%module.DESCRIPTION
                        except:
                                try:
                                        print "Could not find a description in %s"%module.NAME
                                        astr=module.NAME
                                except:
                                        print "Error: Module has no name?"
                        self.log(astr)
                        #debug
                        print astr
                        progress=round((currentmod*100)/totalmods)
                        #print "CurrentMod %d Total Modules: %d Progress %d"%(currentmod,totalmods,progress)
                        self.setProgress(progress)
                        currentmod+=1
                        try:
                                app=module.theexploit()
                        except:
                                try:
                                        mystr="No theexploit class in module %s"%module.DESCRIPTION
                                except:
                                        mystr="No theexploit class in module!"
                                self.log(mystr)
                                continue
                        app.link(self)

                        #set the defaults for exploits not using correct syntax
                        defaultlist=["port","user","password","filename"]
                        for i in defaultlist:
                                if i in dir(app):
                                        #print "FOUND: %s"%i
                                        app.argsDict[i]=getattr(app,i)

                        app.argsDict["passednodes"]=self.argsDict["passednodes"]
                        defaultlist=["user","password","filename"]
                        for i in defaultlist:
                                if i in self.argsDict:
                                        app.argsDict[i]=self.argsDict[i]
                        app.argsDict["netmask"]="32"
                        app.target=target
                        app.argsDict["autohack_state"]=self.autohack_state
                        #print "ArgsDict=%s"%app.argsDict
                        try:
                                ret=app.run()
                                if ret:
                                        app.setProgress(100)
                                else:
                                        app.setProgress(-1)
                                if app.result:
                                        result=app.result
                                        #convert these to a string if they are a list of objects like dcedump is
                                        if isinstance(result , list):
                                                result=map(str, result) 
                                        self.report.note(target,"%s: %s"%(app.name,str(result)))
                        except:
                                self.log("Run returned exception: fix this.")
                                import traceback
                                traceback.print_exc(file=sys.stdout)
                return

        def getargs(self):
                self.host=self.target.interface
                self.netmask=dInt(str(self.argsDict.get("netmask",self.netmask)).split(".")[0])
                self.portscan=int(self.argsDict.get("portscan",self.portscan))
                self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
                self.getarg("do_testhost") #if we want testhost
                # Added for customer requests
                print self.traceroute
                if bool(self.argsDict.get("traceroute", self.traceroute)) == False:
                        self.traceroute = True
                else:
                        self.traceroute = False

                if bool(self.argsDict.get("whereami", self.whereami)) == False:
                        self.whereami = True
                else:
                        self.whereami = False
                #silica vars
                self.ssid=self.argsDict.get("ssid", "")
                self.silica=self.argsDict.get("silica",self.silica)
                self.tpref=self.argsDict.get("tpref",self.tpref)
                return


        def scan_lock(self):
                print "Creating lock file...",
                fp = open("SCAN_LOCK", "w")
                fp.close()
                print "done"
                return


        def scan_unlock(self):
                print "Unlocking any active/stale files...",
                try:
                        os.unlink("SCAN_LOCK")
                except:
                        pass
                print "done"
                return


        def finish(self):
                if self.argsDict.get("silica"):
                        self.scan_unlock()            

                return 


        def run(self):
                sil_flag=False
                if self.argsDict.get("silica"):
                        self.scan_lock()
                        sil_flag=True
                self.getargs()
                self.log("Interface=%s"%self.host)
                self.log("Netmask=%s"%self.netmask)
                self.log("Maxthreads for VulnAssess: %d"%self.maxthreads)
                self.log("Whereami set to: %s"%self.whereami)
                self.log("Traceroute set to: %s"%self.traceroute)
                
                self.report=reporting.report(self.tpref, sil_flag)
                self.vulns=[] #clear it

                try:
                        if not canvasengine.registeredallmodules:
                                canvasengine.registerAllModules()

                        self.node=self.argsDict["passednodes"][0]
                        dothreads = "threads" in self.node.capabilities
                        if not dothreads:
                                self.log("Warning: not using threads because select node does not support threading")


                        # Start passive os detection thread here
                        if sil_flag:
                                pof_thread = passive_os_detect.stpof(self,self.host,180,2)
                                pof_thread.start()


                        self.setInfo("[VulnAssess] Scanning network: %s/%s"%(self.host, self.netmask))
                        self.setProgress(5)

                        # Run whereami to note where we're running from
                        # Added toggle for customer 8/14/08
                        if self.whereami == True:
                                app=self.engine.getModuleExploit("whereami")
                                app.link(self)
                                ret=app.run()
                        else:
                                self.log("Whereami set to off, proceding")
                                
                        self.run_on_all_alive_hosts(threads=dothreads)
                        if sil_flag:
                                pof_thread.stop_pof()
                                print "Up to now we found: ", pof_thread.pofhosts
                                self.report.pofhosts = pof_thread.pofhosts
                        else:
                                self.report.pofhosts = []

                        data=self.report.generate_vulnassess_html()

                        if(self.silica):
                                tdate = time.time()
                                filename = "%sVA_Report_%s_%s_%s.html"%(self.tpref, self.ssid,self.host,tdate)
                        else:
                                filename="Vulnassess_report_%s_%s.html"%(self.host,self.netmask)

                        filename = filename.replace("/", "")
                        filename=os.path.join(canvas_reports_directory,filename)
                        file(filename,"wb").write(data)
                        self.log("Wrote HTML formatted report to: %s"%filename)
                        self.setInfo("VulnAssess scanning %s (done)"%(self.host))
                        self.finish()

                except:
                        self.finish()
                        raise #this will raise the exception again 

                return 1

        def setVersions(self):
                self.versions={}

                self.versions[1]=("All", None)


        def displayVersions(self):
                for v in self.versions.keys():
                        print "Version %d: %s"%(v,self.versions[v][0])


def usage():
        app = theexploit()
        print "Usage: "+sys.argv[0]+" [-T] [-v version]  -t target [ -p targetport:%d]"%(app.port)
        app.displayVersions()
        sys.exit()

#this stuff happens.
if __name__ == '__main__':
        print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
        app = theexploit()
        ret=standard_callback_commandline(app)

