#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
exploitmanager.py - operates a thread and manages an exploit for the engine
"""

import sys
from threading import Thread
from internal import *
import time

#list of exploits to not add to knowledge tree
ignorelist=["CANVAS Exploit"]

class exploitmanager(Thread):
    """
    Runs in its own thread so the exploit doesn't have to
    handles teardown of the exploits globally, setting the progressbar
    and any other variables that need to be set, such as state
    """
    def __init__(self,exploit,engine, daemonFlag=None):
        Thread.__init__(self, verbose=debug_threads)
        self.runcrashtest=0 #by default we do not run our crash test
        self.exploit=exploit
        self.engine=engine
        self.listLog=None

        # XXX: do not re-init self.prompt if we want to have randomisation ;)
        # switched from self.prompt to self.localPrompt
        self.localPrompt = "(CANVAS)"

        # do we really need this ?
        if not hasattr(self.exploit, 'shutdown'):
            self.setDaemon(1) # XXX should not be used if we use threadutils_add()

        # XXX: we want to be able to force a daemonFlag for the threading
        # XXX: if isDaemon() is True for SILICA context runs (the above code sets it true)
        # XXX: then run() never gets inited

        if daemonFlag in [True, False]:
            self.setDaemon(daemonFlag)

        threadutils_add(self)
        self.name = "CANVAS Exploit"
        if hasattr(self.exploit, 'name'):
            self.name = self.exploit.name
        devlog('exploitmanager::__init__', "initialized")
        self.exploit.setInfo("%s" % self.name)
        self.ret=None #return value from exploit
        self.newnode=None
        #We wait many minutes here for a node to start up
        #largely because SILICA takes that long
        #exploits should NOT return 1 unless successfully starting a new node on Silica
        if hasattr(self.engine, "silica") and self.engine.silica:
            self.waitfornewnode=60*20 #after an exploit has finished, we wait this long for a new node to startup()
        else:
            self.waitfornewnode=60*2 #two minutes by default otherwise
        self.state="Running"
        return 
    
    def getprompt(self):
        if hasattr(self.exploit, 'argsDict') and self.exploit.argsDict.has_key('passednodes'):
            node = self.exploit.argsDict['passednodes'][0]
            if hasattr(node, 'shell') and hasattr(node.shell, 'getprompt') and \
                node.shell.getprompt != getattr(self, 'getprompt'):
                return node.shell.getprompt(self.localPrompt)
            if hasattr(node, 'getprompt') and node.getprompt != getattr(self, 'getprompt'):
                return node.getprompt(self.localPrompt)
        return self.localPrompt + ' '

    def listener_log(self,log):
        self.listLog=log
        return 
    
    def test(self):
        """
        This code runs the exploit's test function and then using that information
        will start up a listener of the correct type
        """
        devlog('exploitmanager', "exploitmanager::test()")
        app=self.exploit
        #app.test() will set the version, and possibly the neededListenerTypes()
        ret=app.test()
        if ret:
            #if test succeeded, we then can do our crashtest()
            self.runcrashtest=1
        # make sure we update the argsdict
        app.argsDict["version"] = app.version
        

        sys.stdout.flush()

        
        #this code is duplicated in canvasengine, be careful
        neededlistenertypes=app.neededListenerTypes()

        if neededlistenertypes!=[]:
            devlog("exploitmanager", "Exploit wants %s listener"%neededlistenertypes)

            # XXX fix for autofind control needed in httpserver (and likewise) situations
            # XXX where app.target.interface != actual wanted matching callback for autofind

            autoFind = True
            try:
                autoFind = app.autoFind
            except:
                autoFind = True
            devlog("canvasengine", "Doing autolistener from exploitmanager:test()")
            listener=self.engine.autoListener(neededlistenertypes[0],app.target.interface, autoFind=autoFind)

            if listener==None: #still none? Then print error message
                self.engine.log("You need to select a valid listener %s for this exploit! (Is it blue?)" % \
                    (app.neededListenerTypes()))
                return 0
            #print "Setting listener %s argsdict to %s"%(listener, app.listenerArgsDict)
            listener.argsDict=app.listenerArgsDict
        else:
            devlog("exploitmanager","No need for a listener for this exploit")
            listener=None
        devlog("exploitmanager","Setting app.callback to %s"%listener)
        app.callback=listener #note: this is a listener, not an interface!
        if app.callback:
            #clear this so we can know if we succeeded
            app.callback.lastnewnode=None
        return ret
    
    def _return_from_run(self, retval):
        threadutils_exiting(self)
        return retval
    
    def run(self):
        """
        Run the exploit...called from Thread.start()
        """
        ret=0 #our return value
        self.exploit.dispshellcmd = None
        devlog('exploitmanager', "Exploitmanager running")

        #self.test() is not called by the engine before getting into here. We do
        #it manually
        if 1:
            try:
                if self.exploit.version==0:
                    self.runcrashtest=True
                    if not self.test():
                        self.runcrashtest=False 
                        #possible we were meant to be at 0
                        pass
                        #self.exploit.log("Testing failed!")
                        #return 0
            except AttributeError:
                # exploit doesn't have a version
                pass

        callback=self.exploit.callback
        devlog("exploitmanager", "Set callback to %s"%callback)
        #so he knows who to inform when successful
        if callback:
            devlog('exploitmanager',"Setting callback's current_exploit")
            callback.current_exploit=self.exploit
            callback.busy=1
 
        target=self.exploit.target
        ret=1
        #removed temporarally
        if False and (self.exploit.version==0):
            #didn't we already do this?
            devlog('exploitmanager', "Exploit testing")
            if self.test():
                self.runcrashtest=1

        if ret:
            try:
                devlog('exploitmanager', "Exploit create shellcode")
                self.exploit.createShellcode()
            except:
                #error in creating shellcode
                import traceback
                import sys
                print "Error in %s"%self.exploit.name
                traceback.print_exc(sys.stdout)
                return self._return_from_run(0)
            
            #so he knows who to inform when successful
            if callback:
                callback.current_exploit=self.exploit
                callback.busy=1
            
            try:
                devlog('exploitmanager', "Exploit running")

                ret=self.exploit.run()
                devlog('exploitmanager', "self.exploit.run() returned %s" % ret)
            except self.exploit.error,msg:
                import traceback
                import sys
                traceback.print_exc(file=sys.stdout)
                self.exploit.log("Failed: %s" % str(msg))
                ret=0
            except:
                from exploitutils import bugreport
                bugreport()
                import sys,traceback,string
                from StringIO import StringIO
                s=StringIO()
                traceback.print_exc(file=s)
                s.seek(0)
                self.exploit.debuglog("=-=-=- Traceback -=-=-=\n" +string.join(s.readlines(), ""))
                info=sys.exc_info()
                # do we print traceback here?
                self.exploit.log("Failed (%s):  %s" % (str(info[0]), str(info[1])))
                ret=0
        

        self.ret=ret #set our state to match that of the exploit
        devlog("exploitmanager", "Exploit %s returned %s"%(self.exploit.name,ret))
        if ret in [0,None,-1]:
            #Exploit failed...
            self.exploit.setProgress(-1)
            if self.runcrashtest:
                self.exploit.check_crashed() #check to see if it died...
            if self.exploit.target:
                #we first assume the target is a host object, as it normally is
                try:
                    self.exploit.target.add_knowledge("Not Vuln To", self.exploit.name,0)
                except AttributeError:
                    #try this, although it's not perfect, if you passed in a string as self.exploit.target
                    #we try to get the node you are using
                    node=self.exploit.argsDict["passednodes"][0]
                    try:
                        #and hopefully it has a target with that ip
                        target=node.get_known_host(self.exploit.target)
                        if target:
                            #if so, we'll add the knowlege,hoping it was correct :>
                            target.add_knowledge("Not Vuln To", self.exploit.name,0)
                    except:
                        pass
        else:
            #exploit succeeded - it either returned a new node or it returned 1
            self.exploit.setProgress(100)

            if type(ret) == str:
                devlog("exploitmanager", "Exploit has no node it just returns us the value we need")
                
            elif ret!=1:                    
                if type(ret) in [type(1), type(1L)]:
                    devlog("exploitmanager","Warning: exploit returned an integer that was neither 0 nor 1! %s"%type(ret))
            
                #must have returned a new node...
                self.newnode=ret
                #exploits are responsible for setting the parent node!
                ret.startup() #get the interfaces and whatnot.
                
                #startup=self.engine.getModuleExploit("startup")
                #startup.link(self)
                #argsDict={}
                #argsDict["host"]=self.exploit.target
                #argsDict["passednodes"]=[ret]
                #startup.argsDict=argsDict
                #startup.run()
                
                if ret.parentnode==None:
                    self.exploit.log("THIS EXPLOIT HAS A BUG: did not properly set parentnode")
                else:
                    ret.parentnode.newNode(ret)
                    ret.update_gui()
                self.engine.newNode(ret)
                app=self.exploit
                devlog('exploitmanager', "Stole socket: Calling the postactions handlers on the new node!")
                self.engine.dopostactions(ret,app)
                
            else:
                #Fixed, see below
                #The CANVAS engine will inform the exploit that it has succeeded before
                #it has initialized the new Node. So we reach this point in our code
                #and the new node is still initializing ... future actions should 
                #get caught by the new node's startup() though. So we should be ok.
                
                #ret WAS a 1, indicating success. Now we need to see if 
                #there is a listener that connected back to us
                devlog('exploitmanager', "Exploit returned success but did not steal the socket")
                if self.exploit.callback:
                    devlog('exploitmanager', "Exploit has a callback, as it probably should")
                    #there was a listener, but lastnewnode isn't set until the node
                    #finishes starting...so we wait X Minutes or so (see self.waitfornewnode)
                    #this is somewhat non optional, but better than a huge chain of callbacks
                    #for when the node finishes startup()
                    self.engine.log("Waiting %d seconds for our new node from an exploit"%self.waitfornewnode)
                    for i in xrange(0,self.waitfornewnode):
                        if not self.exploit.callback.lastnewnode:
                            time.sleep(1)
                    if self.exploit.callback.lastnewnode:
                        self.newnode=self.exploit.callback.lastnewnode
                        devlog('exploitmanager', "Calling the postactions handlers on the new node!")
                        self.engine.dopostactions(self.exploit.callback.lastnewnode,self.exploit)
                    else:
                        devlog('exploitmanager', "Callback did not have a lastnewnode!?")
            
            if self.exploit.name not in ignorelist:
                if self.exploit.target:
                    self.exploit.target.add_knowledge("Vuln To", self.exploit.name,100)            

        self.exploit.setState("done")
        if self.listLog != None:
            if self.exploit.dispshellcmd:
                dispshellcmd = self.getprompt() + self.exploit.dispshellcmd
            else:
                dispshellcmd = self.getprompt() + self.exploit.name
            self.engine.gui.gui_queue_append("shellwindow log", [self.listLog, dispshellcmd + "\n"])
            self.engine.gui.gui_queue_append("shellwindow log", [self.listLog, str(self.exploit.result)+"\n"])
        
        if callback:
            callback.current_exploit=None
            callback.busy=0
        
        if self.exploit.target:
            try:
                self.exploit.target.update_gui()
            except AttributeError:
                #it was probably a string of some kind
                try:
                    #give it a shot if we got it correctly upstairs :>
                    target.update_gui()
                except:
                    #I guess not. :<
                    pass
        self.state="Done"
        devlog('exploitmanager', "Return from run: %s" % ret)
        if type(ret) == str:
            return ret
        
        return self._return_from_run(ret)
    
    def shutdown(self):
        if hasattr(self.exploit, 'shutdown'):
            self.exploit.shutdown()
        else:
            name = self.name
            if name == "CANVAS Exploit":
                name = self.exploit
            devlog('exploitmanager::shutdown', "%s doesn't have shutdown() function!" % name)
