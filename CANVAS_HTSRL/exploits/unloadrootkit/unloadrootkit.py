#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2007
#http://www.immunityinc.com/CANVAS/ for more information

# imports
import sys
if '.' not in sys.path: sys.path.append('.')

from exploitutils import *
from canvasexploit import canvasexploit
from tcpexploit import tcpexploit

# info
NAME = "unloadrootkit"
VERSION = "1.0"
DESCRIPTION = "Removes the CANVAS rootkit."
DOCUMENTATION = {}

# properties
PROPERTY={}
PROPERTY['TYPE'] = "Trojans"
PROPERTY['ARCH'] = [ ["Windows"] ]

NOTES = """
"""

class theexploit(tcpexploit):
    def __init__(self):
        """ init """

        tcpexploit.__init__(self)
        self.result = ""
        self.name = NAME
        self.kernelmode_service      = "mosdef"
        self.usermode_service        = "MosdefUserMode"
        self.kernelmode_file         = "c:\\mosdef.sys"
        self.usermode_file           = "c:\\mosdef_usermode.exe"
        self.usermode_enabled        =  1
        self.hidden_file_list        = "c:\\mosdef.hidden.files"
        self.hidden_file_local_path  = "Your_Documents//mosdef.hidden.files"
               
        return
    
    def getArgs(self):
        """ get arguments """

        return

    def unloadWin32Node(self, node):
        """ unload rootkit onto a win32 node """
        self.setInfo("%s (in progress)"%(NAME))
        self.log("Attempting to unload rootkit on Win32 system")

        #JMS - slight logic refactor, we need to do our lsass.exe check
        #first or we won't get a valid connection from SamIConnect
        self.log("Testing whether we are inside mosdef_usermode.exe.")
        pname = self.exploitnodes("getprocessname",nodes=[node])
        self.log("Process Name: %s" % pname)
        
        if "mosdef_usermode" in pname[0][0].lower():
            self.log("We need to processinject into lsass.exe to run this module. Attempting now...")
            
            # Just do a default mosdefmigrate and be done with it
            # I do this unconditional except because the rootkit can hide
            # the process we are doing this from, which causes a mosdefmigrate
            # to fail. The best case scenario is, we create a process we know
            # won't be hidden, climb into it, and then do the removal
            try:
                migrate = self.engine.getModuleExploit( "mosdefmigrate" )
                migrate.link(self)
                ret = migrate.run()
                
                if ret is not None:
                    shell = ret.shell                 
            except:
                pass
            
            
        
        # XXX: this was for multiple nodes results                

        results = []
        ret     = 0
        from win32MosdefShellServer import SC_MANAGER_CREATE_SERVICE
        from win32MosdefShellServer import SERVICE_WIN32_OWN_PROCESS
        from win32MosdefShellServer import SERVICE_AUTO_START
        from win32MosdefShellServer import SERVICE_ERROR_IGNORE
        from win32MosdefShellServer import GENERIC_ALL
        from win32MosdefShellServer import SERVICE_ALL_ACCESS
        from win32MosdefShellServer import SC_MANAGER_ALL_ACCESS
        
        # Open the SC Manager, get a service handle
        # and send the control code to stop the service
        for service_name in [self.kernelmode_service, self.usermode_service]:
            if service_name == self.usermode_service and self.usermode_enabled == 0:
                ret = 0
            else:
                scm_handle    = node.shell.OpenSCManager()
                
                if scm_handle == 0:
                    self.log("Couldn't open the Service Manager")
                else:
                    hservice,error      = node.shell.OpenService(scm_handle,service_name,SERVICE_ALL_ACCESS)
                    
                    if hservice == 0:
                        self.log("Error opening the service: %x" % error)
                        if error == 0x424:
                            self.log("That service does not exist")
                        elif error == 0x430:
                            self.log("The service has been marked for deletion.")
                    else:
                                   
                        ret, current_state = node.shell.ControlService(hservice,0x01)
                  
                        import time        
                        self.log("Giving the service time to shutdown.")
                        time.sleep(5)
                            
                            
                        # The service is stopped let's delete it and close the handles
                        ret, error = node.shell.DeleteService(hservice)
                        if ret == 0:
                            self.log("Failed to delete the service: %x" % error)
                        
                        node.shell.CloseServiceHandle(hservice)
                    node.shell.CloseServiceHandle(scm_handle)
                            
        
        if ret != -1:
                self.log("Successfully unloaded the rootkit.")
                
                for file in [ self.kernelmode_file, self.usermode_file ]:
                    
                    ret = node.shell.unlink( file )
                    
                    if ret:
                        self.log("Successfully deleted %s from the remote filesystem." % file )
                    else:
                        self.log("Failed to delete %s" % file )

                self.setInfo("%s - done (success)" % NAME)

                
        else:
                self.log("Failed to unload the rootkit.")
                self.setInfo("%s - done (failed: %d" % (NAME,ret))
                                   
        # Now check for hidden file cleanup
        self.check_hidden_files( node )
        
        return ret

    
    def check_hidden_files( self, node ):
        """
        Check the remote host for hidden files that need to be renamed or deleted.
        """

        # Download the hidden file list

        try:
            node.download( self.hidden_file_list, self.hidden_file_local_path )
        except:
            self.log("No hidden files to clean up on remote host.")
            return
            
        fd = open( self.hidden_file_local_path, "r" )
        
        if fd:
            file_blob = fd.read()
            self.log("Rootkit cleanup list: %s" % file_blob)
            file_list = file_blob.split("\n")
            
            for file in file_list:
                
                # Here we check the file flag and either rename
                # or remove as instructed
                file_args = file.replace("\r","").split("|")
                flag      = file_args[::-1][0]                

                # Rename flag
                if flag == "R":
                    self.log("Renaming file (%s) back to (%s)" % (file_args[0],file_args[1]) )
                    node.shell.rename_file( file_args[0], file_args[1] )
                
                # Delete flag
                if flag == "D":
                    self.log("Deleting file (%s)" % file_args[0])
                    node.shell.unlink( file_args[0] )
        
            fd.close()
        else:
            self.log("Couldn't open the local hidden file list after we downloaded. Check Your_Documents.")
            
        # Remove the remote file list
        node.shell.unlink( self.hidden_file_list )

        # Remove the list locally
        import os
        os.remove( self.hidden_file_local_path )
        
        self.log("Finished cleaning up hidden files.")
        
        
        return
    
    
    def unloadKitToNode(self, node):
        """ try to unload the kit on the node type """

        # cross platform support in the future
        ret = 0

        if "win32api" in node.capabilities:
            
            if not "rootkit" in node.capabilities:
                # Test for it
                if node.shell.rootkit_present() == -1:
                    self.log("No rootkit detected as being installed.")
                    self.setInfo("%s - done (failed)" % NAME)
                    return 0
                
            ret = self.unloadWin32Node(node)
        else:
            self.log("Platform not supported yet.")

        return ret
                

    def run(self):
        """ main """

        self.setInfo("%s (in progress)"%(NAME))

        self.getArgs()
        results = []
                
        for node in self.argsDict["passednodes"]:
            ret = self.unloadKitToNode(node)
            
            try:
                node.capabilities.remove("rootkit")
            except ValueError:
                self.log("Couldn't remove node capability for rootkit.")
                
            
            results.append(ret)
     
        return 1

if __name__=="__main__":
    print "[*] This module is designed to be run from inside of CANVAS."
    
