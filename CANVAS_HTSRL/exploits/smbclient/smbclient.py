#! /usr/bin/env python
"""
smbclient.py

Starts up a file listener that uses this exploit as a client into a MS network

"""

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2008
#
# http://www.immunityinc.com/CANVAS/ for more information

NAME    = "smbclient"
VERSION = "1.0"

import os,socket,time
import sys
if "." not in sys.path:
    sys.path.append(".")       

from exploitutils import *
from encoder import *
from tcpexploit import tcpexploit
from msrpc import *
import canvasengine
import msrpc

from VFSNode import VFSNode
from smbshell import smbshell

DOCUMENTATION                   = {}
PROPERTY                        = {}
VERSION                         = "0.2"
DESCRIPTION                     = "smbclient"

DOCUMENTATION['Date public']    = "10/10/2010"
DOCUMENTATION['Notes']          = "An SMB client"
PROPERTY['TYPE']                = "Tools"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["Windows"] ]
PROPERTY['VERSION']             = [ "2000", "XP", "2003" ]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.filename   = "C$"
        self.domain     = ""
        self.host       = ""
        self.port       = 139
        self.version    = 0
        self.user       = "Administrator"
        self.name       = NAME
    
    def getargs(self):
        self.host       = self.target.interface
        self.user       = self.argsDict.get("user",self.user)
        self.password   = self.argsDict.get("password",self.password)
        self.filename   = self.argsDict.get("filename",self.filename)
        self.domain     = self.argsDict.get("domain",self.domain)
        self.port       = int(self.argsDict.get("port",self.port))
        
    def test(self):
        """
        Connect to the target and spawn a vfs-shell if we get a connection
        """
        self.getargs()
        self.setInfo("%s attacking %s:%d (Covertness:%d) - running" %\
                    (NAME,self.host,self.port,self.covertness))

        self.log("Using domain=%s user=%s, password %s" % (self.domain,self.user,self.password))
        smbobj              = msrpc.SMB(self.host,port=self.port,getsock=self)
        smbobj.covertness   = self.covertness
        smbobj.username     = self.user
        smbobj.password     = self.password
        smbobj.domain       = self.domain

        ret = smbobj.connect()
        if not ret:
            self.log("Could not connect to remote host: %s"%smbobj.errormsg)
            return 0

        self.log("Trying treeconnect_AndX on share %s"%self.filename)
        ret = smbobj.treeconnect(self.filename)
        if not ret:
            self.log("Failed to connect to share!")
            return 0
        self.log("Connected to share %s"%self.filename)
        smbobj.close()
        return 1
    
    
    def run(self):
        """
        Connect to the target and spawn a vfs-shell if we get a connection
        """
        self.result = []
        self.getargs()

        self.log("%s running against %s:%d covertness: %d" %\
                (NAME,self.host,self.port,self.covertness))
        self.setInfo("%s attacking %s:%d (Covertness:%d) - running" %\
                (NAME,self.host,self.port,self.covertness))
        self.log("Using domain=%s user=%s, password %s" %\
                (self.domain,self.user,self.password))
        
        smbobj              = msrpc.SMB(self.host,port=self.port,getsock=self)
        smbobj.covertness   = self.covertness
        smbobj.username     = self.user
        smbobj.password     = self.password
        smbobj.domain       = self.domain

        ret = smbobj.connect()
        
        if not ret:
            self.log("Could not connect to remote host: %s"%smbobj.errormsg)
            
            if self.port != 445:
                
                smbobj.port = 445
                self.log("Attempting to try port 445.")
                ret         = smbobj.connect()

                if not ret:
                    return 0
            else:
                return 0

        self.log("Successfully connected to %s:%d" % (self.host, smbobj.port) )
        self.log("Trying treeconnect_AndX on share %s"%self.filename)
        ret = smbobj.treeconnect(self.filename)
        
        if not ret:
            
            # Try again with port 445
            if smbobj.port != 445:
                
                smbobj.port = 445
                ret         = smbobj.connect()
                
                if not ret:
                    return 0
                else:
                    
                    ret     = smbobj.treeconnect( self.filename )
                    
                    if not ret:
                        self.log("Failed to connect to share!")
                        return 0
                    
            else:
                self.log("Failed to connect to share!")
                return 0

        self.log("Connected to share %s"%self.filename)
        
        if not smbobj.checkdirectory("\\"):
            self.log("Can't check directory on that share. :<")
        else:
            self.log("Checkdirectory \\ passed...")
            
        node            = VFSNode()
        node.parentnode = self.argsDict["passednodes"][0]
        newshell        = smbshell(smbobj,node,self.logfunction)
        
        self.setInfo("%s attacking %s:%d (Covertness:%d) - done" %\
                    (NAME,self.host,self.port,self.covertness))
        self.result = [node]
        return node

    def dodir(self,dir):
        error,errstr,result = smb_findfirst2(self.connection,self.tid,self.pid,self.uid,dir)
        if error:
            return errstr
        return result
    
    def displayVersions(self):
        print "0 - SMBClient v0.2"    
    
if __name__ == '__main__':
    print "Running CANVAS "+NAME+" version "+VERSION
    app         = theexploit()
    app.options = ["-O user:username", "-O password:password"]
    ret         = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
