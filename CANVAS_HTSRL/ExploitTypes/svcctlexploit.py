#!/usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")
from win32MosdefShellServer import GENERIC_READ
import msrpc
from libs.dcemarshall import *

from win32MosdefShellServer import SC_MANAGER_ALL_ACCESS
from win32MosdefShellServer import SERVICE_WIN32_OWN_PROCESS
from win32MosdefShellServer import SERVICE_AUTO_START
from win32MosdefShellServer import SERVICE_ERROR_IGNORE
from win32MosdefShellServer import SERVICE_ALL_ACCESS
from win32MosdefShellServer import SERVICE_BOOT_START
from win32MosdefShellServer import SERVICE_AUTO_START

class svcctlexploit:
    """
    Used for exploits talking to svcctl (service control manager, etc)
    """
    def __init__(self):
        pass
    
    ################## 
    ### MSRPC Routines
    ##################
    

    def createOpenSCMPkt(self,machinename=None,databasename=None,accessmask=GENERIC_READ):
        marshaller=dcemarshaller()
        data=""
        data+=wchar_t(machinename,["unique"],marshaller).marshall()
        data+=wchar_t(databasename,["unique"],marshaller).marshall()
        data+=dceint(accessmask,[],marshaller).marshall() 
        return data
    
    def parseOpenSCMPkt(self,buf):
        """
        parses the buffer sent back to use by the msrpc server 
        """
        #4 bytes of pointer data (null? wth?)
        #then 16 bytes of policy handle data
        policyhandle=buf[0:20]
        returnvalue=istr2int(buf[20:24])
        #returns 0 on success
        if returnvalue!=0:
            success=0
            self.log("parseOpenSCMPkt return value not 0!: %x"%returnvalue)
            if returnvalue==0x6e5:
                self.log("Could not impersonate user for some reason")
        else:
            success=1
        return success,policyhandle
        
    def OpenSCManager(self,host,access=0):
        """
        opens a remote Service Control Manager
        Returns 0 on failure
        
        On Windows 2000 this will connect to services.exe, which will then
        call OpenSCManager for you. Actually it doesn't call the routine
        itself. It appears to call some other routine internally that does the
        real work. So you can't breakpoint on OpenSCManager or CreateServiceW
        (sorry)
        
        If you breakpoint on OpenSCManager, and you aren't seeing it get called, then that's normal.

        Try breakpointing on RPCImpersonateClient and seeing what is
        going on there. 
        
        """
        self.log("Using msrpcuser: %s    msrpcpassword: %s"%(self.msrpcuser,self.msrpcpassword))
        connectionList = ["ncacn_np:%s[\\svcctl]"% (host)]
        self.myDCE = msrpc.DCE("367abb81-9844-35f1-ad32-98f038001003", "2.0", connectionList, covertness = self.covertness, getsock=self)
        self.myDCE.setUsername(self.msrpcuser)
        self.myDCE.setPassword(self.msrpcpassword)
        self.myDCE.setDomain(self.domain)
        
        try:
            map=self.myDCE.connect()
            if not map:
                self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")
        except Exception, msg:
            self.log(msg)	
            return 0	
        self.log("Successfully connected to service control manager pipe")
        pkt=self.createOpenSCMPkt(accessmask=access)
        self.log("OpenSCManager sending %d bytes"%len(pkt))
        #send to function_09
        ret = self.myDCE.call(15, pkt, response=1)
        #get result
        #parse result
        success,policy_handle=self.parseOpenSCMPkt(msrpc.get_all_stubs(ret))
        if not success:
            return ""
        return policy_handle
    
    def createCreateServicePkt(self,scm,servicename,displayname,desiredaccess,atype,starttype,errorcontrol,binarypath,loadorder,dependancies,servicestartname,password):
        data=""
        marshaller=dcemarshaller()
        data+=scm #policy handle (usually starts with \x00*4)
        #this one does NOT have a pointer associated with it
        data+=wchar_t(msunistring(servicename),["unique"],marshaller).marshall()
        #this one does
        data+=dcepointer(wchar_t(msunistring(displayname),[],marshaller),["unique"],marshaller).marshall()
        desiredaccess=0x0f01ff
        data+=dceint(desiredaccess,[],marshaller).marshall() 
        #atype=0x10
        data+=dceint(atype,[],marshaller).marshall() 
        #starttype=3
        data+=dceint(starttype,[],marshaller).marshall() 
        #errorcontrol=0
        data+=dceint(errorcontrol,[],marshaller).marshall() 
        #no ptr
        data+=wchar_t(msunistring(binarypath),["unique"],marshaller).marshall()
        #ptr
        data+=dcepointer(wchar_t(msunistring(loadorder),[],marshaller),[],marshaller).marshall()
        #ptr
        data+=dcepointer(wchar_t(msunistring(dependancies),[],marshaller),[],marshaller).marshall()
        servicestartname=0
        #ptr
        data+=dcepointer(wchar_t(msunistring(servicestartname),[],marshaller),[],marshaller).marshall()
        #ptr
        data+=dcepointer(wchar_t(msunistring(password),[],marshaller),[],marshaller).marshall()
        #3 nulls
        data+=intel_order(0)*3
        return data
    
    def parseCreateServicePkt(self,stub):
        """
        Parses the data sent back to us from a successful call to CreateServiceW
        last dword is return value - NULL is success, else, is errno
        
        On success returns <0><0><16 bytes of something><0>
        """
        if len(stub)<4:
            self.log("Error: CreateServicePkt is not long enough!")
            return -1
        ret=istr2int(stub[-4:])
        if ret==0x57:
            self.log("Invalid parameter")
        if ret==0x431:
            self.log("Error service exists!")
        return ret
    
    def CreateService(self,scm,servicename,displayname,desiredaccess,atype,starttype,errorcontrol,binarypath,loadorder,dependancies,servicesstartname,password):
        """
        host is the host to connect to
        scm is the string for our scm pointer
        """
        #the SCM value is specific to a connection...so you can't reconnect here
        pkt=self.createCreateServicePkt(scm,servicename,displayname,desiredaccess,atype,starttype,errorcontrol,binarypath,loadorder,dependancies,servicesstartname,password)
        self.log("CreateService sending %d bytes"%len(pkt))
        #send to function_0b
        ret = self.myDCE.call(12, pkt, response=1)
        #get result
        #parse result
        error=self.parseCreateServicePkt(msrpc.get_all_stubs(ret))
        return error
    
    def OpenServiceWPkt(self,scm,servicename,access):
        """
        Creates a OpenServiceW packet for use in sending down the wire
        """
        data=""
        marshaller=dcemarshaller()
        data+=scm #policy handle (usually starts with \x00*4)
        #this one does NOT have a pointer associated with it
        data+=wchar_t(msunistring(servicename),[],marshaller).marshall()
        data+=dceint(access,[],marshaller).marshall() 
        return data
    
    def parseOpenServicePkt(self,data):
        """
        Parses the MSRPC stub returned by a OpenServiceW call
        """
        if len(data)<24:
            self.log("OpenService Packet not long enough: %d"%len(data))
            return -1,None
        handler=data[:20]
        ret=istr2int(data[-4:])
        return ret,handler
    
    def OpenService(self,scm,servicename,access):
        """
        Calls OpenServiceW remotely on a host - but of course, requires that self.myDCE is already set up...
        """
        pkt=self.OpenServiceWPkt(scm,servicename,access)
        self.log("OpenServiceW sending %d bytes"%len(pkt))
        #send to function_10
        ret = self.myDCE.call(0x10, pkt, response=1)
        #get result
        #parse result
        ret,handler=self.parseOpenServicePkt(msrpc.get_all_stubs(ret))
        return ret,handler
    
    def StartServicePkt(self,handler,args=[]):
        """
        Creates a StartService packet for use in sending down the wire
        """
        data=""
        marshaller=dcemarshaller()
        data+=handler #policy handle (usually starts with \x00*4)

        data+=dceint(len(args),[],marshaller).marshall() 
        if len(args)!=0:
            self.log("Marshalling complex array - untested")
            data+=dceint(0xbadf00d,[],marshaller).marshall()  #pointer
            data+=dceint(len(args),[],marshaller).marshall()  #length of array
            data2=""
            i=1
            for anarg in args:
                data+=dceint(0xbadf00d+i,[],marshaller).marshall()  #pointer
                data2+=wchar_t(msunistring(anarg),[],marshaller).marshall()
                i+=1
            data+=data+data2
        else:
            #nothing in array...
            data+=dceint(0,[],marshaller).marshall()  #null pointer 

        return data
    
    def parseStartServicePkt(self,data):
        """
        Parses the MSRPC stub returned by a StartService call
        """
        if len(data)<4:
            self.log("StartService Packet not long enough: %d"%len(data))
            return -1
        ret=istr2int(data[-4:])
        if ret==0x420:
            self.log("A instance of this service is already running...")
        return ret

    def ControlServicePkt(self,handle,control):
        """
        Creates a ControlServiceW packet for use in sending down the wire
        """
        data=""
        marshaller=dcemarshaller()
        data+=handle
        data+=dceint(control,[],marshaller).marshall()
        return data

    def StopService(self,handle):
        """
        Calls ConrolService with SERVICE_CONTROL_STOP remotely on a host - but of course, requires that self.myDCE is already set up...
        """
        pkt=self.ControlServicePkt(handle,1) # SERVICE_CONTROL_STOP=0x00000001
        self.log("StopService sending %d bytes"%len(pkt))
        ret = self.myDCE.call(1, pkt, response=1)
        #get result
        #parse result
        ret=self.parseStartServicePkt(msrpc.get_all_stubs(ret))
        return ret

    def DeleteServicePkt(self,handle):
        data=""
        marshaller=dcemarshaller()
        data+=handle #policy handle (usually starts with \x00*4)
        return data

    def DeleteService(self,handle):
        """
        Calls DeleteService remotely on a host - but of course, requires that self.myDCE is already set up...
        """
        pkt=self.DeleteServicePkt(handle)
        self.log("DeleteService sending %d bytes"%len(pkt))
        ret=self.myDCE.call(2, pkt, response=1)
        ret=self.parseStartServicePkt(msrpc.get_all_stubs(ret))
        return ret

    def StartService(self,handle):
        """
        Calls OpenServiceW remotely on a host - but of course, requires that self.myDCE is already set up...
        """
        pkt=self.StartServicePkt(handle)
        self.log("StartService sending %d bytes"%len(pkt))
        ret = self.myDCE.call(19, pkt, response=1)
        #get result
        #parse result
        ret=self.parseStartServicePkt(msrpc.get_all_stubs(ret))
        return ret

    def CloseServiceHandlePkt(self,handle):
        """
        Creates a OpenServiceW packet for use in sending down the wire
        """
        data=""
        marshaller=dcemarshaller()
        data+=handle #policy handle (usually starts with \x00*4)
        return data
    
    def parseCloseServiceHandlePkt(self,data):
        """
        Parses the MSRPC stub returned by a StartService call
        """
        if len(data)<4:
            self.log("CloseServiceHandle Packet not long enough: %d"%len(data))
            return -1
        ret=istr2int(data[-4:])
        return ret
    
    def CloseServiceHandle(self,handle):
        """
        Calls CloseServiceHandle remotely on a host - but of course, requires that self.myDCE is already set up...
        """
        pkt=self.CloseServiceHandlePkt(handle)
        self.log("CloseServiceHandle sending %d bytes"%len(pkt))
        ret = self.myDCE.call(0, pkt, response=1)
        #get result
        #parse result
        ret=self.parseCloseServiceHandlePkt(msrpc.get_all_stubs(ret))
        return ret
