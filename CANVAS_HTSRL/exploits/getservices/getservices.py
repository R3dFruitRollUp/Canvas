#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2007
#http://www.immunityinc.com/CANVAS/ for more information

import socket
import getopt
import sys

if '.' not in sys.path: sys.path.append('.')

from canvasexploit import canvasexploit
from exploitutils import *
import canvasengine
import libs.canvasos as canvasos

# GUI info
NAME='Windows EnumServices'
DESCRIPTION='Windows Remote Services Enumeration'
DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
This module will attempt to make MSRPC calls in order to retrieve the 
list of services available on the remote machine (via the service
control manager). This is possible to do without authentication
against Windows 2000 SP4 (pre-Update Rollup) and is a valuable
part of your recon against these systems. You may see anti-virus
programs, HIDS, or other secondary protection layers via this module.

"""
DOCUMENTATION['Date public']=''
DOCUMENTATION['References']=''
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Recon'
PROPERTY['SITE']='Remote'
PROPERTY['ARCH']=[['Windows']]
PROPERTY['VERSION']=['2000','XP']

NAME=DESCRIPTION

NOTES="""
This module will list all the services available on a remote machine using a named pipe that
allows anonymous access. This will work against 2000 up to and including SP4, but was fixed
in Update Rollup 1 for SP4. Above that (UR1, XP), a username and password will be needed.
"""

import msrpc
from msrpcexploit import msrpcexploit
import struct
from msrpc import read_raw_unicode_string
from msrpc import get_all_stubs

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name=NAME
        self.host=''
        self.user=''
        self.password=''
        self.UUID='367abb81-9844-35f1-ad32-98f038001003'
        self.uuidversion='2.0'
        self.myDCE=None
        self.SChandle=''
        self.datasize=0
        self.servicesdata=''
        self.autoversion=1
        self.port=445
        self.needsNoShellcode=True
        self.domain="" #null for auto-detect
        return
   
    def getArgs(self):
        self.user=self.argsDict.get('user',self.user)
        self.password=self.argsDict.get('password',self.password)
        self.domain=self.argsDict.get("domain" , self.domain)
        self.host=self.target.interface
        return

    def ServicesConnect(self):
        connectionList=['ncacn_np:%s[\\browser]'%(self.host),'ncacn_np:%s[\\svcctl]'%(self.host)]
        self.myDCE=msrpc.DCE(self.UUID,self.uuidversion,connectionList,covertness=self.covertness,getsock=self, domain=self.domain)
        self.myDCE.setUsername(self.user)
        self.myDCE.setPassword(self.password)
        self.log('Setting username and password to %s:%s'%(self.user,self.password))
        try:
            map=self.myDCE.connect()
            if not map:
                self.raiseError('Could not connect to remote server - service is not running or the host is firewalled.')
        except Exception, msg:
            self.log(msg)
            return False
        return True 

    def OpenSCManager(self):
        '''
/* opcode: 0x0F, address: 0x01002A50 */

long  _ROpenSCManagerW (
 [in][unique][string] wchar_t * arg_1,
 [in][unique][string] wchar_t * arg_2,
 [in] long arg_3,
 [out][context_handle] void ** arg_4
);
        '''
        data=''
        data+=struct.pack('<LL',0,0)
        data+=struct.pack('<L',4) #SC_MANAGER_ENUMERATE_SERVICE
        try:
            ret=get_all_stubs(self.myDCE.call(0xf,data,response=1)) #_ROpenSCManagerW
        except Exception, msg:
            self.log('Could not call MSRPC Function: %s'%(msg))
            return False
        return_code=struct.unpack('<L',ret[-4:])[0]
        self.SChandle=ret[:-4]
        if return_code!=0:
            self.log('Failed to open service manager with return code: %x'%(return_code))
            return False 
        return True

    def EnumServicesStatusEx(self,size=0x2c):
        '''
/* opcode: 0x2A, address: 0x010145D5 */

long  _REnumServicesStatusExW (
 [in][context_handle] void * arg_1,
 [in] /* enum32 */ long arg_2,
 [in] long arg_3,
 [in] long arg_4,
 [out][size_is(arg_6)] char * arg_5,
 [in][range(0,262144)] long arg_6,
 [out] long * arg_7,
 [out] long * arg_8,
 [in, out][unique] long * arg_9,
 [in][unique][string] wchar_t * arg_10
);
        '''
        data=''
        data+=self.SChandle          #hSCManager
        data+=struct.pack('<L',0)    #SC_ENUM_PROCESS_INFO
        data+=struct.pack('<L',0x30) #SERVICE_WIN32
        data+=struct.pack('<L',3)    #SERVICE_STATE_ALL
        data+=struct.pack('<L',size)
        data+=struct.pack('<L',1)    #[unique]
        data+=struct.pack('<LL',0,0)
        try:
            ret=get_all_stubs(self.myDCE.call(0x2a,data,response=1)) #_REnumServicesStatusExW
        except Exception, msg:
            self.log('Could not call MSRPC Function: %s'%(msg))
            return False
        return_code=struct.unpack('<L',ret[-4:])[0]
        if return_code==234: #ERROR_MORE_DATA
            size=struct.unpack('<L',ret[:4])[0]
            self.datasize=struct.unpack('<L',ret[4+size:4+size+4])[0]
            return False
        self.servicesdata=ret[4:4+size]
        return True

    def neededListenerTypes(self):
        return []

    def parseServicesData(self, serviceslist):
        """Dumb parsing of the data, lot faster this way."""
        data=self.servicesdata
        #print repr(data)
        widechar=data[-2:]
        while widechar=='\0\0':
            data=data[:-2]
            widechar=data[-2:]
        while widechar!='\x01\0' and widechar!='\0\0':
            name=''
            displayname=''
            while True:
                widechar=data[-2:]
                data=data[:-2]
                if widechar=='\0\0':
                    break
                name=widechar[0]+name
            self.log("Service found: %s"%prettyprint(name))
            while True:
                widechar=data[-2:]
                data=data[:-2]
                if widechar=='\0\0':
                    break
                displayname=widechar+displayname
            #print repr(displayname)
            widechar=data[-2:]
            #print repr(widechar)
            serviceslist[name]=displayname
        return serviceslist

    def run(self):
        self.setInfo('%s'%(NAME))
        self.getArgs()
        self.result=[]
        node=self.argsDict['passednodes'][0]
        serviceslist={}
        if node.islocal(self.host) and 'win32api' in node.capabilities:
            pass #TODO
        else:
            ret=self.ServicesConnect()
            if not ret:
                self.log('Could not open Services Endpoint!')
                self.result=serviceslist
                return 0
            self.log('Opened Services Endpoint')
            self.log('Opening Services Manager')
            ret=self.OpenSCManager()
            if not ret:
                self.log('Could not get a Service Manager handle')
                self.result=serviceslist
                return 0
            self.log('Enumerating Services')
            ret=self.EnumServicesStatusEx()
            if not ret:
                if self.datasize==0:
                    self.log('Could not enumerate services')
                    self.result=serviceslist
                    return 0
                self.log('Increasing data size')
                ret=self.EnumServicesStatusEx(self.datasize)
                if not ret:
                    self.log('Could not enumerate services')
                    self.result=serviceslist
                    return 0
            self.log('Parsing Services Information')
            self.parseServicesData(serviceslist)
        self.result=serviceslist
        self.log('Number of services: %s'%len(serviceslist))
        self.target.replace_knowledge('services',serviceslist,100)
        self.setInfo('%s - done (success: %s)'%(NAME,'%d services found'%len(serviceslist)))
        return 1

if __name__=='__main__':
    app=theexploit()
    ret=standard_callback_commandline(app)
