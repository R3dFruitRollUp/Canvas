#! /usr/bin/env python
"""
VulnAssess.py


"""

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation


NAME="VulnAssess"
VERSION="1.0"
NOTES2="""

"""

CHANGELOG="""
1.0 
Created.

Added toggles for whereami/traceroute at customer request alexm@ 8/14/08
"""

DEBUGNOTES="""

"""

import os,getopt
import sys
paths = (".", "exploits/passive_os_detect")
for i in paths:
	if i not in sys.path:
		sys.path.append(i)

import passive_os_detect
import timeoutsocket

import socket
from exploitutils import *

from tcpexploit import tcpexploit
from msrpc import *
import canvasengine
import time

from libs.ctelnetlib import Telnet
from shelllistener import shelllistener
from shelllistener import shellfromtelnet

import libs.canvasos as canvasos
from engine.config import canvas_reports_directory

DOCUMENTATION={}
DOCUMENTATION["Notes"]="""
For a given network range do the following actions:
1. Find all the alive hosts
2. For each alive host do an osdetect which generates an os basename
			 Portscan each alive host from 1-10000
			 If port 88 is open and os is Windows, then it is a domain server, so note that.
			 If port 1433 is open, it is a SQL Server, so note that.
			 If port 80 is open, it is a web server, so note that.
3. For each exploit in our exploit modules list, check to see which ones match that 
basename and run their test function
4. For each exploit in an explicit internal list, if the basename matches, run
the exploit and see if we get in. If so, drop a file, and disconnect.
5. Write a little report about it using our reporting module
"""

DOCUMENTATION["Todo"]="""
Future releases want to fingerprint each host so that if a host changes IP, we still
know where it is.
"""


NAME="VulnAssess"
DESCRIPTION="Safe Vulnerability Assessment Tool"

VERSION="0.1"

#affectsList=["Recon"]
PROPERTY = {}
PROPERTY['TYPE'] = "Tools"

GTK2_DIALOG="dialog.glade2"

NOTES=""" 

"""

import libs.reporting as reporting
from hostKnowledge import *
from engine.config import canvas_resources_directory
import os

class theexploit(tcpexploit):
	def __init__(self):
		tcpexploit.__init__(self)
		self.vulns=[]
		self.setPort(0)
		self.setHost("")
		self.setVersion(1)
		self.istest=0
		self.setVersions()
		self.shellcode="A"
		self.localhost=""
		self.localport=0
		self.ssl=0
		self.doshell=1
		self.force=0
		self.name=NAME
		self.netmask="32"
		self.report=None
		self.portscan=1 #default is do a portscan
		self.autohack_state=False 
		self.portlow=1
		self.porthigh=1100
		self.silica=False
		self.ssid=self.tpref=""
		self.do_testhost=False #should we run testhost (default is NO, instead we run a list of preselected recon modules)
		self.passive_detector=None 
		self.traceroute=True # Toggle traceroute, added at customer request
		self.whereami=True # Same request as above
		return


	def getargs(self):
		self.host=self.target.interface
		self.netmask=dInt(str(self.argsDict.get("netmask",self.netmask)).split(".")[0])
		self.portscan=int(self.argsDict.get("portscan",self.portscan))
		self.maxthreads=int(self.argsDict.get("maxthreads",self.maxthreads))
		self.getarg("do_testhost") #if we want testhost
		# Added for customer requests
		print self.traceroute
		if bool(self.argsDict.get("traceroute", self.traceroute)) == False:
			self.traceroute = True
		else:
			self.traceroute = False

		if bool(self.argsDict.get("whereami", self.whereami)) == False:
			self.whereami = True
		else:
			self.whereami = False
		#silica vars
		self.ssid=self.argsDict.get("ssid", "")
		self.silica=self.argsDict.get("silica",self.silica)
		self.tpref=self.argsDict.get("tpref",self.tpref)
		return


	def scan_lock(self):
		print "Creating lock file...",
		fp = open("SCAN_LOCK", "w")
		fp.close()
		print "done"
		return


	def scan_unlock(self):
		print "Unlocking any active/stale files...",
		try:
			os.unlink("SCAN_LOCK")
		except:
			pass
		print "done"
		return


	def finish(self):
		if self.argsDict.get("silica"):
			self.scan_unlock()            

		return 



	def process_thread_results(self, status_q, end_of_run_marker):
		"""
		This is the ThreadRunner2 magic right here. Essentially ALL threads return state about
		what they are up to via a q to the ThreadTracker, The ThreadTracker then does some
		sanitization and spits stuff back down a status q to us.

		This means that we can sit in a loop and read from the same q for all the targets in
		our range and do stuff like reporting based on what we see coming back.

		Data comes back in the form of:
			 [Thread Object to which this status relate] , [status marker] ,[data]

		*REMEBER* this is one queue for ALL threads, not one for each!
		"""
		#TODO **** Change to a register handlers model .....
		while 1:
			tr2_obj, status, data=status_q.get()

			if status == end_of_run_marker:
				##ALL threads have completed so now more status/results to process
				tr2_obj.join()
				break

			elif status == "newhost":
				self.report.newhost(data) #data == target

			elif status == "note":
				self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str

			elif status == "extras":
				self.report.add_extras(data) #data == str

			elif status == "failure":
				self.report.report_failure(data) #data == target

			elif status == "killed":
				self.report.report_failure(data[0]) #data == target
				self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
                
			elif status=="error":
				self.report.note(data[0], data[1]) #data[0]==target, data[1]==explanation str
			
			elif status=="dead":
				##Skip hosts that are not alive
				pass

			elif status == "exception":
				if self.silica:
					outfile=file("SILICA.log","w")
					#traceback.print_exc(file=outfile)
					outfile.write(data)
					outfile.close()
				else:
					print data


		self.log("All results gathered")

	def run(self):
		sil_flag=False
		if self.argsDict.get("silica"):
			self.scan_lock()
			sil_flag=True
		self.getargs()
		self.log("Interface=%s"%self.host)
		self.log("Netmask=%s"%self.netmask)
		self.log("Maxthreads for VulnAssess: %d"%self.maxthreads)
		self.log("Whereami set to: %s"%self.whereami)
		self.log("Traceroute set to: %s"%self.traceroute)
		
		self.localips=[]
		for node in self.argsDict.get("passednodes",[]):
			self.localips+=node.getallips()

		self.report=reporting.report(self.tpref, sil_flag)
		self.vulns=[] #clear it

		try:
			if not canvasengine.registeredallmodules:
				canvasengine.registerAllModules()
				
			##Get the list of modules that we want autohack to run through (this will be made not static in future)
			fd=open(os.path.join(canvas_resources_directory,"vulnassess.txt"),"rb")
			self.exploit_modules=fd.readlines()
			fd.close()
			self.exploit_modules=map(str.strip,self.exploit_modules)			

			self.node=self.argsDict["passednodes"][0]
			dothreads = "threads" in self.node.capabilities
			if not dothreads:
				self.log("Warning: not using threads because select node does not support threading, resetting maxthreads to 1.")
				self.maxthreads=1
				

			# Start passive os detection thread here
			if sil_flag:
				pof_thread = passive_os_detect.stpof(self,self.host,180,2)
				pof_thread.start()


			self.setInfo("[VulnAssess2] Scanning network: %s/%s"%(self.host, self.netmask))
			self.setProgress(5)

			# Run whereami to note where we're running from
			# Added toggle for customer 8/14/08
			if self.whereami == True:
				app=self.engine.getModuleExploit("whereami")
				app.link(self)
				ret=app.run()
			else:
				self.log("Whereami set to off, proceding")

			self.run_threaded_on_alive_hosts(e_module="autoassess")
				
			if sil_flag:
				pof_thread.stop_pof()
				print "Up to now we found: ", pof_thread.pofhosts
				self.report.pofhosts = pof_thread.pofhosts
			else:
				self.report.pofhosts = []

			data=self.report.generate_vulnassess_html()

			if(self.silica):
				tdate = time.time()
				filename = "%sVA_Report_%s_%s_%s.html"%(self.tpref, self.ssid,self.host,tdate)
			else:
				filename="Vulnassess2_report_%s_%s.html"%(self.host,self.netmask)

			filename = filename.replace("/", "")
			filename=os.path.join(canvas_reports_directory,filename)
			file(filename,"wb").write(data)
			self.log("Wrote HTML formatted report to: %s"%filename)
			self.setInfo("VulnAssess2 scanning %s (done)"%(self.host))
			self.finish()

		except:
			self.finish()
			raise #this will raise the exception again 

		return 1

	def setVersions(self):
		self.versions={}

		self.versions[1]=("All", None)


	def displayVersions(self):
		for v in self.versions.keys():
			print "Version %d: %s"%(v,self.versions[v][0])


def usage():
	app = theexploit()
	print "Usage: "+sys.argv[0]+" [-T] [-v version]  -t target [ -p targetport:%d]"%(app.port)
	app.displayVersions()
	sys.exit()

#this stuff happens.
if __name__ == '__main__':
	print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
	app = theexploit()
	ret=standard_callback_commandline(app)

