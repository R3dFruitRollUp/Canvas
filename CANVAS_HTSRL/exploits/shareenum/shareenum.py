#! /usr/bin/env python



#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2004
#http://www.immunityinc.com/CANVAS/ for more information

import sys
#covers both angles
if "." not in sys.path: sys.path.append(".")


import os,getopt
import socket
from exploitutils import *


from canvasexploit import canvasexploit
import canvasengine
import time
import msrpc


NAME="shareenum"
DESCRIPTION="Get a list of shares from the remote machine using srvsvc::NetrShareEnum"

DOCUMENTATION={}
DOCUMENTATION["Notes"]="""

This module will attempt to enumerate the SMB shares open on your currently
selected target. These will be stored into the knowledge tree, and you
may want to follow this up by using the smbclient built into CANVAS to attempt
to access the files on those file shares.

This module operates over the SMB ports (aka 139, 445).

"""

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

PROPERTY['ARCH'] = [ ["Windows"] ]
TODO="""

"""

VERSION="1.0"

#affectsList=["Recon"]
PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

from libs.dcemarshall import *

class share:
    "used for share enum"
    def __init__(self,sharename="",comment="",sharetype=0,sharepath=None):
        self.sharename=sharename
        self.comment=comment
        self.sharetype=sharetype
        self.sharepath=sharepath
        self.password=None

    def __str__(self):
        name=utf16toascii(iso8859toascii(self.sharename)) #remove unicodeness
        comment=utf16toascii(iso8859toascii(self.comment))
        return "%s:%s"%(name,comment)
    
class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.result=""
        self.name=NAME
        self.systemname="\\\\127.0.0.1"
        return
    
    def createShareEnumPkt(self):
        """Creates the MSRPC packet for share enumeration"""
        funcidl="""
        
long  Function_0f( [in] [unique]  [string] wchar_t * element_122,
[in,out]  TYPE_16 * element_123,
[in]  long  element_126, /*prefered length?*/
[out]  long * element_127, /*records returned?*/ 
[in,out] [unique]  long * element_128 /*enum handle*/
 );

        """
        tidl="""
 typedef   struct {
  [unique] [string] wchar_t *share_name;
  long share_type;
  [unique] [string] wchar_t *comment;
  /* long element_17; incorrect?!?*/
 } TYPE_6;

typedef   struct {
  long element_18;
  [size_is(element_18)] [unique] TYPE_6 element_13; /*must be null pointer on call*/
 } TYPE_5;

typedef   [switch_type(long)] union {
/*  [case(0)] [unique] TYPE_3 *element_5; */
  [case(1)] [unique] TYPE_5 *element_10;
 } TYPE_2;

typedef   struct {
  long element_124;
  [switch_is(element_124)] TYPE_2 element_125;
 } TYPE_16;

        """
        data=""
        marshaller=dcemarshaller()
        self.marshaller=marshaller
        marshaller.define(tidl)
        
        e122=dcepointer(wchar_t(msunistring("\\\\"+self.target.interface),["[unique]"],marshaller),["unique"],marshaller)
        e123=marshaller.getinstance("TYPE_16")
        e123.setmember("element_124",dceint(1,[],marshaller))
        e125=marshaller.getinstance("TYPE_2")
        e125.switchval=1
        e123.setmember("element_125",e125)
        e10=marshaller.getinstance("TYPE_5")
        e125.setmember("element_10",e10)
        e13=dcepointer(None,[],marshaller)
        e10.setmember("element_18",dceint((0),[],marshaller))
        e10.setmember("element_13",e13)

        e126=dceint(-1,[],marshaller)
        e128=dcepointer(dceint((0),[],marshaller),["unique"],marshaller)
        
        data+=e122.marshall()
        data+=e123.marshall()
        data+=e126.marshall()
        data+=e128.marshall()
        self.log("Sending data of length %d"%len(data))
        #print "data:\n%s"%prettyhexprint(data)
    
        return data
    
    def parseEnumPkt(self,buf):
        self.log("parseEnumPkt: Buf length: %d"%len(buf))
        #self.log("parseEnumPkt: \n%s"%prettyhexprint(buf))
        #TYPE_16
        #int records returned
        #enum handler
        marshaller = self.marshaller
        info_level = dceint(amarshall=marshaller)
        buf = info_level.demarshall(buf)
        self.log("Info_levelA=%x" % info_level.value)
        buf = info_level.demarshall(buf) #union switch selector
        self.log("Info_levelB=%x" % info_level.value)
        num_elements = dceint(amarshall=marshaller)
        i,buf=getint(buf) #get reference pointer and ignore it
        buf = num_elements.demarshall(buf)
        self.log("Number of elements sent to us: %d"%num_elements.value)

        i,buf=getint(buf) #get reference pointer and ignore it        
        i,buf=getint(buf) #get size of array and ignore it
        #print "pointers?: %s"%prettyhexprint(buf[:4*num_elements.value] )
        #buf=buf[4*num_elements.value:] #ignore num pointers...
        #self.log("what's left: parseEnumPkt: \n%s"%prettyhexprint(buf))
        davecomment="""
        This is a complex array...meaning pointers are stored and then the data
        they reference is parsed at the end of the array.
        
        So it looks like this:

        structures:
        [<reference>
        <int>
        <reference> ] * Num_ent
        and then a big block of strings (2*num ent, of course)
        """
        buf2=buf[3*4*num_elements.value:] #reference only the strings
        #self.log("BUF2: parseEnumPkt: \n%s"%prettyhexprint(buf))
        shares=[]
        for e in range(0,num_elements.value):
            newshare=share()
            i,buf=getint(buf) #pointer to share name
            share.sharetype,buf=getint(buf)
            i,buf=getint(buf) #pointer to share comment
            newshare.sharename,buf2=getdcewchar(buf2)
            newshare.comment,buf2=getdcewchar(buf2)
            #self.log("Found share: %s"%str(newshare))
            shares+=[newshare]
        #t16=self.marshaller.getinstance("TYPE_16")
        #buf=t16.demarshall(buf)
        
        return shares

    def getargs(self):
        #need to revise to use get_knowledge/set_knowledge                    
        systemname=self.argsDict.get("systemname",self.systemname)
        self.host=self.target.interface
        self.user=self.argsDict.get("user",self.user)
        self.password=self.argsDict.get("password", self.password)
        return 
    
    def get_shares(self, user, password):
        """
        Makes the connection to the remote server and gets the
        shares. This is called twice, once with the typical thing
        and once with bob:None, since XP does a weird thing
        with users and password.
        """
        connectionList = ["ncacn_np:%s[\\browser]"% (self.target.interface)]
        self.myDCE = msrpc.DCE("4b324fc8-1670-01d3-1278-5a47bf6ee188", "3.0", connectionList, covertness = self.covertness, getsock=self)
        devlog('shareenum::run', "myDCE: %s" % self.myDCE)
        self.myDCE.setUsername(user)
        self.myDCE.setPassword(password)
        try:
            devlog('shareenum::run', "myDCE.connect: %s" % self.myDCE.connect)
            map=self.myDCE.connect()
            devlog('shareenum::run', "map: %s" % map)
            if not map:
                self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")
        except Exception, msg:
            devlog('shareenum::run', "Could not connect to remote server (%s): %s" % (Exception, msg))
            self.log(msg)
            return 0

        pkt=self.createShareEnumPkt()
        #send to function_02
        ret = msrpc.get_all_stubs(self.myDCE.call(15, pkt, response=1))
        #get result
        #parse result
        sharelist=self.parseEnumPkt(ret)
        return sharelist
    
    def run(self):
        self.getargs()
        self.setInfo("%s"%(NAME))
        self.log("Running shareenum against %s with user:pass = %s:%s"%(self.host,self.user, self.password))
        node=self.argsDict["passednodes"][0]
        #to test from commandline
        #runmodule userenum -t 1
        sharelist=[]
        if node.islocal(self.target.interface) and "win32api" in node.capabilities:
            self.log("Target is localhost on this Node")
            if "win32api" in node.capabilities:
                shell=node.shell
                sharenamelist=shell.NetShareEnum()
                #create a list of classes out of it
                for u in sharenamelist:
                    sharename,sharetype,shareremark,sharepath,sharepassword=u
                    self.log("Share found (unicode) %s : %s"%(prettyprint(sharename),prettyprint(shareremark)))
                    newshare=share(sharename=sharename,sharetype=sharetype,comment=shareremark,sharepath=sharepath)
                    sharelist+=[newshare]
            else:
                self.log("%s node type not supported"%node.nodetype)
        else:
            #is a remote target to our node
            if 0:
                #commented out for now...
                osd=self.engine.getModuleExploit("osdetect")
                osd.link(self)
                osd.run()
                osstr=osd.result
                self.log("OS Detected: %s"%osstr)
            if 1:
                self.log("Using srvsvc to enumerate shares")
                #connect to named pipe
                #bind to RPC server
                if not self.has_named_pipes(self.target):
                    self.log("No SMB ports open...")
                    return 0                    
                ret=self.get_shares(self.user, self.password)
                if ret==0 and not self.user:
                    self.log("Failed with the default blank user - trying user Bob")
                    ret=self.get_shares("Bob","")
                if ret:
                    sharelist=ret 
                
        self.result=sharelist
        self.log("Total Shares: %s"%len(sharelist))
        for u in sharelist:
            self.log("Share found: %s"%str(u))
        self.target.replace_knowledge("SMBShares",sharelist,100)
        
        self.setInfo("%s - done (success: %s)"%(NAME,"%d shares found"%len(sharelist)))
        return 1

if __name__ == '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
