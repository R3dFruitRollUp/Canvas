#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information

#from __future__ must be at beginning of file...
#from __future__ import generators

# 64 bit compatibility, wrap struct.pack and struct unpack
import os
import commands

class structWrap:
    def __init__(self, f = None):
        #print "XXX: WRAPPING STRUCTZ LOL"
        self.f = f
        return

    def amdsixquatro(self, a, k):
        #print "ALTERING: Args, Kwargs: ", a, k
        aList = list(a) # unfreeze the tuple to list
        sList = []
        for c in a[0]:
            if c == 'L': c = 'I'
            if c == 'l': c = 'i'
            sList.append(c)
        aList[0] = "".join(sList)
        a = tuple(aList) # freeze the list to tuple
        #print "ALTERED?: Args, Kwargs: ", a, k
        return a, k

    def __call__(self, *args, **kwargs):
        args, kwargs = self.amdsixquatro(args, kwargs)
        ret = self.f(*args, **kwargs)
        return ret

import struct

#we can use this to know if we are a 64 bit Python or not
original_long_size=struct.calcsize("<L")

#here's a better way to tell if we were 64 bit though...although you
#can have a 32 bit Python on a 64 bit OS...
am_64_bit=False 
    
try:
    #os.uname() not guaranteed to exist?
    if str(os.uname()).count("x86_64"):
        #example value on my box
        #('Linux', 'ubuntu', '2.6.23.1-grsec-testing', '#1 SMP Fri Nov 9 14:42:39 EST 2007', 'x86_64')
        am_64_bit=True
except:
    #no os.uname. so just imagine we are not 64 bit...
    pass 
    

threadchecknonMain_we_are_commandline = False

if not hasattr(struct, "_canvas_wrapped"):
    # swap out the real functions
    _pack = struct.pack
    _unpack = struct.unpack
    _calcsize = struct.calcsize

    # wrap the function with an arg modifier
    struct.pack = structWrap(_pack)
    struct.unpack = structWrap(_unpack)
    struct.calcsize = structWrap(_calcsize)

    # marker so we don't do it when not needed
    struct._canvas_wrapped = True

# end of 64 bit compatibility code

import sys, string
#thanks Tim O'Malley! (BSDish license)
import timeoutsocket
timeoutsocket.setDefaultSocketTimeout(5)
import socket
from MOSDEF.mosdefutils import *
from internal import * # a lot of files only include exploitutils and use internal functions via this include.
import threading
import random
from libs.tlslite.api import *
import time

# platform_is_win32
import os
global platform_is_win32
platform_is_win32 = False
if sys.platform in [ "win32" , "cygwin" ] or os.name == "nt":
    platform_is_win32 = True
#del os #why would we delete os?
import socket

def utf16toascii(buf):
    #replace all non-ascii characters with a ?
    if buf=="":
        return ""
    try:
        ret=buf.decode("utf-16-le").encode("ascii","replace")
    except UnicodeDecodeError:
        ret=prettyprint(buf)

    if ret[-1]=="\x00":
        ret=ret[:-1]
    return ret


def gettcplistener(listenport, listenhost="0.0.0.0", ipv6=False):
    """
    Returns None on failure

    """
    if ipv6:
        s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
    else:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)

    try:
        s.bind((listenhost,listenport))
    except socket.error:
        s.close()
        #import traceback
        #traceback.print_exc()
        return None

    s.listen(5)
    return s
import cStringIO
import gzip
def gzipBuffer(buffer):
    """
    Gzip encodes a buffer, retunring a string of compressed data. This will add the header and footer information
    needed by the HTTP spec. Normal zlib.compress() will not, so you can't use it for Content-Encoded: gzip format.
    """
    zbuf = cStringIO.StringIO()
    zfile = gzip.GzipFile(mode = 'wb',  fileobj = zbuf, compresslevel = 9)
    zfile.write(buffer)
    zfile.close()
    return zbuf.getvalue()

#simpler routines for simpler functions
import StringIO
def gunzipstring(data):
    """
    Gunzip's a string, or throws an exception
    """
    datastream=StringIO.StringIO(data)
    g=gzip.GzipFile(fileobj=datastream)
    data=g.read()
    return data

def gzipstring(data):
    """
    Gzip's a string to another string using StringIO
    """
    datastream=StringIO.StringIO()
    g=gzip.GzipFile(mode="wb",fileobj=datastream)
    g.write(data)
    g.close()
    ret=datastream.getvalue()
    return ret

# read: 0x61626364 == offset 0x1234 .. low nibble for each byte
def offsets(size, endian='<', mask=0x60606060):
    dwords = []
    ret = ""
    align = size % 4
    for i in range(0, size/4): # /sizeof(dword)
        nibbles = []
        nibbles.append(((i*4 + align) & 0xf000) >> 12)
        nibbles.append(((i*4 + align) & 0x0f00) >> 8)
        nibbles.append(((i*4 + align) & 0x00f0) >> 4)
        nibbles.append(((i*4 + align) & 0x000f))
        masked = mask
        masked |= nibbles[0] << 24
        masked |= nibbles[1] << 16
        masked |= nibbles[2] << 8
        masked |= nibbles[3]
        print "[+] masked: %.8X" % masked
        dwords.append(masked)
    for dword in dwords:
        ret += struct.pack(endian + 'L', dword)
    print "[+] returning .. %s" % ret
    return align * 'A' + ret

def iso8859toascii(buf):
    """
    00 -> 7F: ASCII
    A0 -> FF: ISO8859
    """
    table = {0x82:'e',
             0xa1:'!', 0xa2:'c', 0xa3:'L', 0xa5:'Y', 0xa6:'|', 0xa7:'S', 0xa8:'"', 0xa9:'(c)', 0xab:'<<',
             0xad:'-', 0xae:'(R)', 0xb0:'o', 0xb1:'+/-', 0xb2:'^2', 0xb3:'^3', 0xb4:'\'', 0xb5:'u', 0xb6:'P',
             0xb8:',', 0xb9:'^1', 0xba:'o', 0xbb:'>>', 0xbc:'1/4', 0xbd:'1/2', 0xbe:'1/3', 0xbf:'?',
             0xc0:'A', 0xc1:'A', 0xc2:'A', 0xc3:'A', 0xc4:'A', 0xc5:'A', 0xc6:'AE', 0xc7:'C',
             0xc8:'E', 0xc9:'E', 0xca:'E', 0xcb:'E', 0xcc:'I', 0xcd:'I', 0xce:'I', 0xcf:'I',
             0xd0:'D', 0xd1:'N', 0xd2:'O', 0xd3:'O', 0xd4:'O', 0xd5:'O', 0xd6:'O', 0xd7:'x',
             0xd8:'O', 0xd9:'U', 0xda:'U', 0xdb:'U', 0xdc:'U', 0xdd:'Y', 0xde:'b', 0xdf:'B',
             0xe0:'a', 0xe1:'a', 0xe2:'a', 0xe3:'a', 0xe4:'a', 0xe5:'a', 0xe6:'ae', 0xe7:'c',
             0xe8:'e', 0xe9:'e', 0xea:'e', 0xeb:'e', 0xec:'i', 0xed:'i', 0xee:'i', 0xef:'i',
             0xf0:'d', 0xf1:'ni', 0xf2:'o', 0xf3:'o', 0xf4:'o', 0xf5:'o', 0xf6:'o', 0xf7:'%',
             0xf8:'o', 0xf9:'u', 0xfa:'u', 0xfb:'u', 0xfc:'u', 0xfd:'y', 0xfe:'b', 0xff:'y'}
    ret = ""
    for c in buf:
        ordc = ord(c)
        if table.has_key(ordc):
            #devlog('iso8859toascii::replace', "0x%02x -> %s" % (ordc, table[ordc]))
            ret += table[ordc]
        else:
            if ordc > 0x7f and ordc < 0xa0:
                #devlog('iso8859toascii::missing', "not keeping non-ASCII char 0x%02x: %s" % (ordc, c))
                ret+= "?"
            else:
                #devlog('iso8859toascii::keep', "keeping ISO8859 char 0x%02x -> %s" % (ordc, c))
                ret += c
    return ret


letras = string.ascii_letters + string.ascii_uppercase + string.digits


def randomstring(length):
    import random
    return "".join([random.choice(letras) for a in range(0, length)])


def xorstrings(a, b):
    """
    Xors two string/list of chars together and returns the string result

    b is the key, and if it is not long enough, it will be reused from the beginning
    """
    tmp=[]
    for i in xrange(len(a)):
        a1=str(a[i])
        b1=str(b[i%len(b)])
        c1=ord(a1)^ord(b1)
        tmp+=[chr(c1)]
    return "".join(tmp)

def hexify(astr):
    """
    from \x41 to "\x41"
    """
    ret=""
    for c in astr:
        ret+="\\x%2.2x"%ord(c)
    return ret

def prettydictprint(adict):
    """
    print out a dictionary how I like it printed out ...
    """
    keys=adict.keys()
    keys.sort()
    ret2="{"
    for key in keys:
        ret2+="\"%s\" : \"%s\", "%(hexify(key),hexify(adict[key]))
    ret2+="}"
    return ret2

def prettyhexprint(s,length=8):
    """
    A nicely displayed hexdump as a string
    """
    # we are expecting a string here
    if not type(s) == type(""):
        return "can not hexdump %s" % type(s)
    tmp=[]
    i=1
    for c in s:
        tmp+=["%2.2x "%ord(c)]
        if i%length==0:
            tmp+=["\n"]
        i+=1
    return "".join(tmp)


def cleanhexprint(s):
    """    
    turns ABCD
    into 
    41424344
    """
    tmp=[]
    for c in s:
        tmp+=["%2.2x"%ord(c)]
    return "".join(tmp)


# Note: this is a 5m lame function
def hexdump(buf):
    tbl=[]
    tmp=""
    hex=""
    i=0
    for a in buf:
        hex+="%02X "% ord(a)
        i+=1
        if ord(a) >=0x20 and ord(a) <0x7f:
            tmp+=a
        else:
            tmp+="."
        if i%16 == 0:
            tbl.append((hex, tmp))
            hex=""
            tmp=""
    tbl.append((hex, tmp))
    return tbl


def onlystrings(instr):
    """
    prints out all the strings - ununicodes, etc
    """
    instr=instr.replace("\x00","")
    tmp=""
    space=0
    for ch in instr:
        if (ch.isalnum() or ch in goodchars) and ord(ch)<127:
            tmp+=ch
            space=0
        else:
            if not space:
                tmp+=" "
                space=1
    return tmp


def iisuni(inint):
    """
    Transforms an integer into %uXXYY%uZZAA - little endia order for IIS use
    """
    ret=""
    ret+="%%u%4.4x%%u%4.4x"%(inint & 0xffff,((inint &0xffff0000L) >> 16) &0xffff)
    return ret


def iisunibuf(buf):
    """
    covert an entire buffer into IIS unicode format (note: makes 12 characters out of 4)
    """
    ret=""
    mod=4-len(buf)%4
    if mod!=4:
        buf+="\x00"*mod

    while buf!="":
        ret+="%%u%2.2x%2.2x%%u%2.2x%2.2x"%(ord(buf[1]),ord(buf[0]),ord(buf[3]),ord(buf[2]))
        buf=buf[4:]

    return ret


def xmlencode(buf):
    """
    takes in a string and encodes it to change all XML entities (& " etc) into their XML escape codes
    http://www.w3schools.com/xml/xml_cdata.asp
    """
    buf=str(buf)
    translation={ "<": "&lt;" , ">": "&gt;", "&": "&amp;", "'": "&apos;", "\"": "&quot;" }
    for key in translation:
        buf=buf.replace(key,translation[key])
    return buf


def xmldecode(buf):
    """
    opposite of xmlencode()
    """
    from xml.sax.saxutils import unescape as xmlunescape
    return xmlunescape(buf, {"&apos;": "'", "&quot;": '"'})


def urlencode(buf):
    tmp=""
    for c in buf:
        tmp+="%%%2.2x"%ord(c)
    return tmp

def urluencode(buf):
    tmp = []
    bufsize = len(buf)
    for c in range(0, bufsize - bufsize%2, 2):
        tmp.append("%%u%02x%02x" % (ord(buf[c+1]), ord(buf[c]) )  )
    if bufsize %2:
        tmp.append( "%%u%02x41" %  ord(buf[bufsize-1]) )
    return string.joinfields(tmp, "")

def uuencode(buf):
    import binascii
    s = ""
    l = 0
    while l < len(buf):
        s += binascii.b2a_uu(buf[l:l+45])
        l += 45
    return s


def uudecode(buf):
    import binascii
    # XXX do it for each line\n of buffer ?
    return binascii.a2b_uu(buf)


def uuencode_file(buf, filename="file", filemode=0644):
    return "begin %o %s\n%s`\nend" % (filemode & 0777, filename, uuencode(buf))


def b64encode(buf):
    import binascii
    return binascii.b2a_base64(buf)


def b64decode(buf):
    import binascii
    return binascii.a2b_base64(buf)


def indexable(var):
    return hasattr(var, '__getitem__')


def sizeable(var):
    return hasattr(var, '__len__')


def allowAddress(addr, badbytelist):
    for a in range(0, 32, 8):
        tmp= (addr >> a) & 0xff
        if tmp in badbytelist:
            return 0
    return 1


def intel_hex(instring):
    """
    reverses a string in hex
    """
    instring=binstring(instring)
    inlist=list(instring)
    inlist.reverse()
    instring="".join(inlist)
    return instring


def getbyte(buf):
    """
    Gets one byte from the stream and returns it as an integer value 
    """
    return ord(buf[0]), buf[1:]

def getint(buf):
    """For reading an intel order integer out of a buffer
    returns integer_in_intel_order, buf[4:]"""
    return istr2int(buf),buf[4:]


def getshort(buf):
    """
    Get an intel-orderd 16 bit integer from the buffer
    returns <the integer>,  <buffer[2:]>
    """
    return istr2halfword(buf),buf[2:]


#return 1 if there is a bad character in an integer word (converted to a str).
#of course, if you pass a string in, we just handle it as a string
def hasbadchar(word,badchars):
    try:
        wordstr=intel_order(word)
    except:
        wordstr=str(word)
    for ch in badchars:
        if wordstr.count(ch):
            return 1
    return 0


#returns a string with every other byte in it
def everyother(buffer):
    result=""
    i=0
    while i<len(buffer):
        result+=buffer[i]
        i+=2
    return result


def csub(a,b):
    """
    Do subtraction like C does, with wrapover
    don't automatically convert to a LONG integer,
    which screws everything up
    """
    #print "A=%8.8x - B=%8.8x"%(a,b)
    c=uint32(a-b)   
    #print "C= %8.8x %s"%(c,str(type(c)))   
    return c

def istr2double(astring):
    firsthalf=str2littleendian(astring)
    secondhalf=str2littleendian(astring[4:])
    return long(firsthalf)+(long(secondhalf)<<32)

def reversedword(myint): #just here for namespace
    return reverseword(myint)

def reverseword(long):
    data=intel_order(long)
    ret=str2bigendian(data)
    return ret


def reverseshort(myshort):
    data=halfword2istr(myshort)
    newshort=nstr2halfword(data)
    return newshort


def s_intelword(myint):
    return intel_order(myint)

def UTF16toUTF8(utf16buf):
    """Unicode to UTF-8 encoder, should be Windows compliant."""
    utf8buf=''
    if (len(utf16buf)%2)==1:
        utf16buf+='\x00'
    for i in range(0,len(utf16buf),2):
        import struct
        H=struct.unpack('<H',utf16buf[i:i+2])[0]
        #print '%d'%(H)
        if H<0x80:
            utf8buf+=utf16buf[i]
        elif H<0x800:
            utf8buf+=chr(0xc0|((ord(utf16buf[i+1])&0xf)<<2)|(ord(utf16buf[i])>>6))
            utf8buf+=chr(0x80|(ord(utf16buf[i])&0x3f))
        else:
            utf8buf+=chr(0xe0|(ord(utf16buf[i+1])>>4))
            utf8buf+=chr(0x80|((ord(utf16buf[i+1])&0xf)<<2)|(ord(utf16buf[i])>>6))
            utf8buf+=chr(0x80|(ord(utf16buf[i])&0x3f))
    return utf8buf

#returns a binary version of the string
def binstring(instring):
    result=[]
    #erase all whitespace
    tmp=instring.replace(" ","")
    tmp=tmp.replace("\n","")
    tmp=tmp.replace("\t","")
    tmp=tmp.replace("\r","")
    tmp=tmp.replace(",","")


    if len(tmp) % 2 != 0:
        print "tried to binstring something of illegal length: %d: *%s*"%(len(tmp),prettyprint(tmp))
        return ""

    while tmp!="":
        two=tmp[:2]
        #account for 0x and \x stuff
        if two!="0x" and two!="\\x":
            result+=[chr(int(two,16))]
        tmp=tmp[2:]
    result="".join(result)
    return result


def pathunique(newpath):
    if newpath not in sys.path:
        sys.path.append(newpath)


def s_binary(instring):
    """
    for spike compatability
    """
    return binstring(instring)


#overwrites a string in place...hard to do in python
def stroverwrite(instring,overwritestring,offset):
    """
    We use this in our exploits as a way to keep them clean.
    str += str
    str += str2 is bad form.
    
    This api is more of a memcpy() which allows for easy setting of eip offsets and such.
    
    """
    head=instring[:offset]
    #print head
    tail=instring[offset+len(overwritestring):]
    #print tail
    result=head+overwritestring+tail
    return result


def getnullstring(instring):
    null=instring.find("\x00")
    if null==-1:
        return instring
    return instring[:null]


def sunrpcstr(instring, nonull=0):
    ret=big_order(len(instring))+sunstring(instring,nonull=nonull)
    return ret


def pad4(instr):
    return sunstring(instr,nonull=1)


def sunstring(instring,nonull=0):
    """
    pads out a string with a null and to %4
    """

    #print "instring=%s"%instring
    ret=instring
    if not nonull:
        instring+=chr(0)

    padlen=4-len(ret)%4
    if padlen==4:
        padlen=0
    #print "Len=%d mod4=%d"%(len(ret),padlen)
    ret+=chr(0)*(padlen)
    #print "hexofit=%s"%hexprint(ret)
    return ret


def mod4string(astr):
    return sunstring(astr)


def small_prettyprint(instring):
    prtstring=prettyprint(instring)
    if len(prtstring)>100:
        prtstring=prtstring[:50]+"..."+prtstring[-50:]
    return prtstring


def cprint(instring):
    """
    prints out a  buffer the way C would like to see it
    """

    tmp=""
    tmp="\"" #add start quote
    for ch in instring:
        value="\\x%2.2x" % ord(ch)
        tmp+=value
    tmp+="\"" #add finish quote
    return tmp

def getsitebase(url):
    """
    Used by spkproxy.SPIDER() to get the site base of a url.
    """
    return "".join(url.split("/")[2:3])+"/"

#returns None on error
#returns a dictionary of a string split like a normal HTTP argument list
def splitargs(argstring,orderlist=[]):
    resultDict={}
    templist=argstring.split("&")
    for pair in templist:
        if pair!="":
            templist2=pair.split("=")
            if len(templist2)<2:
                #print "Failed to parse the URL arguments because of
                #invalid number of equal signs in one argument in:
                #\""+pair+"\" len="+str(len(templist2))
                return None
            else:
                #add this argument to the Dict
                orderlist.append(templist2[0])
                resultDict[templist2[0]]="=".join(templist2[1:])
    return resultDict


def geturl(url,post):
    """
    Gets a URL via GET or POST
    returns None on errors
    """
    import urllib
    newurl=url.split("?")[0]
    try:
        urldict=splitargs(url.split("?")[1])
    except:
        urldict={}
    params = urllib.urlencode(urldict)

    if post:
        inurl=urllib.urlopen(newurl,params)
    else:
        newurl=newurl+"?"+params
        inurl=urllib.urlopen(newurl)
    if inurl==None:
        return None

    data=inurl.read()
    return data


def msunistring(instr):
    """Does a backwards string from a standard ASCII string and then adds two nulls"""
    if instr in [0,None]:
        # a null pointer ...
        return None
    ret=""
    ret+=backwardsunistring(instr)
    ret+="\x00\x00"
    return ret



def str_from_object(obj, blacklist=None):
    """
    Converts any object into a string representation
    in a recursive fashion
    """
    if blacklist==None:
        blacklist={}
    ret=""
    if str(obj) in blacklist:
        return "<blacklisted obj>"

    blacklist[str(obj)]=True 
    if type(obj) == type([]):
        #we have a list
        ret+="["
        for o in obj:
            ret+=str_from_object(o, blacklist)
            ret+=","
        ret=ret[:-1]
        ret+="]"
    elif type(obj) == type({}):
        #dictionary
        ret+="{"
        for o in obj.keys():
            ret+="%s: "%o
            ret+=str_from_object(obj[o], blacklist)
            ret+=","
        ret=ret[:-1]
        ret+="}"
    else:
        ret+=str(obj)

    return ret 



def int32toIpstr(uint, swap=False):
    return socket.inet_ntoa(int2str32(uint, swap=swap))


def getNetworkInterfaces():
    """Returns a list of the network interfaces on the current machine, win32 or linux"""
    ret=[]
    for i in getInterfaceData():
        ret+=[i[0]]
    return ret

def parserouteprint(data):
    """
    Instead of parsing the ipconfig /all which relies on English
    text, we can pattern match a "route print" command much better.
    With Adam's blessing we will deprecate parseipconfig()
    """
    final_list      = []
    interface_count = 1
    split_string = "=" * 75
    
    route_table  = data.split(split_string)[3].split("\n")
    clean_route_table  = route_table[3:len(route_table)-2]
    
    # Now walk through the table and obtain all of the
    # interfaces and IP addresses
    found_ips = {}
    
    for route in clean_route_table:
        entry     = route.split(" ")
        temp_list = []
        
        for ip in entry:
            if ip:
                temp_list.append(ip)
                
        if len(temp_list):
            # Build our final list
                        
            ip_addr = temp_list[3].replace("\t","").replace("\n","")
            
            if temp_list[1] != "255.255.255.255" and temp_list[1] != "0.0.0.0":
                if not found_ips.has_key(ip_addr):
                    netmask =  str2bigendian(socket.inet_aton(temp_list[1]))
                    final_list.append(["#%d" % interface_count, ip_addr, netmask])
                    found_ips[ip_addr] = netmask                
                    interface_count += 1
    
    return final_list


def parseipconfig(data):
    """some ugly parsing of ipconfig /all
    TODO: Ensure that other langauges use the same Mask and IP values...
    """
    ret=[]
    interfaces=data.split(":\r\n\r\n")
    print "Number of interfaces=%s"%(len(interfaces)-1)
    #print "Interfaces0=%s\n\n\n"%interfaces[0]
    #print "Interfaces1=%s\n\n\n"%interfaces[1]
    #the interface name is from \nto the :\r\n\r\n
    for inum in range(0,len(interfaces)):
        i=interfaces[inum]
        name=i.split("\r\n")[-1]
        #print "Name=%s"%name
        try:
            i2=interfaces[inum+1]
        except:
            #print "Breaking..."
            break
        i3=i2.split("\r\n") #now we have a list of our entries
        netmask=""
        for item in i3:
            #print "item=%s"%item
            if not item.count(":"): 
                continue #blank line, so continue
            desc,value=item.split(":")[:2]
            #print "desc, value=%s,%s"%(desc,value)
            if desc.count("IP"):
                IP=value.replace(" ","").strip()
            elif desc.count("Mask"):
                netmask=value.replace(" ","").strip()
        if netmask !="":
            netmask=str2bigendian(socket.inet_aton(netmask))
        else:
            print "Netmask is null? Setting to 255.255.255.255"
            netmask=str2bigendian("\xff"*4) #windows can't use inet_aton("255.255.255.255") for some reason

        mylist=[name,IP,netmask]
        #print "mylist=%s"%mylist
        ret.append(mylist)
    return ret


def parseGETS2(data):
    import struct
    ret =[]
    for a in data.split("\n"):
        if a=="":
            continue
        b=a.split(" ")
        devlog('parseGETS2', b)
        ndx=string.atoi(b[0], 16)
        addr = socket.inet_ntoa(struct.pack("L", string.atoi(b[1], 16)))
        mask = socket.htonl(string.atoi(b[2], 16))
        if addr and mask:
            ret.append( ["#%d" % ndx, addr, mask])
    return ret

def parseIPV6IFS(data):
    """
    Parses IPV6IFS.exe output in the form of 'IFID ADDRESS%SCOPE'
    """

    import struct
    ret = []
    for a in data.split("\n"):
        if a=="":
            continue
        b = a.split(" ")
        devlog('parseIPV6IFS', b)
        ifid = "#" + b[0]
        addr = b[1]
        print "Win32 IPv6 parsed .. ifid %s -> addr %s"% (ifid, addr)
        mask = "0xffffffffffffffff" # bogus mask for now BETA
        if addr.find("error") != 0:
            ret.append( [ifid, addr, mask] )
    #print ret
    return ret

def win32InterfaceTypeByNumber(itype):
    # <ipifcons.h>
    MIB_IF_TYPE = {1:'other', 6:'ethernet', 9:'tokenring', 15:'fddi', 23:'ppp', 24:'loopback', 28:'slip'}
    if MIB_IF_TYPE.has_key(itype):
        return MIB_IF_TYPE[itype]
    return "unknown(%d)" % itype


def af_familyByNumber(num):
    """
    Address family name by number
    """

    afnames = {}
    for name in dir(socket):
        if name[:3] == "AF_":
            afnames[getattr(socket, name)] = name
    if afnames.has_key(num):
        return afnames[num]
    return "unknown family %d" % num

def getInterfaceListBSD():
    """
    This function uses fctrl and is hence highly annoying to debug, but it does
    get the interface list from Linux (and presumably from OS X/BSD)
    """
    #get a list of interfaces using ioctl
    import fcntl, socket
    import struct, array
    interfaceList = []
    if sys.platform.count("linux"):
        SIOCGIFCONF = 0x8912
    elif sys.platform.count("darwin") or sys.platform.count("sunos"):
        SIOCGIFCONF = sint32(0xc0086914L) # old socket I/O ioctl
    else:
        return []
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    buffer = array.array('c', '\x00' * 1024)
    ifc = struct.pack("iP", buffer.buffer_info()[1], buffer.buffer_info()[0])
    try:
        ifc = fcntl.ioctl(s, SIOCGIFCONF, ifc)
    except:
        #unfortunately for VS, if we get this bug the user can't use their shellcode :<
        print "Unexpected fcntl behaviour! add interfaces manually"
        return []
    size, ptr = struct.unpack("iP", ifc)
    devlog('getInterfaceListBSD', "IFC Data: \n%s"%prettyhexprint(ifc))

    if am_64_bit:
        sizeof_struct_ifconf = 40 #not sure why , just is 
    else:
        sizeof_struct_ifconf = 32
    
    
    devlog('getInterfaceListBSD', "found %d interfaces with ioctl(SIOCGIFCONF)" % (size / sizeof_struct_ifconf))
    buffstr=buffer.tostring()
    devlog('getInterfaceListBSD', "Interface Data: \n%s"%prettyhexprint(buffstr))

    for idx in range(0, size, sizeof_struct_ifconf):
        ifconf = buffstr[idx:idx+sizeof_struct_ifconf]
        #name = struct.unpack("16s16x", ifconf)[0]
        fmt="@16sH14x"
        name, af_family = struct.unpack(fmt, ifconf[:struct.calcsize(fmt)])
        name, therest = name.split('\0', 1)
        devlog('getInterfaceListBSD', "interface%d: %s (%s)" % \
               (idx / sizeof_struct_ifconf, prettyprint(name), prettyprint(af_familyByNumber(af_family))))
        if (af_family == socket.AF_INET or af_family == socket.AF_INET6) and not name in interfaceList:
            interfaceList += [name]
    return interfaceList


def getIPFromInterfaceBSD(interface):
    import fcntl, socket
    if sys.platform.count("linux"):
        SIOCGIFADDR = 0x8915
    elif sys.platform.count("darwin") or sys.platform.count("sunos"):
        SIOCGIFADDR = sint32(0xc020690dL) # old socket I/O ioctl
    else:
        return None
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
    try:
        r = fcntl.ioctl(s.fileno(), SIOCGIFADDR, interface + 256 * '\x00')
    except:
        print "Unexpected fcntl behaviour! add interface manually"
        return None
    ip = socket.inet_ntoa(r[20:24])
    return ip

def getIPv6FromInterfaceLinux(interface):
    " Uses /proc/net/if_inet6 to get ipv6 addresses to interfaces "
    #print "[!] checking for Linux IPv6 interfaces ..."

    try:
        fd = open("/proc/net/if_inet6", "r")
    except IOError:
        #print "[!] no Linux IPv6 information found"
        return []
    #print "[!] parsing if_inet6 for: %s"% interface

    import struct
    import string

    addrlist = []
    try:
        # address, index, plen, scope, flags, interface
        # fe80000000000000020c29fffe18aa1c 02 40 20 80     eth0
        for line in fd.readlines():
            iflist = line.split() # split on spaces
            paddress = iflist[0] # the address in raw hex
            plen = string.atoi(iflist[2], base=16) # XXX: netmask ?
            pif = iflist[5] # the interface it's on
            address = struct.unpack("4s4s4s4s4s4s4s4s", paddress) # we want a string
            if interface in pif: 
                address = ':'.join(address) # to : form
                import socket
                # compress the address (google for the win!)
                address = socket.inet_ntop(socket.AF_INET6, socket.inet_pton(socket.AF_INET6, address))
                #print "[!] IPv6: %s -> %s/%s"% (interface, address, plen)
                addrlist += [ [ address, plen ] ]
    except:
        import traceback
        traceback.print_exc(file=sys.stderr)
        #addrlist needs to be returned, but we're done parsing 
        pass 
    # return a list of found ipv6 addresses for that interface
    return addrlist

def getLinuxIPFromInterface(interface):
    return getIPFromInterfaceBSD(interface)

def getSolarisIPFromInterface(interface):
    return getIPFromInterfaceBSD(interface)

def getNetmaskFromInterfaceBSD(interface):
    import fcntl, socket
    import struct, array
    if sys.platform.count("linux"):
        SIOCGIFNETMASK = 0x891b
    elif sys.platform.count("darwin"):
        SIOCGIFNETMASK = sint32(0xc0206915L) # old socket I/O ioctl
    elif sys.platform.count("sunos"):
        SIOCGIFNETMASK = sint32(0xc0206919L)
    else:
        return None
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ifc = interface + "\x00" * (64 - len(interface))
    try:
        ifc = fcntl.ioctl(s, SIOCGIFNETMASK, ifc)
    except:
        print "Unexpected fcntl behaviour! add interface manually"
        return None
    netmask  = struct.unpack(">20xL40x", ifc)[0]
    return netmask


def getLinuxNetMask(interface):
    return getNetmaskFromInterfaceBSD(interface)


def getSolarisNetMask(interface):
    return getNetmaskFromInterfaceBSD(interface)


def getInterfaceData():
    #print "[C] Getting interface data"

    #import socket

    interfaceList = []
    ifacelist = []

    if platform_is_win32:
        if 1: # XXX except:
            devlog('getInterfaceData', "using GETIFS2.exe method")
            #get a list of interfaces by parsing ipconfig /all
            #interfaceList+=[["lo","127.0.0.1",0xff000000L]]
            command="GETIFS2.exe"
            if sys.platform=="cygwin":
                command="./"+command
            p=os.popen2(command)
            d=p[1].read()
            interfaceList += parseGETS2(d)
            #interfaceList=interfaceList[:-1]

            try:
                # XXX: IPv6 interfaces for win32 gui
                command = "IPV6IFS.exe"
                if sys.platform == "cygwin":
                    command = "./" + command
                p = os.popen2(command)
                d = p[1].read()
                interfaceList += parseIPV6IFS(d)
            except: # ugly
                print "IPv6 not supported on this Win32 Host ..."

    elif sys.platform.count("linux") or sys.platform.count("darwin") or sys.platform.count("sunos"):
        ifacelist = getInterfaceListBSD()
        for ifname in ifacelist:
            ip = getIPFromInterfaceBSD(ifname)
            netmask = getNetmaskFromInterfaceBSD(ifname)
            if ip != None and netmask != None:
                interfaceList.append([ifname, ip, netmask])

    # IPv6 interface adding for linux
    if sys.platform.count("linux"):
        if ifacelist == []:
            ifacelist = getInterfaceListBSD() 
        for ifname in ifacelist:
            addrlist = getIPv6FromInterfaceLinux(ifname)
            # addrelist: [ address, netmask_in_bits ] XXX check for validity
            for line in addrlist:
                ip = line[0]
                plen = line[1]
                netmask  = "0x" + "f" * (int(plen) / 4)
                netmask += "0" * (16 - (int(plen) / 4)) 
                interfaceList.append([ifname, ip, netmask])

    else:
        print "sys.platform: %s - using default of loopback" % sys.platform

    if interfaceList == []:
        interfaceList += [["lo","127.0.0.1",0xff000000L]]

    #print "Returning %s"%interfaceList
    return interfaceList


def xordata(data,key):
    ret=[]
    for ch in data:
        ch=chr(ord(ch) ^ key)
        ret+=[ch]
    return "".join(ret)

def get_source_ip(target):
    """
    Returns an IP address to send out from given a target ip address or host
    name
    """
    #We fake a connection here just to find the callback interface
    randport=random.randint(1,65534)
    find_me=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    #devlog("canvasengine","Connecting to %s:%d"%(target,randport))
    try:
        find_me.connect((target,randport))
    except socket.error:
        #could not assign requested address - i.e. we tried to connect
        #to a 192.168.1.0 and the computer complained
        #I dunno why it does this. It's super annoying.
        #This will always happen on udpscan, for example
        return None 
    callback_ip=find_me.getsockname()[0]
    find_me.close()
    return callback_ip    

# Gets the MAC address from the interface provided
def getIfaceMAC(iface):
    """
    could also use:
    self.interface_name,self.interface_protocol,self.packet_type,self.hardware_type,self.hardware_address = self.ips.getsockname()
    """
    c = commands.getstatusoutput("ifconfig "+ iface)    
    b = c[1].split("HWaddr")
    if(len(b)>1):
        d = b[1].split(" ")
        return d[1].strip()
    else:
        return "00:00:00:00:00:00"


def getIPfromInterface(interface):
    IP="Unknown"
    if sys.platform=="win32":
        if interface=="lo":
            return "127.0.0.1"
        else:
            import os
            i2=""
            try:
                #this will fail on multiple interfaces...
                command="ipconfig /all"
                p=os.popen2(command)
                d=p[1].read()
                interfaces=d.split(":\r\n\r\n")
                #the interface name is from \nto the :\r\n\r\n
                for inum in range(0,len(interfaces)):
                    i=interfaces[inum]
                    name=i.split("\r\n")[-1]
                    if name==interface:
                        i2=interfaces[inum+1]
                        #print "i2=%s"%i2
                        #sixth unit down is the IP
                        IP=i2.split(":")[6].replace(" ","")
                        IP=IP.split("\r\n")[0]
            except:
                #some kind of parsing bug! Need to fix:
                print "Parsing bug (please paste to dave) - you'll have to set "
                print "I2=%s"%i2
                print "interface=%s"%interface
                try:
                    print "IP=%s"%IP
                except:
                    pass

                import traceback
                traceback.print_exc(file=sys.stdout)
                IP="127.0.0.1"
            return IP
    # XXX getLinuxIPfromInterface() not implemented
    #elif sys.platform.count("linux"):
    #    #not win32
    #    #Linux. We need Solaris Support here too.
    #    IP=getLinuxIPfromInterface(interface)
    #    return IP
    else:
        print "sys.platform of %s not fully supported. . . returning 127.0.0.1"%sys.platform
        return "127.0.0.1"


def getAllLocalIPs():
    return getInterfaceData()   
    """
    ipList=[]
    for interface in getNetworkInterfaces():
        ipList+=[getIPfromInterface(interface)]
    return ipList
    """


def getLocalIP():
    """
    Gets the local IP via some dumb tricks with popen()
    No good multiplatform way to do this though
    """
    IP=getAllLocalIPs()[0][1]
    return IP


def getIPfromARPTable():
    """
    Read hosts out of the arp cache and add them to our list
    """
    import os
    ipList = []
    if sys.platform == "win32" or os.name == "nt":
        try:
            if 0:
                #canvas_win32api only exists for Python24
                #so let's not do this
                import canvas_win32api
                arplist = canvas_win32api.GetARPEntryList()
                for entry in arplist:
                    ipList += [int32toIpstr(entry['Addr'], swap=True)]
        except:
            pass
    else:
        try: # Linux at least
            arplist=file("/proc/net/arp").readlines()[1:]
            for entry in arplist:
                if entry.count("00:00:00:00:00:00"):
                    continue
                ipList += [entry.split(" ")[0]]
        except IOError:
            pass
    return ipList


def read_bigendianword_packet(s):
    data=s.recv(4)
    #print "Data=%s"%prettyprint(data)
    size=str2bigendian(data)
    #print "Size=*%d*\n"%size
    data=s.recv(size)
    return data


def send_bigendian_halfword_packet(s,packet,additive=0):
    length=len(packet)+additive
    size=chr(length/256 & 0xff)
    size+=chr(length & 0xff)
    packet=size+packet
    return s.send(packet)


def rrecv(sock,size):
    retdata=""
    newsize=0
    while newsize<size:
        data=sock.recv(1)
        if data=="":
            print "Connection ended!?"
            return retdata
        retdata+=data
        newsize+=len(data)
    return retdata


def recv_bigendian_halfword_packet(sock,additive=0):
    data=rrecv(sock,2)
    #print "size is "+prettyprint(data)
    size=ord(data[0])<<8
    size+=ord(data[1])
    #print "Size of packet: %x"%size
    data2=rrecv(sock,size+additive)
    return data2


def intelword_recv(s):
    """
    This function recieves an intel_order 32 bit integer,
    and then recieves that much data from the socket

    It may throw the timeout exception if it did not get all
    the data it expects
    """
    data=s.recv(4)
    #print "Data is "+prettyprint(data)
    size=istr2int(data)
    data=s.recv(size)
    return data


def intelhalfword_recv(s):
    """
    This function is used for some network protocols
    that send a sixteen bit intel_order (unsigned) number
    and then a block of data of that size

    It may throw a timeout exception if the data does not 
    arrive in time
    """
    data=s.recv(2)
    size=istr2halfword(data)
    data=s.recv(size)
    return data


def badchartest(start,end,badchars):
    """
    used for generating strings to test for bad characters
    Generates strings such as:
    \x00\x01\x02...\xff that won't contain any characters in badchars argument, which should
    be a string (from self.badchars, typically).
    """
    tst=""
    for c in range(start,end+1):
        if chr(c) not in badchars:
            tst+=chr(c)
    return tst

# Check if an IP is in the local reserved range
def check_reserved(ip):
    reserved = [ "10.", "127.", "192.168.", "0." ]
    # Append A class subrange for 172.
    for x in range(16,32):
        reserved.append("172."+ str(x) + ".")

    for x in reserved:
        if x == ip[:len(x)]:
            return True

    return False


# Converts IP netmask format to the CIDR format
def nmask2cidr(nmask):
    ip = struct.unpack(">L", socket.inet_aton(nmask))[0]
    result=0
    while(1):
        # Bitwise least significant shifting
        if ip==0 or (ip&1):
            break
        ip>>=1
        result+=1

    # we go opposite in big endian
    return 32-result

class IPList:
    """
    Class used for efficient production of a long list of
    IP's from an IP and netmask
    """
    def __init__(self,ip,netmask):
        """netmask is the /24, not the ffffff00"""
        #print "Netmask=%d"%netmask
        self.ip=str2bigendian(socket.inet_aton(ip))
        self.netmask=uint32(netmask)
        #print "netmask=%s"%netmask
        self.numberofips=2**(32-uint32(netmask)) #how many ip's total
        #print "number of ips=%s"%self.numberofips
        self.ip=self.ip&(~(self.numberofips-1)) #need to mask it out so we don't do wacky things
        return

    def __len__(self):
        return int(self.numberofips)

    def __iter__(self):
        """
        We need to use yield here or else we will have to store 
        huge amounts of ips
        """
        start=0
        end=1
        if self.netmask == 32:
            yield socket.inet_ntoa(big_order(self.ip))
        elif self.netmask>=24:
            start=1

        for i in xrange(start,self.numberofips-end):
            yield socket.inet_ntoa(big_order(self.ip+i))


def getIPList(ip):
    """
    Returns a list of IP's from 128.8.*.*
    or 128.8.0.0/16
    """

    #if ip is a name/netmask
    ret=[]
    if ip.count("*"):
        number=ip.count("*")
        if number>3:
            print "Too many *'s in IP address!"
            return None

        digits=ip.split(".")
        netmask=32-number*8
        digits=digits[:4-number] #adjust to account for *'s
        while len(digits)<4: digits.append("0") #insert zeros
        ip=".".join(digits)

    elif ip.count("/"):
        (ip,netmask)=ip.split("/")
        ip=socket.gethostbyname(ip) #we may have a hostname, so convert it
        netmask=int(netmask)

    else:
        print "Single IP %s"%ip
        ip=socket.gethostbyname(ip)
        netmask=32

    #at this point we hvae a ip and a netmask
    #print "Network is %s"%ip
    #print "netmask is %d"%netmask
    return IPList(ip,netmask)


def rawhexstr(fp):
    """ makes a raw hex string out of another string """
    return "%2.2x%2.2x%2.2x%2.2x"%(ord(fp[0]),ord(fp[1]),ord(fp[2]),ord(fp[3]))


def testip():
    """
    A small function that tests our getIPlist function
    """
    for i in getIPList("192.168.1.255/24"):
        print i


def ber_encoded_string(instr):
    """
    Returns a ASN1 BER encoded string (if the string is < 255)
    (for long strings, we return nothing!!)
    """
    tmp=""
    tmp+=s_binary("13")
    if len(instr)<255:
        tmp+=chr(len(instr))
        tmp+=instr
    return tmp


# FIXME doesnt read until "\r\n\r\n" but only 1000bytes
def getWWWHeader(host,port,ssl=0,sock=None):

    if sock==None:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    else:
        s=sock

    try:
        print "Connecting to: ", host, "port:", port
        s.connect(host,port)
    except:
        return ""


    # setup function pointers
    if(ssl):
        sslsock=socket.ssl(s._sock)
        trecv = sslsock.recv
        twrit = sslsock.write
    else:
        trecv = s.recv
        twrit = s.send


    sploitstrings = [ "GET / HTTP/1.0\r\n\r\n", "HEAD / HTTP/1.0\r\n\r\n" ]
    sploitstrings += ["GET / HTTP/1.1\r\nHost: localhost\r\n\r\n" ]

    for sploitstring in sploitstrings:

        print "Trying with: ", sploitstring        
        twrit(sploitstring)

        result = ""
        while(True):
            if "400 Bad Request" in result and "Server" not in result:
                continue
            # We cap at 20kb to avoid reading huge files
            if(len(result)>20000):
                break
            try:
                tres = trecv(1000)
                if(tres == None or tres == ""):
                    #got something, so let's return?
                    break
                result += tres
            except:
                continue



            time.sleep(0.001)

        # We got a response from get don't bother with head
        if result:
            break

    return result


def uniquedict_val(d):
    """
    Goes through the dictionary finds unique *values* not keys and returns them in a list
    somewhat useful for manipulating element pairs
    """
    uql = []
    for x in d:
        if d[x] not in uql:
            uql.append(d[x])

    return uql


def uniquelist(alist):
    """
    Looks at all the elements in a list, and returns a new list
    that contains only the uniq elements.

    On Win32, you don't want the path to contain duplicates, as this
    greatly slows down module loading, so it's a good idea
    to use this function on sys.path after sys.path.append()

    (somewhat slow - probably you don't want to use this in a loop)
    """
    outlist=[]
    for a in alist:
        if a not in outlist:
            outlist.append(a)
    return outlist


def heapIndex(base, size):
    """Used for finding the lookahead buffer in win32 heap overflows
    """
    size += 0x0f
    size &= 0xfffffff8L
    size = size >> 3
    index = size*0x30
    index += 0x688
    index += base
    return index


def reversestring(data):
    #reverse data - we can't assume 2.3 here, so we have to do this the hard way
    l=[]
    l.extend(data)
    l.reverse()
    data2="".join(l)
    return data2


def isprint(str):
    for i in str:
        if not i in string.printable:
        #if not ord(i) in range(0x20,0x7f):
            return 0
    return 1

def getsearchpatternoffset(registerval, mychr="\xcc", startchar=0x01, badchars=""):
    """
    If you use searchpattern and you end up with
    eip=0xcccccc45, this function will return
    4*4 (aka 16)

    registerval is either an int, long or a string value
    """
    if type(registerval) in [type(1), type(1L)]:
        findme=intel_order(registerval)
    elif type(registerval)==type(""):
        findme=registerval
    else:
        print "Don't know how to deal with type: %s"%type(registerval)
    length=4*256*2 #max length, essentially
    ret=searchpattern(length, mychr, startchar, badchars).find(findme)
    return ret

def new_searchpattern(length):
    """
    TODO:
    generate a string from only A-Z

    total=0

    i2strlist=[]
    for c in xrange(ord("A"),ord("Z")):
        i2strlist+=[chr(c)]
    #so now, i2strlist[4]=="D", etc 
    #we can represent any decimal number by such:
    #1000 = BAAA. Arg. This won't work. Need to avoid
    #duplicates. so each block of 4 bytes is unique.
    #need to literally convert into base 26
    Better might be to do a random method for generating
    the string - have to create our own really simple
    random number generator  that is very predictable
    md5sum("CANVAS") and then md5sum of that, over and over
    mod 26
    """

import md5
def md5sum_file(filename):
    """
    Gets an md5sum on a file, returns it as a string
    """
    fd=file(filename,"rb")
    mymd5=md5.new()
    while 1:
        try:
            data=fd.read(1000)
        except:
            break 
        if data=="":
            break
        mymd5.update(data)
    ret=mymd5.hexdigest()
    return ret 
    
    
def searchpattern(length,mychr="\xcc", startchar=0x01, badchars=""):
    """
    Length is in bytes.
    
    Creates a pattern that looks like this:
    intel_order(0xcccccc41)+
    intel_order(0xcccccc42)+
    intel_order(0xcccccc43)+ ...

    And so on. This is useful for finding out where in your
    attack string a particular register has been loaded from.

    """
    i=0
    ret=""
    length=int(length)
    if type(startchar)==type(""):
        #if the user passed in a character, we convert it
        startchar=ord(startchar)
        
    while len(ret) < length:
        j=0
        while j<(256-startchar):
            if chr(startchar + j) not in badchars:
                ret+=chr(startchar+j)+mychr*3
            j+=1
            if len(ret)>=length:
                break
        i+=1
        mychr=chr(ord(mychr)+1)
    #in case length was not %4, we add padding here
    ret+=mychr*(length%4)
    ret=ret[:length]
    return ret


def reliablerecv(s,length):
    datalist=[]
    readlength=0
    while readlength<length:
        tmp=s.recv(length-readlength)
        if tmp=="":
            break
        readlength+=len(tmp)
        datalist.append(tmp)
    data="".join(datalist)
    return data


def usage(app):
    """
    TODO:
    override theexploit.getargs() with a faked argsDict object
    that simple tells us every argument we tried to load from
    and then we can automatically populate the self.options 
    for that exploit.
    """
    import sys
    print "="*20 + "main options" + "="*22
    print "Standard options: -v <version> -t <host> [ -p <port> ]"
    print "Callback options: -l <localhost> -d <localport>"
    print "="*20 + "additional options" +"="*16
    print "Toggle test mode: -T"
    print "Set covertness: -C <covertness>"
    print "="*10 + "custom options (use -O option:value)"+ "="*8
    try:
        for option in app.options:
            print option
    except:
        pass
    print "="*20 + "versions" + "="*26
    try:
        app.displayVersions()
    except AttributeError:
        pass
    try:
        app.engine.shutdown()
    except:
        pass

    sys.exit()

#used by canvasntlm and msrpc.py
def unicode2ascii(buf):
    result=""
    for a in range(0, len(buf)):
        if not a%2:
            result+=buf[a]
    return result

def nounizeros(buf):
    if not buf:
        return ""
    ret=buf.replace("\x00","")
    return ret

class Fortune:
    def __init__(self, file = "fortunes.txt"):
        try:
            self.__lines = open(file).readlines()
        except:
            self.__lines = [""]
        self.__index = -1
        import random
        random.shuffle(self.__lines)
    def __str__(self):
        self.__index += 1
        self.__index %= len(self.__lines)
        return self.__lines[self.__index].replace('&', '\n')[:-1]

def randomlist(randomlist):
    """
    Out of this list, pick a random one and return it
    """
    index=random.randint(0,len(randomlist)-1)
    return randomlist[index]

def get_random_letters(length):
    letters=["a","b","c","d","e","A"]
    ret=""
    for i in range(0,length):
        ret+=randomlist(letters)
    return ret

def filesize_backup(crashname, crashname_backup, maxsize):
    """
    backs up a crashlog if necessary
    """
    try:
        f=file(crashname,"r")
        f.seek(0,2) #seek to end
        size=f.tell()
        f.close()
        if size>maxsize:
            print "Removing old crash file %s"%crashname_backup
            try:
                os.remove(crashname_backup)
                print "File %s removed"%crashname_backup
            except:
                pass 
            print "Renaming %s to %s"%(crashname, crashname_backup)
            os.rename(crashname, crashname_backup)
            print "Renamed %s to %s"%(crashname, crashname_backup)
    except OSError, msg:
        print "OSError: %s"%msg
        #no file to remove (windows error?)
        pass 
    except IOError, msg:
        print "IOError: %s"%msg 
        #no file to remove (linux error)
        pass 
    return 

def bugreport():
    """
    Looks to see if our CRASH.log is > a large file should be
    and if it is, then moves it to the CRASH.bak file, removing that
    if it exists already.

    Writes (appends) a log of everything that happened in the crash to 
    the CRASH.log

    Obeys the canvas_root_directory global so you can store these
    correctly even if using canvas in some way we haven't intended yet.
    """
    # TODO: lock on file?
    import os, sys, datetime, traceback
    from versionsinfos import versionsinfos
    from engine.config import canvas_root_directory
    crashname=os.path.join(canvas_root_directory, "CRASH.log")
    crashname_backup=os.path.join(canvas_root_directory, "CRASH.bak")
    maxsize=1000000

    #check to see if we need to back our file up (prevents
    #the disk from filling up, esp. on SILICA)
    filesize_backup(crashname, crashname_backup, maxsize)

    #now open our crashname
    try:
        f = file(crashname, "a")
    except IOError:
        print "Cannot load CRASH.log - using CRASH.log.PID instead"
        f = file(crashname+"."+str(os.getpid()), "a")
    f.write('-'*80 + "\n\n[0] date:\n\n    %s\n\n" % datetime.datetime.now().ctime())
    f.write("[1] path:\n\n    %s\n\n" % sys.path)
    f.write("[2] modules loaded:\n\n")
    modkeys = sys.modules.keys()
    modkeys.sort()
    for modname in modkeys:
        f.write(" module %s:\n  %s\n" % (modname, sys.modules[modname]))
    try:
        infos = versionsinfos()
        f.write("\n[3] versions:\n\n")
        for info in infos:
            f.write("    %s\n" % infos[info])
    except:
        # will that happen ? (check versionsinfos::versionsinfos)
        if hasattr(os, 'uname'):
            uname_str = str(os.uname())
        else:
            uname_str = os.name
        f.write("\n[3] uname:\n\n    %s\n" % uname_str)
    f.write("\n[4] argv:\n\n    %s\n\n" % sys.argv)
    f.write("[5] traceback\n\n")
    #sometimes we are called from an exception handler, but if we are
    #not, then we really want the stack, not the exception...
    #this bug took a while to find. :<
    traceback.print_stack(file=f)
    traceback.print_exc(file=f)
    #also print to stderr, for the user to see.
    traceback.print_stack(file=sys.stderr)
    traceback.print_exc(file=sys.stderr)

    f.write("\n\n")
    f.close()

def filterdict(dontuse, adict):
    """
    Copies a dictionary to another dictionary minus a few keys
    useful for pickle's __getstate__
    """
    newdict={}
    for key in adict:
        #will be none if it was removed while we are running this loop
        value=adict.get(key,None)
        if key not in dontuse:
            newdict[key]=value
    return newdict

def upperdict(dict):
    """
    for key in dictionary, make every key uppercase in a new dict
    """
    newdict={}
    for key in dict:
        newdict[str(key).upper()]=dict[key]
    return newdict

def bugtracker(trackedfunction, *funcargs):
    """
    should be called before starting any new thread
    """
    try:
        return trackedfunction(*funcargs)
    # imo SyntaxError should not happen on customer side, and we dont want to report that on dev side.
    # KeyboardInterrupt shouldn't be reported as well.
    except KeyboardInterrupt:
        if debug_enabled:
            raise
        print "Aborted by user."
        raise SystemExit
    except SystemExit:
        if debug_enabled:
            print "SystemExit raised."
        raise
    except: # we DO want bugreport of SyntaxError :/
        bugreport()
        if debug_enabled:
            import internal
            internal.logging.display("\n\n%s\n\n" % Fortune('misfortunes.txt'), internal.logging.colors.YELLOW, "")
            raise
        print "Some error occured, you should send the CRASH.log generated file to Immunity support team. (feedback@immunitysec.com)"
        raise SystemExit

def threadcheckMain(astr="Unknown"):
    """
    Reports a bug if we are not in the main thread, which means
    we are doing GUI actions in the wrong thread
    """
    currentthread=str(threading.currentThread())
    if "Main" not in currentthread:
        devlog("threading","Serious bug - the wrong thread called: %s"%astr)
        bugreport()
    return

def threadchecknonMain(astr="Unknown"):
    """
    Reports a bug if we are in the main thread, since we should NEVER
    be in the main thread in certain functions/classes (only the 
    GUI should be the main thread)
    """
    global threadchecknonMain_we_are_commandline 
    if threadchecknonMain_we_are_commandline:
        #it's ok to run in the main thread as a commandline... 
        #since that will be the only thread most likely
        return 

    currentthread=str(threading.currentThread())
    if "Main" in currentthread:
        devlog("threading","Serious bug - the wrong thread called: %s"%astr)
        bugreport()
    return

def standard_callback_commandline(app,node=None,args=None, fromcommandline=True, quoteparse=False):
    """
    Calls our command line parser and sets a global to let our thread-checker
    know it's ok to execute things in the main thread.

    On the other hand, we want to eventually thread off our commandline interface
    at which point we should remove that global
    """
    global threadchecknonMain_we_are_commandline 
    threadchecknonMain_we_are_commandline = True

    return bugtracker(_standard_callback_commandline, app, node, args, fromcommandline, quoteparse)


def quoteparse_split(args):
    """
    Transforms a string of "-O bob:1 -O bob2:"1 1"" into a list of arguments,
    with the "1 1" as a single argument.
    We could use lexx/yacc here, but it seemed like overkill.
    """
    quoted=False #true if we are in a quoted string
    escape=False #true if previous character was a \ and we were not in escape mode
    #go character by character and split this up
    current="" #this holds the current argument
    ret=[]
    for c in args:
        if c == " " and not quoted:
            #we finshed an argument
            ret.append(current)
            current=""
        elif c == "\\" :
            #handle backslashes carefully since they are our escape character
            if not escape:
                #we are now in escape mode
                escape=True
            else:
                #we escaped a backslash
                current+="\\"
        elif c == "\"":
            #quote characters are also special
            if escape:
                current+="\""
            elif quoted:
                #quoted, so we're done with that string - the next space should let us save an argument
                quoted=False
            else:
                #not quoted, so start a quote now
                quoted=True 
        else:
            current+=c 
    #final string
    ret.append(current)        
    #ret has our arguments now
    return ret 
            
            
          
        

def commandline_fromengine(app, node, args):
    """
    Used to call the commandline function from the canvas engine
    """
    _standard_callback_commandline(app, node, args,  fromcommandline=False , quoteparse=True)
    return

def _standard_callback_commandline(app,node=None,args=None, fromcommandline=True, quoteparse=False):
    """
    Parses arguments and runs a module with those arguments
    
    node can be a list of nodes as well (used when called from the engine)
    
    """
    import getopt

    def disp_usage(msg=None):
        if msg:
            print msg
        if hasattr(app, 'usage'):
            app.usage()
        else:
            devlog('all', "Commandline Error: Exploit class doesn't have a usage() method")
            usage(app)

    # XXX license_check() here? || canvas_startup() (common gui/cmdline)

    doexit=0
    if args==None and fromcommandline:
        args=sys.argv[1:]
        doexit=1
    else:
        try:
            args2=args+"\n"
            #simple parser here
            if not quoteparse:
                #just split on spaces (we are getting this from the bash shell, which already did our parsing)
                args=args.split(" ")
            else:
                #do quotes ourselves.
                #TODO
                args=quoteparse_split(args)
        except:
            #not a string
            pass
    #print "Args=%s"%args
    try:
        opts, args = getopt.getopt(args, "sv:t:p:l:d:TC:m:U:F:O:P:")
        #print "opts=%s arts=%s"%(opts,args)
    except getopt.GetoptError, info:
        disp_usage("Error in arguments: %s" % info)
        if doexit and app.engine:
            if hasattr(app.engine, 'shutdown'):
                app.engine.shutdown()
            else:
                print app.engine
                devlog('all', "Commandline Error: Exploit class doesn't have a shutdown() method")
        return 0
    #print "Starting parser"
    test = 0
    i = 0
    version=0
    covertness=1
    target="1"
    port = 0
    #localhost=""
    localport=0
    if hasattr(app, 'port'):
        port = app.port
    if hasattr(app, 'localport'):
        localport = app.localport
    localhost=""
    #if hasattr(app, 'localhost'):
    #    localhost = app.localhost
    argsDict=app.argsDict
    for o, a in opts:
        #print "Parsing arg: %s"%o
        if o == "-v":
            version = int(a)
        if o == "-t":
            i+=1
            target = a
        if o == "-p":
            port = int(a)
        if o == "-T":
            i+=1
            test = 1
        if o == "-l":
            i+=1
            localhost = a
        if o == "-d":
            i+=1
            localport = int(a)
        if o == "-C":
            covertness=int(a)
        if o == "-m":
            argsDict["method"] = int(a)
        if o == "-U":
            argsDict["user"]= a
        if o == "-P":
            argsDict["password"]= a
        if o == "-F":
            argsDict["filename"]= a
        if o == "-Q":
            argsDict["helperhost"] = a
        if o == "-T":
            argsDict["command"] = a
        if o == "-O":
            i=a.find(":")
            name=a[:i]
            value=a[i+1:]
            argsDict[name]=value


    if app.engine==None:
        import canvasengine
        app.engine=canvasengine.canvasengine(None)



    try: 
        if localhost!="":
            # if it needs resolving, resolve it
            try:
                localhost = socket.gethostbyname(localhost)
            except:
                pass
            print "localhost=%s"%localhost
            from listenerLine import fakeListenerLine
            app.callback=fakeListenerLine(localhost,localport)
    except UnboundLocalError:
        disp_usage("Don't forget the localhost/localport parameters (-l and -d as in dog)")

        if doexit:
            if app.engine:
                app.engine.shutdown()
        return 0

    #check to see if we were passed a list of nodes - this will
    #happen if called from the engine
    nodes=None 
    if type(node) == type([]):
        nodes=node 
        node=node[0]
        
    if node==None:
        if app.engine:
            #we don't want to create our OWN local node if we already have one
            node=app.engine.getLocalNode()
        else:
            from localNode import localNode
            node=localNode() 

    from hostKnowledge import hostKnowledge, knowledgeContainer
    container=knowledgeContainer(node)
    app.target=hostKnowledge(target,container)

    #for debugging our pickle stuff
    #app.target.save_to_file()
    if nodes:
        argsDict["passednodes"]=nodes
    else:
        argsDict["passednodes"]=[node]
    argsDict["port"]=port
    argsDict["localhost"] = localhost
    argsDict["localport"] = localport
    app.argsDict=argsDict
    app.version=version
    app.covertness=covertness

    if test == 1:
        if not hasattr(app, 'test'):
            print "[!] that module does not have a test() function"
        else:
            #print "Running test"
            if app.test():
                print "[+] This server seems vulnerable"
            else:
                print "[-] Server does not seem vulnerable"
        if doexit:
            app.engine.shutdown()
        return 1

    if i < 1 and fromcommandline: # XXX
        disp_usage("[C] Not enough arguments (%d)\n" % i)

        #print "Doexit=%d"%doexit
        if doexit:
            app.engine.shutdown()
        return 0
    try:
        app.createShellcode()
    except AttributeError:
        print "[C] Shellcode could not be created. No callback specified"
        import traceback
        traceback.print_exc(file=sys.stderr)
        return 0
    
    shell = app.run()
    
    if localhost!="":
        print "[C] done -- connectback set to %s:%d"% (localhost, localport)
    if doexit:
        devlog("canvasengine", "standard_callback: shutting down engine")
        app.engine.shutdown()
        devlog("canvasengine", "standard_callback: shut down engine")
    if shell not in [1,0,None,-1]:
        devlog('engine', "Setting engine to %s" % app.engine)
        if type(shell)==type(""):
            devlog('engine',"Error, module returned a string: %s!"%shell)
            shell=0
        else:
            shell.engine=app.engine
    #return either a shellserver or a return code
    return shell


def getlines(astr,bugline):
    """
    prints the 3 lines before and after the line our bug is one
    """
    lines=astr.split("\n")
    lines=lines[bugline-3:bugline+3]
    return "\n".join(lines)


def printlines(astr,bugline):
    data=getlines(astr,bugline)
    print "-"*80+"\n"+data+"\n"+"-"*80
    return


def snort_websend(s,pkt,timeout=60.0):
    #sends one byte at a time to annoy snort-like IDS's
    #basically IDS's can't afford to store the same state as IIS. Funny, huh?


    print "Sending %d packets to attempt to avoid an ids with time delay between packets of %f"%(len(pkt),timeout)
    start=pkt.find("/")
    if start==-1:
        start=4
    header=pkt[start:].find(" ")
    if header==-1:
        header=30
    print "The packets from %d to %d will be sent with a delay between them"%(start,header)
    s.sendall(pkt[:start])
    for c in pkt[start:header]:
        s.sendall(c)
        time.sleep(timeout)
    s.sendall(pkt[header:])
    print "Done sending"
    return


def snort_sendall(s,pkt,timeout=61.0):
    #sends one byte at a time to annoy snort-like IDS's

    print "Sending %d packets to attempt to avoid an ids with time delay between packets of %f"%(len(pkt),timeout)
    start=0
    header=len(pkt)
    print "The packets from %d to %d (out of %d) will be sent with a delay between them"%(start,header,len(pkt))
    i=start
    s.sendall(pkt[:start])
    for c in pkt[start:header]:
        s.sendall(c)
        print "Sent packet %d"%i
        i+=1
        time.sleep(timeout)
    s.sendall(pkt[header:])
    print "Done sending"
    return


def strip_leading_path(source):
    "directory/file.exe to file.exe"
    i = len(source)-1
    try:
        while source[i] != '\\' and source[i] != '/':
            i -= 1
    except IndexError:
        i = -1
    source = source[i+1:]
    return source


def intersection(str1,str2):
    """
    for finding which bad chars you have
    """
    ret=[]
    for c in str1:
        if c in str2:
            ret+=[c]
    return "".join(ret)


def lazy_recv(fd,length):
    buf="A"
    fullbuf=[]
    wanted=length
    while buf!="" and wanted > 0:
        try:
            buf=fd.recv(wanted)
        except timeoutsocket.Timeout:
            break
        fullbuf+=[buf]
        wanted-=len(buf)

    return "".join(fullbuf)


def host_is_interesting(host):
    """
    Hosts are not interesting if they are loopback or multicast, etc.
    """
    ip = socket.inet_aton(host)
    lip = str2int32(ip)
    if lip == 0xffffffffL: # broadcast
        return False
    a = lip >> 24
    if a == 127: # loopback
        return False
    if a == 224: # multicast
        return False
    if a == 240: # badclass
        return False

    # does that interest someone?
    if (lip & 0xe0000000L) == 0xe0000000L: # experimental
        return False
    return True


def select_stdin_and_socket_for_reading(sockfd, timeout = 0.2):
    """
    checks to see if the user has entered any data, otherwise looks
    to see if the remote side has caused an error of any kind
    """
    import select

    try:
        rd = []
        wr = []
        ex = []
        
        if sockfd == None:
            # remote: HTTP/ICMP/ETC. .. no sockfd
            rd, wr, ex = select.select([sys.stdin.fileno()], [], [], timeout)
        else:
            rd, wr, ex = select.select([sockfd, sys.stdin.fileno()], [], [], timeout)
    except TypeError:
        print "Typeerror on select: sockfd is %s type (you can't shellshock HTTP MOSDEF)" % type(sockfd)
        raise
    except select.error, (errcode, errmsg):
        if errcode == 10038: # win32 ENOTSOCK
            import os
            if os.name != 'nt':
                raise
            import msvcrt
            while True:
                rd = []
                wr = []
                ex = []
                # if remote == HTTP, do not try to select on sockfd
                if sockfd != None:
                    rd, wr, ex = select.select([sockfd], [], [], timeout)
                if msvcrt.kbhit():
                    rd += [sys.stdin.fileno()]
                if rd != []:
                    return (rd, [], [])
            raise select.error
    return (rd, [], [])

def tlssock(sock):
    """
    Creates a TLS Socket from a normal socket (returns object)
    """
    #HANDLE SSL HERE
    settings=HandshakeSettings()
    settings.minKeySize=512 #some servers have a very small key
    settings.maxVersion=(3,1) #servers hate it when you are TLSv1.1
    connection=TLSConnection(sock)
    connection.handshakeClientCert(settings=settings)
    return connection

def writeflush(msg, file = sys.stdout):
    file.write(msg)
    file.flush()

def no_double_spaces(astr):
    """
    Replaces all strings of spaces with one space
    Not a fast function.
    """
    oldstr=""
    while oldstr!=astr:
        oldstr=astr
        astr=astr.replace("  "," ") #two spaces to one
    return astr 

#We do this once to get the user data
try:
    expiredate,contactemail=file("userdata","r").readlines()[:2]
except:
#    print "Did not find userdata file"
    expiredate="0/0/0"
    contactemail="bob@example.com"

###DNS Routines to find SMTP servers (used by smtp_fingerprinter and such)
#we do some tricks here to return the longest host first
def lens(a,b):
    return cmp(len(a),len(b))

def split_host(host):
    """
    Returns list of hosts from one host
    """
    tmp=[]
    hosts=host.split(".")
    for a in range(len(hosts)):
        tmp+=[".".join(hosts[-a:])]
    tmp.sort(cmp=lens,reverse=True)
    return tmp

def get_mx(host):
    """
    Linux only - gets the MX if possible for a host
    """
    #TODO: Add Windows support here.
    
    sin,sout_err = os.popen4("which host")
    data=sout_err.read()
    #print "which host data:%s"%data
    if "host" in data:
        #print "We have host command"
        #we have host command
        sin,sout_err = os.popen4("host -t mx %s"%host)
        data=sout_err.readlines()
        #print "host data: %s"%data
        #note, the following check is broken by non-English versions of Linux :<
        #we should be able to say "LANG=C" I believe to normalize this?
        if "is handled by " in data:
            #dave@ubuntu:~$ host -t mx immunityinc.com
            #immunityinc.com mail is handled by 0 a.mx.immunityinc.com.
            mail_server=data.split("is handled by")[1].split(" ")[1]
            return mail_server

    sin,sout_err = os.popen4("which dig")
    data=sout_err.read()
    if "dig" in data:
        #we have dig
        sin,sout_err = os.popen4("dig mx %s"%host)
        data=sout_err.readlines()
        answer=False 
        for line in data:
            if answer or line.count(";; ANSWER"):
                answer=True 
            else:
                continue
            if line.count("MX"):
                host =line.split(" ")
                #print "Host split: %s"%host 
                host= host[-1].strip()
                #print "MX found: %s"%host 
                return host 
            
    #print "MX for %s not found"%host 
    return None 


if __name__=="__main__":
    print "testing exploitutils code (uncomment what you want to test)..."
    #print "Str_from_object test=%s"%str_from_object(["HELLO", {"HELLO2": 1}])
    #hl=IPList("1.1.1.1",bits(0xff000000L))
    #for h in hl:
    #    print h
    searchstring=searchpattern(200,badchars="\r\n")
    print "Searchstring=%s"%repr(searchstring)
    off=0x10ccccccL
    print "Offset of %x = %d"%(off,getsearchpatternoffset(dInt(off),badchars=""))
    """
    print "- local IPs"
    print getAllLocalIPs()
    print "Getting IPv6 IPS"
    print getIPv6FromInterfaceLinux("eth0")
    print "Done getting IPv6 IPS"
    #print getNetworkInterfaces()
    #data=file("ipconfig1.txt").read().replace("\n","\r\n")
    if 0:
        import os
        data=os.popen2("ipconfig /all")[1].read()
        print parseipconfig(data)
    print "- ARP table"
    print getIPfromARPTable()
    if sys.platform.count("sunos"):
        print getIPfromInterface("pcn0")
    """
