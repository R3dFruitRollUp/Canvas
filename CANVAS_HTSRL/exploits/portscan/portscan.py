#! /usr/bin/env python

#Proprietary CANVAS source code - use only under the license agreement
#specified in LICENSE.txt in your CANVAS distribution
#Copyright Immunity, Inc, 2002-2006
#http://www.immunityinc.com/CANVAS/ for more information


# CANVAS Portscan module
#
# Bug class: Recon
# 

import sys
if "." not in sys.path:
    sys.path.append(".")

import os
import socket
import time

# CANVAS modules
from exploitutils import *
from tcpexploit import *
from sniffer import sender
from sniffer import packetConstructor
import random
from msrpcexploit import allnamedpipes
import timeoutsocket
# GUI info
NAME="Portscanner"
DESCRIPTION="Portscanner"
DOCUMENTATION={}
DOCUMENTATION["Notes"] = "This is a scanrand-like portscanning module\nthat uses a sniffer and raw socket sender\nto do extremely fast portscanning (1000 ports per minute)"
DOCUMENTATION["CLINotes"] = "exploits/portscan/portscan.py -O portlow:1 -O porthigh:200 -t 192.168.103.130"
DOCUMENTATION["Callback"]="Make sure you have the callback set to the right IP! Otherwise the TCP checksum will be incorrect and all the packets will be dropped..."
DOCUMENTATION["Windows"]="For XP, this link is helpful: http://support.microsoft.com/kb/314053"
VERSION="0.1"

PROPERTY = {}
PROPERTY['TYPE'] = "Recon"
PROPERTY['SITE'] = "Remote"

NOTES="""

For commandline, you'll want to use -O source:SOURCEIP to avoid bad checksums

"""

CHANGELOG="""
"""

#TCP ports we assume are never going to be MSRPC ports
noifidsports=[21, 22, 25, 53, 80, 25, 110, 111, 143, 443, 465, 515]

class theexploit(tcpexploit):
    def __init__(self):
        tcpexploit.__init__(self)
        self.setInfo(DESCRIPTION)
        # used for done flag from commandline
        self.done = 0
        self.port=53 #if fromport is 0 we randomize it
        self.closedports=[]
        self.openports=[]
        self.ifids_did_check={} #we do O(N) search through this per packet - very bad. Is there any easier way?
        #I guess we could make it a dictionary and do a get.(openport,0)...to investigate later
        self.name=NAME
        self.covertness = 0
        self.setVersions()
        self.timeout=0.5
        self.result=self.openports
        #source=self.engine.get_callback_interface().ip
        self.source="127.0.0.1"
        self.UUID=None # the interface we're looking for if looking for an MSRPC interface
        self.UUIDfound=None # the port we found the UUID on
        self.namedpipe=None #pipe we found our UUID on
        return
        
    def setVersions(self):
        self.versions={}
        self.versions[0]=("Fast CANVAS Scan (requires root)", None)
        self.versions[1]=("TCP Connect Scan", None)
        
    def test(self):
        """All targets can be portscanned"""
        return 1
    
    def snooze(self, seconds):
        self.log("Snoozing (%d seconds)"% seconds)
        while seconds:
            self.log("%.2d seconds left in snooze"% seconds)
            time.sleep(1)
            seconds = seconds - 1 
        return 1

    def closedcallback(self,parser):
        self.closedports+=[parser.attribs["tcpsource"]]
        return

    def opencallback(self,parser):
        openport=parser.attribs["tcpsport"]
        #we don't do this is we already know about that port
        if openport in self.openports:
            return 
        self.openports+=[openport]
        self.log("Found open port %s:%d"%(self.host,openport))
        #devlog('portscan::openports', "Found open port %s:%d" % (self.host, openport))
        #print "Found open port %s:%d" % (self.host, openport)
        #there's never an MSRPC endpoint on 21,25,111, etc so we ignore these for ifids checks 

        if (openport not in noifidsports) and self.UUID and not self.ifids_did_check.get(openport,0):
            self.log("Scanning port %d for UUID %s"%(openport,self.UUID))
            self.ifids_did_check[openport]=1
            result=self.ifidscheck(openport)

        return
    
    def scanrand(self,allports):
        # Fast CANVAS SCAN
        #first, we need to register as a callback with the sniffer
        #then we need to scan the ports      
        if self.UUID:
            self.log("Don't do scanrand when looking for UUID")
            return 0
        
        if not self.engine.sniffer_isactive():
            self.log("sniffer not active")
            self.setInfo("Portscan: sniffer not active - cannot do raw socket mode.")
            return 0
        
        if self.node.nodetype!="LocalNode":
            self.log("Cannot do a scanrand-style scan from a remote node.")
            #can't do scanrand from remote nodes
            return 0

        # scanrand not supported for IPv6 yet
        if ":" in self.host:
            self.log("[XXX] no IPv6 support for ScanRand yet !")
            return 0
        
        try:
            mysender=sender()
        except:
            self.log("Failed to open a raw socket...")
            return 0
        closedfs="ipsource(%s) tcpflags(RST) tcpflags(ACK)"%self.host
        openfs="ipsource(%s) tcpflags(SYN) tcpflags(ACK)"%self.host
        #self.engine.register_sniffer_callback(self.closedcallback,closedfs)
        self.engine.register_sniffer_callback(self.opencallback,openfs)
        top=2
        source=self.source
        self.log("Source IP=%s"%source)
        mpacker=packetConstructor()
        dest=self.host

        for tries in range(1,top):
            self.log("Try %d/%d"%(tries,top-1))
            #have to do retries to make sure things work - well, no we don't
            #but we'll leave the possibility in regardless
            totallength=len(allports)
            current=0
            for port in allports:
                if self.done:
                    self.engine.unregister_sniffer_callback(self.opencallback)
                    return 0
                if self.state==self.HALT:
                    self.log("Ending portscan on port %d"%port)
                    self.setInfo("%s stopped on port %d"%(NAME,port))
                    self.log("Open ports found so far: %s"%self.openports)
                    self.engine.unregister_sniffer_callback(self.opencallback)
                    return 0

                    
                current+=1
                if current % 100 == 0:
                    self.log("Portscan scanning for port %d"%current)
                    self.setProgress(((current*1.0)/(totallength*1.0))*100)

                    #our source is just the callback interface...

                #self.log("source=%s"%source)
                mpacker.clear()
                #self.port is really self.fromport here
                #print "source=%s:%s dest=%s:%s" % (source, self.port, dest, port)
                mpacker.TCP(source,dest,["SYN"],self.port,port,"")
                mysender.sendto(mpacker.get(),"TCP",(dest,0))
                #if you don't sleep, you'll miss some ports. 
                time.sleep(0.01)
        mysender.close() #close all raw sockets for sending
        self.log("Sleeping to recover any lost packets...")
        time.sleep(2)
        self.engine.unregister_sniffer_callback(self.opencallback)
        #add this knowledge to the target

        return 1

    def ifidscheck(self,port):
        """
        Looks to see what ifids are available on that port
        saves the results in self.UUIDfound and self.namedpipe
        returns a list of the ifids possible to find on this port
        
        can be called in any of the thousands of threads we start up
        returns False when we did not find it
        """
        if self.done:
            #no need to check this port 
            self.log("Not checking port %d since we're already done"%port)
            return False 
        ifidsscan=self.engine.getModuleExploit("ifids")
        ifidsscan.link(self)
        ifidsscan.port=port
        done=False
        if port in [139,445]:
            #run a loop
            self.log("Running ifids on all named pipes")
            for pipe in allnamedpipes:
                #can't do this because other threads are setting self.done!
                #if self.done:
                #    self.log("Found our UUID on named pipe %s"%pipe)
                #    return ifidsscan.result
                ifidsscan.namedpipe=pipe
                ifidsscan.run()
                result=ifidsscan.result
                if result and self.UUID:
                    for interface in result:
                        if interface[2]==self.UUID:
                            #we don't check the IFID's version
                            #we found it!
                            self.UUIDfound=port
                            self.namedpipe=pipe
                            self.done=1
                            return result
        
        else:
            #just run once
            ifidsscan.run()
        result=ifidsscan.result
        
        if result and self.UUID:
            for interface in result:
                if interface[2]==self.UUID:
                    #we don't check the IFID's version
                    self.UUIDfound=port
                    self.done=1
                    return result
                    #we found it!

            self.log("Did not find UUID %s in that ifids list"%self.UUID)
        return False 

    def getargs(self):
        self.host = self.target.interface
        self.timeout = float(self.argsDict.get("timeout", self.timeout))
        self.UUID= self.argsDict.get("UUID",self.UUID)
        #annoyingly, more args below in run()
        return 
        
    def run(self):
        allports = startport = endport = None
        self.getargs()
        if self.host in [ "0.0.0.0" ] :
            self.log("Portscan of host %s is insane. Select a target."%self.host)
            return 0 
        if self.UUID:
            self.log("Portscan is looking for UUID %s"%self.UUID)
                    
        fastscan = self.argsDict.get("fastscan", False)
        if fastscan in ["yes", "1"]: fastscan = True
        elif fastscan in ["no", "0"]: fastscan = False
        elif fastscan != False: fastscan = True # assuming we want it...
        scanmode = self.argsDict.get("mode", "portrange")
        portrange_mode=False 
        allports_mode=False 
        self.log("Portscan Scanmode=%s"%scanmode)
        self.port = int(self.argsDict.get("port", self.port))
        if scanmode == "portrange":
            portrange_mode = True
            portlow = int(self.argsDict.get("portlow", 1))
            if portlow:
                startport = portlow
            porthigh = int(self.argsDict.get("porthigh", 10000))
            if porthigh:
                endport = porthigh
            allports=xrange(portlow, porthigh+1)
        elif scanmode == "chosen ports":
            allports=self.argsDict.get("allports",[])
            self.log("Scanning %d ports"%len(allports))
        else: #if scanmode == "allports":
            allports_mode = True

        postscan_ifids = self.argsDict.get("postscan_ifids", False)
        postscan_http = self.argsDict.get("postscan_http", False)
        if postscan_ifids and postscan_http:
            self.postscan = "all"
        elif postscan_ifids:
            self.postscan = "ifids" #ifids for ifidsscan
        elif postscan_http:
            self.postscan = "http"
        else:
            self.postscan = self.argsDict.get("postscan", "")
        self.postscan=self.postscan.lower() #lowercase it
        self.source=self.argsDict.get("source",self.engine.get_callback_interface(self.host))
        self.log("Portscan Timeout=%f"%self.timeout)
        if fastscan:
            self.log("Using FastScan mode")
        self.setInfo("%s scanning %s (in progress)"% (self.name, self.host))
        self.log("%s scanning %s (in progress)"% (self.name, self.host))
        self.log("Postscan=%s"%self.postscan)
        
        self.node=self.argsDict["passednodes"][0]
        if not ":" in self.host: # XXX: ipv6
            self.host=socket.gethostbyname(self.host)
        if portrange_mode:
            self.log("Portrange mode enabled - scanning %d to %d"%(portlow,porthigh))
        if allports_mode:
            self.log("Determining port list by covertness")
            if self.covertness==1:
                self.log("Using all ports")
                if not startport: startport = 1
                if not endport: endport = 65535
            elif self.covertness<5:
                self.log("Using low and rpc ports")
                allports=range(1,1025)+[5900]+range(32700,35900)+range(65530,65536)
                if self.UUID:
                    #do the three major ones first
                    allports=[135,139,445]+allports
            else:
                self.log("Using low ports")
                if not startport: startport = 1
                if not endport: endport = 1024 # XXX or 2000 / 2025 ?
            if startport:
                self.log("Startport=%d endport=%d"%(startport,endport))
        if not endport: endport = 65535
        if not allports:
            allports = range(startport, endport + 1)
        now=time.localtime(time.time())
        strtime=time.strftime("%y/%m/%d %H:%M", now)
        self.log("Start time: %s"%strtime)
        tc0=time.time()

        #check for host unreachable, and if so, don't continue onwards
        self.log("Checking for host unreachable")
        self.ranportscan=self.target.get_knowledge("RanPortscan")

        if self.ranportscan and self.UUID:
            self.log("Looking for our UUID on all known open ports")
            ports=self.target.get_knowledge("TCPPORTS")
            if not ports:
                ports=[]
            for port in ports:
                port=int(port)
                result=self.ifidscheck(port)
                if result:
                    self.log("Found the ifid on port %d"%port)
                    return 1
            self.log("Did not find the IFID we were looking for")
            return 0 
                
            
        if not self.ranportscan:
            randomport=random.randint(1,65534)
            ret=self.C_isOpen(self.host, randomport,timeout=5)
            self.log("Scan of port %s:%s returned %s"%(self.host,randomport,ret))
            if ret=="Host Unreachable":
                self.log("Host %s is unreachable - not port scanning"%self.host)
                self.setInfo("Portscan of %s failed (Host Unreachable)"%self.host)
                return 0

        if not self.ranportscan:
            ret=self.scanrand(allports)
            if ret:
                self.log("Sleeping for 2 seconds to recover packets")
                time.sleep(2)
        #now add any open ports back to this list
        if self.done:
            #normally we would return 0... but if we have a UUID and a UUIDfound, then we're good to go
            if self.UUID and self.UUIDfound:
                return 1
            return 0
        
        
        if not self.ranportscan and ret == 0 and self.node.nodetype == 'LocalNode' and sys.platform in ['win32']:
            #can't do cygwin because fork() won't always work :<
            self.setInfo("Portscan: Doing tcpscan.exe Win32 Fast Asynchronous TCP Scan")
            self.log("Doing tcpscan.exe Win32 Fast Asynchronous TCP Scan")
            self.log("port range reduced to 1-2000")
            if not startport: startport=1
            if startport > 2000: startport = 2000
            if endport > 2001: endport = 2001
            allports = range(startport, endport + 1)
            #print sys.path
            if "." not in sys.path:
                sys.path.append(".") #tcpscan is in our local directory which needs to be in our path
            #we assume Windows XP SP2 or Windows Vista here
            max_wait_event=5 #you can only have 5 open TCP connections in Vista
            command = "tcpscan.exe %s %d %d %d" % (self.host,  startport, endport, max_wait_event)
            self.log("Running %s"%command)
            p = os.popen2(command)
            buf = p[1].read()
            self.log("Finished running tcpscan.exe")
            self.log(buf)
            l = buf.split('\n')
            for each in l:
                if each.find('/') == -1:
                    continue
                port=each.split(' ')[1].split('/')[0]
                self.openports.append(port)
                if port in noifidsports:
                    continue
                if self.UUID:
                    self.log("Looking for %s with ifidscheck"%self.UUID)
                    result=self.ifidscheck(port)
                if self.UUID and self.UUIDfound:
                    return 1
            #print self.openports
            ret = 1
        
        if not self.ranportscan and ret==0:
            #scanrand failed....do TCP scan
            self.setInfo("Portscan: Doing TCP Connect Scan")
            self.log("Doing TCP connect scan")
            self.log("Node capabilities: %s"%self.node.capabilities)
            if "win32api" in self.node.capabilities:
                self.log("Doing MOSDEF Win32 Fast Asynchronous TCP Scan")
                timeout=int(self.timeout*1000)
                self.log("Using startport: %d endport %d timeout %d"%(startport,endport,timeout))
                ret=self.node.shell.tcpConnectScan(self.host,startport,endport,timeout)

                self.log("Returned: %s"%ret)
                self.openports=ret[0][1]
            else:
                totallength=len(allports)
                current=0
                for port in allports:
                    #run our connect-scan against the target
                    if self.UUID and self.UUIDfound:
                        return 1
                    if self.done:
                        return 0
                    if self.getState()==self.HALT:
                        self.log("Ending portscan on port %d"%port)
                        self.setInfo("%s stopped on port %d"%(NAME,port))
                        self.log("Open ports found so far: %s"%self.openports)
                        return 0
                    self.setProgress(((current*1.0)/(totallength*1.0))*100)
                    current+=1
                    isopen=self.C_isOpen(self.host, port)
                    if isopen=="Open":
                        self.log("TCP Handshake found %d open"%port)
                        self.openports.append(port)
                        if self.UUID and (port not in noifidsports):
                            result=self.ifidscheck(port)
                    if isopen=="Host Unreachable":
                        self.log("Host %s unreachable"%self.host)
                        self.log("Stopping scan...")
                        break
                    
        now=time.localtime(time.time())
        strtime=time.strftime("%y/%m/%d %H:%M", now)
        self.log("Stop time: %s"%strtime)

        tc1=time.time()
        self.log("Seconds used: %s"%(tc1-tc0))
        self.openports=uniquelist(self.openports)
        #print "Closed: %s"%self.closedports
        self.openports.sort() # Make this look a bit better
        self.log("Open ports found on %s: %s"%(self.host,self.openports))
        self.log("All done")            
        self.openports=uniquelist(self.openports)
        self.target.replace_knowledge("TCPPORTS",self.openports,100)
        if (len(self.openports)+len(self.closedports))>1:
            """
            Our logic here is that we scanned a list of at least 2
            ports, which means we don't want to rescan this host
            """
            self.target.add_knowledge("RanPortscan", True, 100)        
        self.log("postscan=%s"%self.postscan)
        self.setInfo("%s scanning %s (Postscan: %s)"% (self.name, self.host,self.postscan))
        postscan=self.postscan
        doneports=[]
        if self.UUID:
            self.log("Not doing postscan %s because we are looking for a single UUID"%postscan)
        else:
            if postscan not in ["None",None,""]:
                self.log("Doing %s scan"%postscan)
                for port in self.openports:
                    if self.done:
                        return 0
                    port=int(port)
                    self.log("Postscan %s:%d"%(postscan,port))
                    if (port not in noifidsports) and (postscan_ifids or postscan in ["ifids","all"]):
                        result=self.ifidscheck(port)
                        if result:
                            doneports.append(port)
                            continue #no need to further check this - it's MSRPC
                    #we only get here if it's not MSRPC
                    if postscan_http or postscan in ["http","all"]:
                        httpscan=self.engine.getModuleExploit("httpfingerprint")
                        httpscan.link(self)
                        httpscan.port=port
                        self.log("Running httpscan")
                        httpscan.run()
                        if httpscan.result!=None:
                            doneports.append(port)
                            continue
        

        self.setInfo("%s scanning %s (done)"% (self.name, self.host))
        self.log("Portscanner finished with open ports: %s"%self.openports)
        return 1
    
    def shutdown(self):
        self.done=1
    
    def displayVersions(self):
        for v in self.versions.keys():
            print "\tVersion %d: %s"%(v,self.versions[v][0])
    
    def usage(self):
        import sys
        print "Usage: %s -t <host> -C <covertness> [ -O options:value ... ]\n" % sys.argv[0]
        print "   options:"
        print "        mode:               allports/portrange"
        print "        timeout:            time to sleep between each packet sent in second"
        print "        portlow,porthigh:   port range (imply mode:portrange)"
        print "        postscan:           ifids,http,all"
        print "        source:             ip source"
        print "        fastscan:           yes/no (yes by default)\n"

if __name__== '__main__':
    app = theexploit()
    ret=standard_callback_commandline(app)
